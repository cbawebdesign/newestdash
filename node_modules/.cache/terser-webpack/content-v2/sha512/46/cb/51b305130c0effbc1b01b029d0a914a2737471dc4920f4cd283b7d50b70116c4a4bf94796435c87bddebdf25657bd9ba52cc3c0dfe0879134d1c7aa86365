{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{\"6GwG\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,\"AdminModule\",function(){return admin_module_AdminModule});var common=__webpack_require__(\"SVse\"),flex_layout=__webpack_require__(\"u9T3\"),icon=__webpack_require__(\"Tj54\"),fesm2015_button=__webpack_require__(\"Dxy4\"),a11y=__webpack_require__(\"YEUz\"),observers=__webpack_require__(\"9b/N\"),portal=__webpack_require__(\"1z/I\"),core=__webpack_require__(\"8Y7J\"),fesm2015_core=__webpack_require__(\"UhP/\"),animations=__webpack_require__(\"omvX\"),Subject=__webpack_require__(\"XNiG\"),merge=(__webpack_require__(\"quSY\"),__webpack_require__(\"VRyK\")),fromEvent=__webpack_require__(\"xgIS\"),of=__webpack_require__(\"LRne\"),timer=__webpack_require__(\"PqYM\"),startWith=(__webpack_require__(\"GS7A\"),__webpack_require__(\"JX91\")),takeUntil=(__webpack_require__(\"/uUt\"),__webpack_require__(\"1G5W\")),coercion=__webpack_require__(\"8LU1\"),fesm2015_platform=__webpack_require__(\"SCoL\"),keycodes=__webpack_require__(\"Ht+U\"),bidi=__webpack_require__(\"9gLZ\"),scrolling=__webpack_require__(\"7KAL\");const _c0=[\"*\"],_c5=[\"tabListContainer\"],_c6=[\"tabList\"],_c7=[\"nextPaginator\"],_c8=[\"previousPaginator\"],_c9=[\"mat-tab-nav-bar\",\"\"],_MAT_INK_BAR_POSITIONER=new core.s(\"MatInkBarPositioner\",{providedIn:\"root\",factory:function(){return element=>({left:element?(element.offsetLeft||0)+\"px\":\"0\",width:element?(element.offsetWidth||0)+\"px\":\"0\"})}});let tabs_MatInkBar=(()=>{class MatInkBar{constructor(_elementRef,_ngZone,_inkBarPositioner,_animationMode){this._elementRef=_elementRef,this._ngZone=_ngZone,this._inkBarPositioner=_inkBarPositioner,this._animationMode=_animationMode}alignToElement(element){this.show(),\"undefined\"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>this._setStyles(element))}):this._setStyles(element)}show(){this._elementRef.nativeElement.style.visibility=\"visible\"}hide(){this._elementRef.nativeElement.style.visibility=\"hidden\"}_setStyles(element){const positions=this._inkBarPositioner(element),inkBar=this._elementRef.nativeElement;inkBar.style.left=positions.left,inkBar.style.width=positions.width}}return MatInkBar.ɵfac=function(t){return new(t||MatInkBar)(core.Qb(core.l),core.Qb(core.B),core.Qb(_MAT_INK_BAR_POSITIONER),core.Qb(animations.a,8))},MatInkBar.ɵdir=core.Lb({type:MatInkBar,selectors:[[\"mat-ink-bar\"]],hostAttrs:[1,\"mat-ink-bar\"],hostVars:2,hostBindings:function(rf,ctx){2&rf&&core.Ib(\"_mat-animation-noopable\",\"NoopAnimations\"===ctx._animationMode)}}),MatInkBar})();const passiveEventListenerOptions=Object(fesm2015_platform.f)({passive:!0});let tabs_MatPaginatedTabHeader=(()=>{class MatPaginatedTabHeader{constructor(_elementRef,_changeDetectorRef,_viewportRuler,_dir,_ngZone,_platform,_animationMode){this._elementRef=_elementRef,this._changeDetectorRef=_changeDetectorRef,this._viewportRuler=_viewportRuler,this._dir=_dir,this._ngZone=_ngZone,this._platform=_platform,this._animationMode=_animationMode,this._scrollDistance=0,this._selectedIndexChanged=!1,this._destroyed=new Subject.a,this._showPaginationControls=!1,this._disableScrollAfter=!0,this._disableScrollBefore=!0,this._stopScrolling=new Subject.a,this.disablePagination=!1,this._selectedIndex=0,this.selectFocusedIndex=new core.o,this.indexFocused=new core.o,_ngZone.runOutsideAngular(()=>{Object(fromEvent.a)(_elementRef.nativeElement,\"mouseleave\").pipe(Object(takeUntil.a)(this._destroyed)).subscribe(()=>{this._stopInterval()})})}get selectedIndex(){return this._selectedIndex}set selectedIndex(value){value=Object(coercion.f)(value),this._selectedIndex!=value&&(this._selectedIndexChanged=!0,this._selectedIndex=value,this._keyManager&&this._keyManager.updateActiveItem(value))}ngAfterViewInit(){Object(fromEvent.a)(this._previousPaginator.nativeElement,\"touchstart\",passiveEventListenerOptions).pipe(Object(takeUntil.a)(this._destroyed)).subscribe(()=>{this._handlePaginatorPress(\"before\")}),Object(fromEvent.a)(this._nextPaginator.nativeElement,\"touchstart\",passiveEventListenerOptions).pipe(Object(takeUntil.a)(this._destroyed)).subscribe(()=>{this._handlePaginatorPress(\"after\")})}ngAfterContentInit(){const dirChange=this._dir?this._dir.change:Object(of.a)(null),resize=this._viewportRuler.change(150),realign=()=>{this.updatePagination(),this._alignInkBarToSelectedTab()};this._keyManager=new a11y.g(this._items).withHorizontalOrientation(this._getLayoutDirection()).withHomeAndEnd().withWrap(),this._keyManager.updateActiveItem(this._selectedIndex),\"undefined\"!=typeof requestAnimationFrame?requestAnimationFrame(realign):realign(),Object(merge.a)(dirChange,resize,this._items.changes).pipe(Object(takeUntil.a)(this._destroyed)).subscribe(()=>{Promise.resolve().then(realign),this._keyManager.withHorizontalOrientation(this._getLayoutDirection())}),this._keyManager.change.pipe(Object(takeUntil.a)(this._destroyed)).subscribe(newFocusIndex=>{this.indexFocused.emit(newFocusIndex),this._setTabFocus(newFocusIndex)})}ngAfterContentChecked(){this._tabLabelCount!=this._items.length&&(this.updatePagination(),this._tabLabelCount=this._items.length,this._changeDetectorRef.markForCheck()),this._selectedIndexChanged&&(this._scrollToLabel(this._selectedIndex),this._checkScrollingControls(),this._alignInkBarToSelectedTab(),this._selectedIndexChanged=!1,this._changeDetectorRef.markForCheck()),this._scrollDistanceChanged&&(this._updateTabScrollPosition(),this._scrollDistanceChanged=!1,this._changeDetectorRef.markForCheck())}ngOnDestroy(){this._destroyed.next(),this._destroyed.complete(),this._stopScrolling.complete()}_handleKeydown(event){if(!Object(keycodes.r)(event))switch(event.keyCode){case keycodes.e:case keycodes.m:this.focusIndex!==this.selectedIndex&&(this.selectFocusedIndex.emit(this.focusIndex),this._itemSelected(event));break;default:this._keyManager.onKeydown(event)}}_onContentChanges(){const textContent=this._elementRef.nativeElement.textContent;textContent!==this._currentTextContent&&(this._currentTextContent=textContent||\"\",this._ngZone.run(()=>{this.updatePagination(),this._alignInkBarToSelectedTab(),this._changeDetectorRef.markForCheck()}))}updatePagination(){this._checkPaginationEnabled(),this._checkScrollingControls(),this._updateTabScrollPosition()}get focusIndex(){return this._keyManager?this._keyManager.activeItemIndex:0}set focusIndex(value){this._isValidIndex(value)&&this.focusIndex!==value&&this._keyManager&&this._keyManager.setActiveItem(value)}_isValidIndex(index){if(!this._items)return!0;const tab=this._items?this._items.toArray()[index]:null;return!!tab&&!tab.disabled}_setTabFocus(tabIndex){if(this._showPaginationControls&&this._scrollToLabel(tabIndex),this._items&&this._items.length){this._items.toArray()[tabIndex].focus();const containerEl=this._tabListContainer.nativeElement,dir=this._getLayoutDirection();containerEl.scrollLeft=\"ltr\"==dir?0:containerEl.scrollWidth-containerEl.offsetWidth}}_getLayoutDirection(){return this._dir&&\"rtl\"===this._dir.value?\"rtl\":\"ltr\"}_updateTabScrollPosition(){if(this.disablePagination)return;const scrollDistance=this.scrollDistance,translateX=\"ltr\"===this._getLayoutDirection()?-scrollDistance:scrollDistance;this._tabList.nativeElement.style.transform=`translateX(${Math.round(translateX)}px)`,(this._platform.TRIDENT||this._platform.EDGE)&&(this._tabListContainer.nativeElement.scrollLeft=0)}get scrollDistance(){return this._scrollDistance}set scrollDistance(value){this._scrollTo(value)}_scrollHeader(direction){return this._scrollTo(this._scrollDistance+(\"before\"==direction?-1:1)*this._tabListContainer.nativeElement.offsetWidth/3)}_handlePaginatorClick(direction){this._stopInterval(),this._scrollHeader(direction)}_scrollToLabel(labelIndex){if(this.disablePagination)return;const selectedLabel=this._items?this._items.toArray()[labelIndex]:null;if(!selectedLabel)return;const viewLength=this._tabListContainer.nativeElement.offsetWidth,{offsetLeft:offsetLeft,offsetWidth:offsetWidth}=selectedLabel.elementRef.nativeElement;let labelBeforePos,labelAfterPos;\"ltr\"==this._getLayoutDirection()?(labelBeforePos=offsetLeft,labelAfterPos=labelBeforePos+offsetWidth):(labelAfterPos=this._tabList.nativeElement.offsetWidth-offsetLeft,labelBeforePos=labelAfterPos-offsetWidth);const beforeVisiblePos=this.scrollDistance,afterVisiblePos=this.scrollDistance+viewLength;labelBeforePos<beforeVisiblePos?this.scrollDistance-=beforeVisiblePos-labelBeforePos+60:labelAfterPos>afterVisiblePos&&(this.scrollDistance+=labelAfterPos-afterVisiblePos+60)}_checkPaginationEnabled(){if(this.disablePagination)this._showPaginationControls=!1;else{const isEnabled=this._tabList.nativeElement.scrollWidth>this._elementRef.nativeElement.offsetWidth;isEnabled||(this.scrollDistance=0),isEnabled!==this._showPaginationControls&&this._changeDetectorRef.markForCheck(),this._showPaginationControls=isEnabled}}_checkScrollingControls(){this.disablePagination?this._disableScrollAfter=this._disableScrollBefore=!0:(this._disableScrollBefore=0==this.scrollDistance,this._disableScrollAfter=this.scrollDistance==this._getMaxScrollDistance(),this._changeDetectorRef.markForCheck())}_getMaxScrollDistance(){return this._tabList.nativeElement.scrollWidth-this._tabListContainer.nativeElement.offsetWidth||0}_alignInkBarToSelectedTab(){const selectedItem=this._items&&this._items.length?this._items.toArray()[this.selectedIndex]:null,selectedLabelWrapper=selectedItem?selectedItem.elementRef.nativeElement:null;selectedLabelWrapper?this._inkBar.alignToElement(selectedLabelWrapper):this._inkBar.hide()}_stopInterval(){this._stopScrolling.next()}_handlePaginatorPress(direction,mouseEvent){mouseEvent&&null!=mouseEvent.button&&0!==mouseEvent.button||(this._stopInterval(),Object(timer.a)(650,100).pipe(Object(takeUntil.a)(Object(merge.a)(this._stopScrolling,this._destroyed))).subscribe(()=>{const{maxScrollDistance:maxScrollDistance,distance:distance}=this._scrollHeader(direction);(0===distance||distance>=maxScrollDistance)&&this._stopInterval()}))}_scrollTo(position){if(this.disablePagination)return{maxScrollDistance:0,distance:0};const maxScrollDistance=this._getMaxScrollDistance();return this._scrollDistance=Math.max(0,Math.min(maxScrollDistance,position)),this._scrollDistanceChanged=!0,this._checkScrollingControls(),{maxScrollDistance:maxScrollDistance,distance:this._scrollDistance}}}return MatPaginatedTabHeader.ɵfac=function(t){return new(t||MatPaginatedTabHeader)(core.Qb(core.l),core.Qb(core.h),core.Qb(scrolling.h),core.Qb(bidi.b,8),core.Qb(core.B),core.Qb(fesm2015_platform.a),core.Qb(animations.a,8))},MatPaginatedTabHeader.ɵdir=core.Lb({type:MatPaginatedTabHeader,inputs:{disablePagination:\"disablePagination\"}}),MatPaginatedTabHeader})(),tabs_MatTabNavBase=(()=>{class _MatTabNavBase extends tabs_MatPaginatedTabHeader{constructor(elementRef,dir,ngZone,changeDetectorRef,viewportRuler,platform,animationMode){super(elementRef,changeDetectorRef,viewportRuler,dir,ngZone,platform,animationMode),this._disableRipple=!1,this.color=\"primary\"}get backgroundColor(){return this._backgroundColor}set backgroundColor(value){const classList=this._elementRef.nativeElement.classList;classList.remove(`mat-background-${this.backgroundColor}`),value&&classList.add(`mat-background-${value}`),this._backgroundColor=value}get disableRipple(){return this._disableRipple}set disableRipple(value){this._disableRipple=Object(coercion.c)(value)}_itemSelected(){}ngAfterContentInit(){this._items.changes.pipe(Object(startWith.a)(null),Object(takeUntil.a)(this._destroyed)).subscribe(()=>{this.updateActiveLink()}),super.ngAfterContentInit()}updateActiveLink(){if(!this._items)return;const items=this._items.toArray();for(let i=0;i<items.length;i++)if(items[i].active)return this.selectedIndex=i,void this._changeDetectorRef.markForCheck();this.selectedIndex=-1,this._inkBar.hide()}}return _MatTabNavBase.ɵfac=function(t){return new(t||_MatTabNavBase)(core.Qb(core.l),core.Qb(bidi.b,8),core.Qb(core.B),core.Qb(core.h),core.Qb(scrolling.h),core.Qb(fesm2015_platform.a),core.Qb(animations.a,8))},_MatTabNavBase.ɵdir=core.Lb({type:_MatTabNavBase,inputs:{color:\"color\",backgroundColor:\"backgroundColor\",disableRipple:\"disableRipple\"},features:[core.Ab]}),_MatTabNavBase})(),tabs_MatTabNav=(()=>{class MatTabNav extends tabs_MatTabNavBase{constructor(elementRef,dir,ngZone,changeDetectorRef,viewportRuler,platform,animationMode){super(elementRef,dir,ngZone,changeDetectorRef,viewportRuler,platform,animationMode)}}return MatTabNav.ɵfac=function(t){return new(t||MatTabNav)(core.Qb(core.l),core.Qb(bidi.b,8),core.Qb(core.B),core.Qb(core.h),core.Qb(scrolling.h),core.Qb(fesm2015_platform.a),core.Qb(animations.a,8))},MatTabNav.ɵcmp=core.Kb({type:MatTabNav,selectors:[[\"\",\"mat-tab-nav-bar\",\"\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&core.Jb(dirIndex,tabs_MatTabLink,1),2&rf){let _t;core.uc(_t=core.fc())&&(ctx._items=_t)}},viewQuery:function(rf,ctx){if(1&rf&&(core.Lc(tabs_MatInkBar,3),core.Lc(_c5,3),core.Lc(_c6,3),core.Lc(_c7,1),core.Lc(_c8,1)),2&rf){let _t;core.uc(_t=core.fc())&&(ctx._inkBar=_t.first),core.uc(_t=core.fc())&&(ctx._tabListContainer=_t.first),core.uc(_t=core.fc())&&(ctx._tabList=_t.first),core.uc(_t=core.fc())&&(ctx._nextPaginator=_t.first),core.uc(_t=core.fc())&&(ctx._previousPaginator=_t.first)}},hostAttrs:[1,\"mat-tab-nav-bar\",\"mat-tab-header\"],hostVars:10,hostBindings:function(rf,ctx){2&rf&&core.Ib(\"mat-tab-header-pagination-controls-enabled\",ctx._showPaginationControls)(\"mat-tab-header-rtl\",\"rtl\"==ctx._getLayoutDirection())(\"mat-primary\",\"warn\"!==ctx.color&&\"accent\"!==ctx.color)(\"mat-accent\",\"accent\"===ctx.color)(\"mat-warn\",\"warn\"===ctx.color)},inputs:{color:\"color\"},exportAs:[\"matTabNavBar\",\"matTabNav\"],features:[core.Ab],attrs:_c9,ngContentSelectors:_c0,decls:13,vars:8,consts:[[\"aria-hidden\",\"true\",\"mat-ripple\",\"\",1,\"mat-tab-header-pagination\",\"mat-tab-header-pagination-before\",\"mat-elevation-z4\",3,\"matRippleDisabled\",\"click\",\"mousedown\",\"touchend\"],[\"previousPaginator\",\"\"],[1,\"mat-tab-header-pagination-chevron\"],[1,\"mat-tab-link-container\",3,\"keydown\"],[\"tabListContainer\",\"\"],[1,\"mat-tab-list\",3,\"cdkObserveContent\"],[\"tabList\",\"\"],[1,\"mat-tab-links\"],[\"aria-hidden\",\"true\",\"mat-ripple\",\"\",1,\"mat-tab-header-pagination\",\"mat-tab-header-pagination-after\",\"mat-elevation-z4\",3,\"matRippleDisabled\",\"mousedown\",\"click\",\"touchend\"],[\"nextPaginator\",\"\"]],template:function(rf,ctx){1&rf&&(core.oc(),core.Wb(0,\"div\",0,1),core.ec(\"click\",function(){return ctx._handlePaginatorClick(\"before\")})(\"mousedown\",function($event){return ctx._handlePaginatorPress(\"before\",$event)})(\"touchend\",function(){return ctx._stopInterval()}),core.Rb(2,\"div\",2),core.Vb(),core.Wb(3,\"div\",3,4),core.ec(\"keydown\",function($event){return ctx._handleKeydown($event)}),core.Wb(5,\"div\",5,6),core.ec(\"cdkObserveContent\",function(){return ctx._onContentChanges()}),core.Wb(7,\"div\",7),core.nc(8),core.Vb(),core.Rb(9,\"mat-ink-bar\"),core.Vb(),core.Vb(),core.Wb(10,\"div\",8,9),core.ec(\"mousedown\",function($event){return ctx._handlePaginatorPress(\"after\",$event)})(\"click\",function(){return ctx._handlePaginatorClick(\"after\")})(\"touchend\",function(){return ctx._stopInterval()}),core.Rb(12,\"div\",2),core.Vb()),2&rf&&(core.Ib(\"mat-tab-header-pagination-disabled\",ctx._disableScrollBefore),core.pc(\"matRippleDisabled\",ctx._disableScrollBefore||ctx.disableRipple),core.Db(5),core.Ib(\"_mat-animation-noopable\",\"NoopAnimations\"===ctx._animationMode),core.Db(5),core.Ib(\"mat-tab-header-pagination-disabled\",ctx._disableScrollAfter),core.pc(\"matRippleDisabled\",ctx._disableScrollAfter||ctx.disableRipple))},directives:[fesm2015_core.q,observers.a,tabs_MatInkBar],styles:['.mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\"\";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-tab-links{display:flex}[mat-align-tabs=center]>.mat-tab-link-container .mat-tab-links{justify-content:center}[mat-align-tabs=end]>.mat-tab-link-container .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:none}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-link:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-link.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-link.mat-tab-disabled{opacity:.5}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-link{opacity:1}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media(max-width: 599px){.mat-tab-link{min-width:72px}}\\n'],encapsulation:2}),MatTabNav})();class MatTabLinkMixinBase{}const _MatTabLinkMixinBase=Object(fesm2015_core.A)(Object(fesm2015_core.w)(Object(fesm2015_core.x)(MatTabLinkMixinBase)));let tabs_MatTabLinkBase=(()=>{class _MatTabLinkBase extends _MatTabLinkMixinBase{constructor(_tabNavBar,elementRef,globalRippleOptions,tabIndex,_focusMonitor,animationMode){super(),this._tabNavBar=_tabNavBar,this.elementRef=elementRef,this._focusMonitor=_focusMonitor,this._isActive=!1,this.rippleConfig=globalRippleOptions||{},this.tabIndex=parseInt(tabIndex)||0,\"NoopAnimations\"===animationMode&&(this.rippleConfig.animation={enterDuration:0,exitDuration:0})}get active(){return this._isActive}set active(value){Object(coercion.c)(value)!==this._isActive&&(this._isActive=value,this._tabNavBar.updateActiveLink())}get rippleDisabled(){return this.disabled||this.disableRipple||this._tabNavBar.disableRipple||!!this.rippleConfig.disabled}focus(){this.elementRef.nativeElement.focus()}ngAfterViewInit(){this._focusMonitor.monitor(this.elementRef)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this.elementRef)}}return _MatTabLinkBase.ɵfac=function(t){return new(t||_MatTabLinkBase)(core.Qb(tabs_MatTabNavBase),core.Qb(core.l),core.Qb(fesm2015_core.i,8),core.bc(\"tabindex\"),core.Qb(a11y.h),core.Qb(animations.a,8))},_MatTabLinkBase.ɵdir=core.Lb({type:_MatTabLinkBase,inputs:{active:\"active\"},features:[core.Ab]}),_MatTabLinkBase})(),tabs_MatTabLink=(()=>{class MatTabLink extends tabs_MatTabLinkBase{constructor(tabNavBar,elementRef,ngZone,platform,globalRippleOptions,tabIndex,focusMonitor,animationMode){super(tabNavBar,elementRef,globalRippleOptions,tabIndex,focusMonitor,animationMode),this._tabLinkRipple=new fesm2015_core.s(this,ngZone,elementRef,platform),this._tabLinkRipple.setupTriggerEvents(elementRef.nativeElement)}ngOnDestroy(){super.ngOnDestroy(),this._tabLinkRipple._removeTriggerEvents()}}return MatTabLink.ɵfac=function(t){return new(t||MatTabLink)(core.Qb(tabs_MatTabNav),core.Qb(core.l),core.Qb(core.B),core.Qb(fesm2015_platform.a),core.Qb(fesm2015_core.i,8),core.bc(\"tabindex\"),core.Qb(a11y.h),core.Qb(animations.a,8))},MatTabLink.ɵdir=core.Lb({type:MatTabLink,selectors:[[\"\",\"mat-tab-link\",\"\"],[\"\",\"matTabLink\",\"\"]],hostAttrs:[1,\"mat-tab-link\",\"mat-focus-indicator\"],hostVars:7,hostBindings:function(rf,ctx){2&rf&&(core.Eb(\"aria-current\",ctx.active?\"page\":null)(\"aria-disabled\",ctx.disabled)(\"tabIndex\",ctx.tabIndex),core.Ib(\"mat-tab-disabled\",ctx.disabled)(\"mat-tab-label-active\",ctx.active))},inputs:{disabled:\"disabled\",disableRipple:\"disableRipple\",tabIndex:\"tabIndex\"},exportAs:[\"matTabLink\"],features:[core.Ab]}),MatTabLink})(),tabs_MatTabsModule=(()=>{class MatTabsModule{}return MatTabsModule.ɵmod=core.Ob({type:MatTabsModule}),MatTabsModule.ɵinj=core.Nb({factory:function(t){return new(t||MatTabsModule)},imports:[[common.c,fesm2015_core.j,portal.f,fesm2015_core.r,observers.c,a11y.a],fesm2015_core.j]}),MatTabsModule})();var src=__webpack_require__(\"g7MM\"),client=__webpack_require__(\"kSUX\"),content_directive=__webpack_require__(\"Qfjl\"),flex=__webpack_require__(\"VDRc\"),router=__webpack_require__(\"iInd\");function AdminComponent_ng_container_0_a_4_Template(rf,ctx){if(1&rf&&(core.Wb(0,\"a\",4,5),core.Ic(2),core.Vb()),2&rf){const item_r3=ctx.$implicit,_r4=core.vc(1);core.pc(\"routerLink\",item_r3.link)(\"active\",_r4.isActive),core.Db(2),core.Jc(item_r3.label)}}function AdminComponent_ng_container_0_Template(rf,ctx){if(1&rf&&(core.Ub(0),core.Wb(1,\"h2\"),core.Ic(2),core.Vb(),core.Wb(3,\"nav\",2),core.Gc(4,AdminComponent_ng_container_0_a_4_Template,3,3,\"a\",3),core.Vb(),core.Tb()),2&rf){const msgs_r1=ctx.$implicit;core.Db(2),core.Jc(msgs_r1.title||\"Admin tools\"),core.Db(2),core.pc(\"ngForOf\",msgs_r1.menu)}}let admin_component_AdminComponent=(()=>{class AdminComponent{}return AdminComponent.ɵfac=function(t){return new(t||AdminComponent)},AdminComponent.ɵcmp=core.Kb({type:AdminComponent,selectors:[[\"wm-admin\"]],decls:3,vars:1,consts:[[4,\"wmContent\",\"wmContentSelect\"],[\"fxFlex\",\"1 1 auto\"],[\"mat-tab-nav-bar\",\"\"],[\"mat-tab-link\",\"\",\"routerLinkActive\",\"\",3,\"routerLink\",\"active\",4,\"ngFor\",\"ngForOf\"],[\"mat-tab-link\",\"\",\"routerLinkActive\",\"\",3,\"routerLink\",\"active\"],[\"rla\",\"routerLinkActive\"]],template:function(rf,ctx){1&rf&&(core.Gc(0,AdminComponent_ng_container_0_Template,5,2,\"ng-container\",0),core.Wb(1,\"div\",1),core.Rb(2,\"router-outlet\"),core.Vb()),2&rf&&core.pc(\"wmContentSelect\",\"admin\")},directives:[content_directive.a,flex.b,router.l,tabs_MatTabNav,common.l,router.j,tabs_MatTabLink,router.i],styles:[\"[_nghost-%COMP%]{width:100%;position:relative;display:flex;flex-direction:column;padding:32px}\"]}),AdminComponent})();var auth_guard=__webpack_require__(\"U9eP\"),admin=__webpack_require__(\"1RzK\");__webpack_require__(\"J3Me\");const routes=[{path:\"\",content:\"admin\",component:admin_component_AdminComponent,canActivate:[auth_guard.a],data:{authGuardPipe:admin.b},children:[{path:\"\",redirectTo:\"access\",pathMatch:\"full\"},{path:\"access\",loadChildren:()=>Promise.all([__webpack_require__.e(1),__webpack_require__.e(2),__webpack_require__.e(17)]).then(__webpack_require__.bind(null,\"Ok+D\")).then(m=>m.UserAccessModule)},{path:\"fixer\",loadChildren:()=>Promise.all([__webpack_require__.e(4),__webpack_require__.e(0),__webpack_require__.e(23)]).then(__webpack_require__.bind(null,\"joOy\")).then(m=>m.ProfileFixerModule)}]}];let admin_module_AdminModule=(()=>{class AdminModule{}return AdminModule.ɵmod=core.Ob({type:AdminModule}),AdminModule.ɵinj=core.Nb({factory:function(t){return new(t||AdminModule)},imports:[[common.c,flex_layout.a,icon.b,fesm2015_button.c,tabs_MatTabsModule,client.a,src.e.forChild(routes)]]}),AdminModule})()},kSUX:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"b\",function(){return client_service_FunctionsClient}),__webpack_require__.d(__webpack_exports__,\"a\",function(){return client_module_ClientModule});var auth=__webpack_require__(\"R6uK\"),take=__webpack_require__(\"IzEk\"),switchMap=__webpack_require__(\"eIep\"),from=__webpack_require__(\"Cfvw\"),of=__webpack_require__(\"LRne\"),core=__webpack_require__(\"8Y7J\");let auth_token_service_AuthToken=(()=>{class AuthToken{constructor(auth){this.auth=auth}intercept(req,next){return this.auth.user$.pipe(Object(take.a)(1),Object(switchMap.a)(user=>user?Object(from.a)(user.getIdToken()):Object(of.a)(null)),Object(switchMap.a)(token=>next.handle(token?req.clone({headers:req.headers.set(\"Authorization\",\"Bearer \"+token)}):req)))}}return AuthToken.ɵfac=function(t){return new(t||AuthToken)(core.ac(auth.c))},AuthToken.ɵprov=core.Mb({token:AuthToken,factory:AuthToken.ɵfac}),AuthToken})();var functions_service=__webpack_require__(\"Iw12\"),http=__webpack_require__(\"IheW\");let client_service_FunctionsClient=(()=>{class FunctionsClient{constructor(functions,http){this.functions=functions,this.http=http}get(endPoint){return this.http.get(this.functions.url+endPoint)}post(endPoint,data){return this.http.post(this.functions.url+endPoint,data)}patch(endPoint,data){return this.http.patch(this.functions.url+endPoint,data)}delete(endPoint){return this.http.delete(this.functions.url+endPoint)}}return FunctionsClient.ɵfac=function(t){return new(t||FunctionsClient)(core.ac(functions_service.a),core.ac(http.b))},FunctionsClient.ɵprov=core.Mb({token:FunctionsClient,factory:FunctionsClient.ɵfac}),FunctionsClient})();var functions_module=__webpack_require__(\"RZm4\"),auth_module=__webpack_require__(\"Yfbv\");let client_module_ClientModule=(()=>{class ClientModule{}return ClientModule.ɵmod=core.Ob({type:ClientModule}),ClientModule.ɵinj=core.Nb({factory:function(t){return new(t||ClientModule)},providers:[{provide:http.a,useClass:auth_token_service_AuthToken,multi:!0},client_service_FunctionsClient],imports:[[auth_module.a,functions_module.a,http.c]]}),ClientModule})()}}]);","name":"18-es2015.50ab4673c108fae9e950.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[18],{\n\n/***/ \"6GwG\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"AdminModule\", function() { return /* binding */ admin_module_AdminModule; });\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/fesm2015/common.js\nvar common = __webpack_require__(\"SVse\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/flex-layout/esm2015/flex-layout.js + 1 modules\nvar flex_layout = __webpack_require__(\"u9T3\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/material/fesm2015/icon.js\nvar icon = __webpack_require__(\"Tj54\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/material/fesm2015/button.js\nvar fesm2015_button = __webpack_require__(\"Dxy4\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/fesm2015/a11y.js\nvar a11y = __webpack_require__(\"YEUz\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/fesm2015/observers.js\nvar observers = __webpack_require__(\"9b/N\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/fesm2015/portal.js\nvar portal = __webpack_require__(\"1z/I\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/fesm2015/core.js\nvar core = __webpack_require__(\"8Y7J\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/material/fesm2015/core.js + 1 modules\nvar fesm2015_core = __webpack_require__(\"UhP/\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/fesm2015/animations.js + 1 modules\nvar animations = __webpack_require__(\"omvX\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js\nvar Subject = __webpack_require__(\"XNiG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules\nvar Subscription = __webpack_require__(\"quSY\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js\nvar merge = __webpack_require__(\"VRyK\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js\nvar fromEvent = __webpack_require__(\"xgIS\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js\nvar of = __webpack_require__(\"LRne\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/timer.js\nvar timer = __webpack_require__(\"PqYM\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/animations/fesm2015/animations.js\nvar fesm2015_animations = __webpack_require__(\"GS7A\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js\nvar startWith = __webpack_require__(\"JX91\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js\nvar distinctUntilChanged = __webpack_require__(\"/uUt\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js\nvar takeUntil = __webpack_require__(\"1G5W\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/fesm2015/coercion.js\nvar coercion = __webpack_require__(\"8LU1\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/fesm2015/platform.js\nvar fesm2015_platform = __webpack_require__(\"SCoL\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/fesm2015/keycodes.js\nvar keycodes = __webpack_require__(\"Ht+U\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/fesm2015/bidi.js\nvar bidi = __webpack_require__(\"9gLZ\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/fesm2015/scrolling.js + 1 modules\nvar scrolling = __webpack_require__(\"7KAL\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/material/fesm2015/tabs.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token for the MatInkBar's Positioner. */\n\n\n\n\n\n\n\n\n\nfunction MatTab_ng_template_0_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"nc\" /* ɵɵprojection */](0);\n    }\n}\nconst _c0 = [\"*\"];\nfunction MatTabBody_ng_template_2_Template(rf, ctx) { }\nconst _c1 = function (a0) { return { animationDuration: a0 }; };\nconst _c2 = function (a0, a1) { return { value: a0, params: a1 }; };\nconst _c3 = [\"tabBodyWrapper\"];\nconst _c4 = [\"tabHeader\"];\nfunction MatTabGroup_div_2_ng_template_2_ng_template_0_Template(rf, ctx) { }\nfunction MatTabGroup_div_2_ng_template_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Gc\" /* ɵɵtemplate */](0, MatTabGroup_div_2_ng_template_2_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n    }\n    if (rf & 2) {\n        const tab_r4 = core[\"ic\" /* ɵɵnextContext */]().$implicit;\n        core[\"pc\" /* ɵɵproperty */](\"cdkPortalOutlet\", tab_r4.templateLabel);\n    }\n}\nfunction MatTabGroup_div_2_ng_template_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Ic\" /* ɵɵtext */](0);\n    }\n    if (rf & 2) {\n        const tab_r4 = core[\"ic\" /* ɵɵnextContext */]().$implicit;\n        core[\"Jc\" /* ɵɵtextInterpolate */](tab_r4.textLabel);\n    }\n}\nfunction MatTabGroup_div_2_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r12 = core[\"Xb\" /* ɵɵgetCurrentView */]();\n        core[\"Wb\" /* ɵɵelementStart */](0, \"div\", 6);\n        core[\"ec\" /* ɵɵlistener */](\"click\", function MatTabGroup_div_2_Template_div_click_0_listener() { core[\"yc\" /* ɵɵrestoreView */](_r12); const tab_r4 = ctx.$implicit; const i_r5 = ctx.index; const ctx_r11 = core[\"ic\" /* ɵɵnextContext */](); const _r0 = core[\"vc\" /* ɵɵreference */](1); return ctx_r11._handleClick(tab_r4, _r0, i_r5); });\n        core[\"Wb\" /* ɵɵelementStart */](1, \"div\", 7);\n        core[\"Gc\" /* ɵɵtemplate */](2, MatTabGroup_div_2_ng_template_2_Template, 1, 1, \"ng-template\", 8);\n        core[\"Gc\" /* ɵɵtemplate */](3, MatTabGroup_div_2_ng_template_3_Template, 1, 1, \"ng-template\", 8);\n        core[\"Vb\" /* ɵɵelementEnd */]();\n        core[\"Vb\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const tab_r4 = ctx.$implicit;\n        const i_r5 = ctx.index;\n        const ctx_r1 = core[\"ic\" /* ɵɵnextContext */]();\n        core[\"Ib\" /* ɵɵclassProp */](\"mat-tab-label-active\", ctx_r1.selectedIndex == i_r5);\n        core[\"pc\" /* ɵɵproperty */](\"id\", ctx_r1._getTabLabelId(i_r5))(\"disabled\", tab_r4.disabled)(\"matRippleDisabled\", tab_r4.disabled || ctx_r1.disableRipple);\n        core[\"Eb\" /* ɵɵattribute */](\"tabIndex\", ctx_r1._getTabIndex(tab_r4, i_r5))(\"aria-posinset\", i_r5 + 1)(\"aria-setsize\", ctx_r1._tabs.length)(\"aria-controls\", ctx_r1._getTabContentId(i_r5))(\"aria-selected\", ctx_r1.selectedIndex == i_r5)(\"aria-label\", tab_r4.ariaLabel || null)(\"aria-labelledby\", !tab_r4.ariaLabel && tab_r4.ariaLabelledby ? tab_r4.ariaLabelledby : null);\n        core[\"Db\" /* ɵɵadvance */](2);\n        core[\"pc\" /* ɵɵproperty */](\"ngIf\", tab_r4.templateLabel);\n        core[\"Db\" /* ɵɵadvance */](1);\n        core[\"pc\" /* ɵɵproperty */](\"ngIf\", !tab_r4.templateLabel);\n    }\n}\nfunction MatTabGroup_mat_tab_body_5_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r16 = core[\"Xb\" /* ɵɵgetCurrentView */]();\n        core[\"Wb\" /* ɵɵelementStart */](0, \"mat-tab-body\", 10);\n        core[\"ec\" /* ɵɵlistener */](\"_onCentered\", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentered_0_listener() { core[\"yc\" /* ɵɵrestoreView */](_r16); const ctx_r15 = core[\"ic\" /* ɵɵnextContext */](); return ctx_r15._removeTabBodyWrapperHeight(); })(\"_onCentering\", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentering_0_listener($event) { core[\"yc\" /* ɵɵrestoreView */](_r16); const ctx_r17 = core[\"ic\" /* ɵɵnextContext */](); return ctx_r17._setTabBodyWrapperHeight($event); });\n        core[\"Vb\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const tab_r13 = ctx.$implicit;\n        const i_r14 = ctx.index;\n        const ctx_r3 = core[\"ic\" /* ɵɵnextContext */]();\n        core[\"Ib\" /* ɵɵclassProp */](\"mat-tab-body-active\", ctx_r3.selectedIndex == i_r14);\n        core[\"pc\" /* ɵɵproperty */](\"id\", ctx_r3._getTabContentId(i_r14))(\"content\", tab_r13.content)(\"position\", tab_r13.position)(\"origin\", tab_r13.origin)(\"animationDuration\", ctx_r3.animationDuration);\n        core[\"Eb\" /* ɵɵattribute */](\"aria-labelledby\", ctx_r3._getTabLabelId(i_r14));\n    }\n}\nconst _c5 = [\"tabListContainer\"];\nconst _c6 = [\"tabList\"];\nconst _c7 = [\"nextPaginator\"];\nconst _c8 = [\"previousPaginator\"];\nconst _c9 = [\"mat-tab-nav-bar\", \"\"];\nconst _MAT_INK_BAR_POSITIONER = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('MatInkBarPositioner', {\n    providedIn: 'root',\n    factory: _MAT_INK_BAR_POSITIONER_FACTORY\n});\n/**\n * The default positioner function for the MatInkBar.\n * @docs-private\n */\nfunction _MAT_INK_BAR_POSITIONER_FACTORY() {\n    const method = (element) => ({\n        left: element ? (element.offsetLeft || 0) + 'px' : '0',\n        width: element ? (element.offsetWidth || 0) + 'px' : '0',\n    });\n    return method;\n}\nlet tabs_MatInkBar = /*@__PURE__*/ (() => {\n    class MatInkBar {\n        constructor(_elementRef, _ngZone, _inkBarPositioner, _animationMode) {\n            this._elementRef = _elementRef;\n            this._ngZone = _ngZone;\n            this._inkBarPositioner = _inkBarPositioner;\n            this._animationMode = _animationMode;\n        }\n        /**\n         * Calculates the styles from the provided element in order to align the ink-bar to that element.\n         * Shows the ink bar if previously set as hidden.\n         * @param element\n         */\n        alignToElement(element) {\n            this.show();\n            if (typeof requestAnimationFrame !== 'undefined') {\n                this._ngZone.runOutsideAngular(() => {\n                    requestAnimationFrame(() => this._setStyles(element));\n                });\n            }\n            else {\n                this._setStyles(element);\n            }\n        }\n        /** Shows the ink bar. */\n        show() {\n            this._elementRef.nativeElement.style.visibility = 'visible';\n        }\n        /** Hides the ink bar. */\n        hide() {\n            this._elementRef.nativeElement.style.visibility = 'hidden';\n        }\n        /**\n         * Sets the proper styles to the ink bar element.\n         * @param element\n         */\n        _setStyles(element) {\n            const positions = this._inkBarPositioner(element);\n            const inkBar = this._elementRef.nativeElement;\n            inkBar.style.left = positions.left;\n            inkBar.style.width = positions.width;\n        }\n    }\n    MatInkBar.ɵfac = function MatInkBar_Factory(t) { return new (t || MatInkBar)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Qb\" /* ɵɵdirectiveInject */](_MAT_INK_BAR_POSITIONER), core[\"Qb\" /* ɵɵdirectiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatInkBar.ɵdir = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineDirective */]({ type: MatInkBar, selectors: [[\"mat-ink-bar\"]], hostAttrs: [1, \"mat-ink-bar\"], hostVars: 2, hostBindings: function MatInkBar_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Ib\" /* ɵɵclassProp */](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n            }\n        } });\n    return MatInkBar;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `MatTabContent`. It serves as\n * alternative token to the actual `MatTabContent` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_TAB_CONTENT = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('MatTabContent');\nlet tabs_MatTabContent = /*@__PURE__*/ (() => {\n    class MatTabContent {\n        constructor(\n        /** Content for the tab. */ template) {\n            this.template = template;\n        }\n    }\n    MatTabContent.ɵfac = function MatTabContent_Factory(t) { return new (t || MatTabContent)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */])); };\n    MatTabContent.ɵdir = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineDirective */]({ type: MatTabContent, selectors: [[\"\", \"matTabContent\", \"\"]], features: [/*@__PURE__*/ core[\"Cb\" /* ɵɵProvidersFeature */]([{ provide: MAT_TAB_CONTENT, useExisting: MatTabContent }])] });\n    return MatTabContent;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `MatTabLabel`. It serves as\n * alternative token to the actual `MatTabLabel` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_TAB_LABEL = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('MatTabLabel');\nlet tabs_MatTabLabel = /*@__PURE__*/ (() => {\n    class MatTabLabel extends portal[\"b\" /* CdkPortal */] {\n    }\n    MatTabLabel.ɵfac = function MatTabLabel_Factory(t) { return ɵMatTabLabel_BaseFactory(t || MatTabLabel); };\n    MatTabLabel.ɵdir = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineDirective */]({ type: MatTabLabel, selectors: [[\"\", \"mat-tab-label\", \"\"], [\"\", \"matTabLabel\", \"\"]], features: [/*@__PURE__*/ core[\"Cb\" /* ɵɵProvidersFeature */]([{ provide: MAT_TAB_LABEL, useExisting: MatTabLabel }]), core[\"Ab\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatTabLabel;\n})();\nconst ɵMatTabLabel_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Yb\" /* ɵɵgetInheritedFactory */](tabs_MatTabLabel);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Boilerplate for applying mixins to MatTab.\n/** @docs-private */\nclass MatTabBase {\n}\nconst _MatTabMixinBase = /*@__PURE__*/ Object(fesm2015_core[\"x\" /* mixinDisabled */])(MatTabBase);\n/**\n * Used to provide a tab group to a tab without causing a circular dependency.\n * @docs-private\n */\nconst MAT_TAB_GROUP = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('MAT_TAB_GROUP');\nlet tabs_MatTab = /*@__PURE__*/ (() => {\n    class MatTab extends _MatTabMixinBase {\n        constructor(_viewContainerRef, _closestTabGroup) {\n            super();\n            this._viewContainerRef = _viewContainerRef;\n            this._closestTabGroup = _closestTabGroup;\n            /** Plain text label for the tab, used when there is no template label. */\n            this.textLabel = '';\n            /** Portal that will be the hosted content of the tab */\n            this._contentPortal = null;\n            /** Emits whenever the internal state of the tab changes. */\n            this._stateChanges = new Subject[\"a\" /* Subject */]();\n            /**\n             * The relatively indexed position where 0 represents the center, negative is left, and positive\n             * represents the right.\n             */\n            this.position = null;\n            /**\n             * The initial relatively index origin of the tab if it was created and selected after there\n             * was already a selected tab. Provides context of what position the tab should originate from.\n             */\n            this.origin = null;\n            /**\n             * Whether the tab is currently active.\n             */\n            this.isActive = false;\n        }\n        /** Content for the tab label given by `<ng-template mat-tab-label>`. */\n        get templateLabel() { return this._templateLabel; }\n        set templateLabel(value) { this._setTemplateLabelInput(value); }\n        /** @docs-private */\n        get content() {\n            return this._contentPortal;\n        }\n        ngOnChanges(changes) {\n            if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {\n                this._stateChanges.next();\n            }\n        }\n        ngOnDestroy() {\n            this._stateChanges.complete();\n        }\n        ngOnInit() {\n            this._contentPortal = new portal[\"g\" /* TemplatePortal */](this._explicitContent || this._implicitContent, this._viewContainerRef);\n        }\n        /**\n         * This has been extracted to a util because of TS 4 and VE.\n         * View Engine doesn't support property rename inheritance.\n         * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n         * @docs-private\n         */\n        _setTemplateLabelInput(value) {\n            // Only update the templateLabel via query if there is actually\n            // a MatTabLabel found. This works around an issue where a user may have\n            // manually set `templateLabel` during creation mode, which would then get clobbered\n            // by `undefined` when this query resolves.\n            if (value) {\n                this._templateLabel = value;\n            }\n        }\n    }\n    MatTab.ɵfac = function MatTab_Factory(t) { return new (t || MatTab)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"S\" /* ViewContainerRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](MAT_TAB_GROUP)); };\n    MatTab.ɵcmp = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineComponent */]({ type: MatTab, selectors: [[\"mat-tab\"]], contentQueries: function MatTab_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Jb\" /* ɵɵcontentQuery */](dirIndex, MAT_TAB_LABEL, 1);\n                core[\"Jb\" /* ɵɵcontentQuery */](dirIndex, MAT_TAB_CONTENT, 3, core[\"O\" /* TemplateRef */]);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx.templateLabel = _t.first);\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._explicitContent = _t.first);\n            }\n        }, viewQuery: function MatTab_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Lc\" /* ɵɵviewQuery */](core[\"O\" /* TemplateRef */], 3);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._implicitContent = _t.first);\n            }\n        }, inputs: { disabled: \"disabled\", textLabel: [\"label\", \"textLabel\"], ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"] }, exportAs: [\"matTab\"], features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */], core[\"Bb\" /* ɵɵNgOnChangesFeature */]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function MatTab_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */]();\n                core[\"Gc\" /* ɵɵtemplate */](0, MatTab_ng_template_0_Template, 1, 0, \"ng-template\");\n            }\n        }, encapsulation: 2 });\n    return MatTab;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Animations used by the Material tabs.\n * @docs-private\n */\nconst matTabsAnimations = {\n    /** Animation translates a tab along the X axis. */\n    translateTab: /*@__PURE__*/ Object(fesm2015_animations[\"o\" /* trigger */])('translateTab', [\n        // Note: transitions to `none` instead of 0, because some browsers might blur the content.\n        /*@__PURE__*/ Object(fesm2015_animations[\"l\" /* state */])('center, void, left-origin-center, right-origin-center', /*@__PURE__*/ Object(fesm2015_animations[\"m\" /* style */])({ transform: 'none' })),\n        // If the tab is either on the left or right, we additionally add a `min-height` of 1px\n        // in order to ensure that the element has a height before its state changes. This is\n        // necessary because Chrome does seem to skip the transition in RTL mode if the element does\n        // not have a static height and is not rendered. See related issue: #9465\n        /*@__PURE__*/ Object(fesm2015_animations[\"l\" /* state */])('left', /*@__PURE__*/ Object(fesm2015_animations[\"m\" /* style */])({ transform: 'translate3d(-100%, 0, 0)', minHeight: '1px' })),\n        /*@__PURE__*/ Object(fesm2015_animations[\"l\" /* state */])('right', /*@__PURE__*/ Object(fesm2015_animations[\"m\" /* style */])({ transform: 'translate3d(100%, 0, 0)', minHeight: '1px' })),\n        /*@__PURE__*/ Object(fesm2015_animations[\"n\" /* transition */])('* => left, * => right, left => center, right => center', /*@__PURE__*/ Object(fesm2015_animations[\"e\" /* animate */])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')),\n        /*@__PURE__*/ Object(fesm2015_animations[\"n\" /* transition */])('void => left-origin-center', [\n            /*@__PURE__*/ Object(fesm2015_animations[\"m\" /* style */])({ transform: 'translate3d(-100%, 0, 0)' }),\n            /*@__PURE__*/ Object(fesm2015_animations[\"e\" /* animate */])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')\n        ]),\n        /*@__PURE__*/ Object(fesm2015_animations[\"n\" /* transition */])('void => right-origin-center', [\n            /*@__PURE__*/ Object(fesm2015_animations[\"m\" /* style */])({ transform: 'translate3d(100%, 0, 0)' }),\n            /*@__PURE__*/ Object(fesm2015_animations[\"e\" /* animate */])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')\n        ])\n    ])\n};\nlet tabs_MatTabBodyPortal = /*@__PURE__*/ (() => {\n    class MatTabBodyPortal extends portal[\"c\" /* CdkPortalOutlet */] {\n        constructor(componentFactoryResolver, viewContainerRef, _host, _document) {\n            super(componentFactoryResolver, viewContainerRef, _document);\n            this._host = _host;\n            /** Subscription to events for when the tab body begins centering. */\n            this._centeringSub = Subscription[\"a\" /* Subscription */].EMPTY;\n            /** Subscription to events for when the tab body finishes leaving from center position. */\n            this._leavingSub = Subscription[\"a\" /* Subscription */].EMPTY;\n        }\n        /** Set initial visibility or set up subscription for changing visibility. */\n        ngOnInit() {\n            super.ngOnInit();\n            this._centeringSub = this._host._beforeCentering\n                .pipe(Object(startWith[\"a\" /* startWith */])(this._host._isCenterPosition(this._host._position)))\n                .subscribe((isCentering) => {\n                if (isCentering && !this.hasAttached()) {\n                    this.attach(this._host._content);\n                }\n            });\n            this._leavingSub = this._host._afterLeavingCenter.subscribe(() => {\n                this.detach();\n            });\n        }\n        /** Clean up centering subscription. */\n        ngOnDestroy() {\n            super.ngOnDestroy();\n            this._centeringSub.unsubscribe();\n            this._leavingSub.unsubscribe();\n        }\n    }\n    MatTabBodyPortal.ɵfac = function MatTabBodyPortal_Factory(t) { return new (t || MatTabBodyPortal)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"j\" /* ComponentFactoryResolver */]), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"S\" /* ViewContainerRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](Object(core[\"W\" /* forwardRef */])(() => tabs_MatTabBody)), core[\"Qb\" /* ɵɵdirectiveInject */](common[\"d\" /* DOCUMENT */])); };\n    MatTabBodyPortal.ɵdir = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineDirective */]({ type: MatTabBodyPortal, selectors: [[\"\", \"matTabBodyHost\", \"\"]], features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatTabBodyPortal;\n})();\nlet tabs_MatTabBodyBase = /*@__PURE__*/ (() => {\n    class _MatTabBodyBase {\n        constructor(_elementRef, _dir, changeDetectorRef) {\n            this._elementRef = _elementRef;\n            this._dir = _dir;\n            /** Subscription to the directionality change observable. */\n            this._dirChangeSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n            /** Emits when an animation on the tab is complete. */\n            this._translateTabComplete = new Subject[\"a\" /* Subject */]();\n            /** Event emitted when the tab begins to animate towards the center as the active tab. */\n            this._onCentering = new core[\"o\" /* EventEmitter */]();\n            /** Event emitted before the centering of the tab begins. */\n            this._beforeCentering = new core[\"o\" /* EventEmitter */]();\n            /** Event emitted before the centering of the tab begins. */\n            this._afterLeavingCenter = new core[\"o\" /* EventEmitter */]();\n            /** Event emitted when the tab completes its animation towards the center. */\n            this._onCentered = new core[\"o\" /* EventEmitter */](true);\n            // Note that the default value will always be overwritten by `MatTabBody`, but we need one\n            // anyway to prevent the animations module from throwing an error if the body is used on its own.\n            /** Duration for the tab's animation. */\n            this.animationDuration = '500ms';\n            if (_dir) {\n                this._dirChangeSubscription = _dir.change.subscribe((dir) => {\n                    this._computePositionAnimationState(dir);\n                    changeDetectorRef.markForCheck();\n                });\n            }\n            // Ensure that we get unique animation events, because the `.done` callback can get\n            // invoked twice in some browsers. See https://github.com/angular/angular/issues/24084.\n            this._translateTabComplete.pipe(Object(distinctUntilChanged[\"a\" /* distinctUntilChanged */])((x, y) => {\n                return x.fromState === y.fromState && x.toState === y.toState;\n            })).subscribe(event => {\n                // If the transition to the center is complete, emit an event.\n                if (this._isCenterPosition(event.toState) && this._isCenterPosition(this._position)) {\n                    this._onCentered.emit();\n                }\n                if (this._isCenterPosition(event.fromState) && !this._isCenterPosition(this._position)) {\n                    this._afterLeavingCenter.emit();\n                }\n            });\n        }\n        /** The shifted index position of the tab body, where zero represents the active center tab. */\n        set position(position) {\n            this._positionIndex = position;\n            this._computePositionAnimationState();\n        }\n        /**\n         * After initialized, check if the content is centered and has an origin. If so, set the\n         * special position states that transition the tab from the left or right before centering.\n         */\n        ngOnInit() {\n            if (this._position == 'center' && this.origin != null) {\n                this._position = this._computePositionFromOrigin(this.origin);\n            }\n        }\n        ngOnDestroy() {\n            this._dirChangeSubscription.unsubscribe();\n            this._translateTabComplete.complete();\n        }\n        _onTranslateTabStarted(event) {\n            const isCentering = this._isCenterPosition(event.toState);\n            this._beforeCentering.emit(isCentering);\n            if (isCentering) {\n                this._onCentering.emit(this._elementRef.nativeElement.clientHeight);\n            }\n        }\n        /** The text direction of the containing app. */\n        _getLayoutDirection() {\n            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n        }\n        /** Whether the provided position state is considered center, regardless of origin. */\n        _isCenterPosition(position) {\n            return position == 'center' ||\n                position == 'left-origin-center' ||\n                position == 'right-origin-center';\n        }\n        /** Computes the position state that will be used for the tab-body animation trigger. */\n        _computePositionAnimationState(dir = this._getLayoutDirection()) {\n            if (this._positionIndex < 0) {\n                this._position = dir == 'ltr' ? 'left' : 'right';\n            }\n            else if (this._positionIndex > 0) {\n                this._position = dir == 'ltr' ? 'right' : 'left';\n            }\n            else {\n                this._position = 'center';\n            }\n        }\n        /**\n         * Computes the position state based on the specified origin position. This is used if the\n         * tab is becoming visible immediately after creation.\n         */\n        _computePositionFromOrigin(origin) {\n            const dir = this._getLayoutDirection();\n            if ((dir == 'ltr' && origin <= 0) || (dir == 'rtl' && origin > 0)) {\n                return 'left-origin-center';\n            }\n            return 'right-origin-center';\n        }\n    }\n    _MatTabBodyBase.ɵfac = function _MatTabBodyBase_Factory(t) { return new (t || _MatTabBodyBase)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](bidi[\"b\" /* Directionality */], 8), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */])); };\n    _MatTabBodyBase.ɵdir = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineDirective */]({ type: _MatTabBodyBase, inputs: { animationDuration: \"animationDuration\", position: \"position\", _content: [\"content\", \"_content\"], origin: \"origin\" }, outputs: { _onCentering: \"_onCentering\", _beforeCentering: \"_beforeCentering\", _afterLeavingCenter: \"_afterLeavingCenter\", _onCentered: \"_onCentered\" } });\n    return _MatTabBodyBase;\n})();\nlet tabs_MatTabBody = /*@__PURE__*/ (() => {\n    class MatTabBody extends tabs_MatTabBodyBase {\n        constructor(elementRef, dir, changeDetectorRef) {\n            super(elementRef, dir, changeDetectorRef);\n        }\n    }\n    MatTabBody.ɵfac = function MatTabBody_Factory(t) { return new (t || MatTabBody)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](bidi[\"b\" /* Directionality */], 8), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */])); };\n    MatTabBody.ɵcmp = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineComponent */]({ type: MatTabBody, selectors: [[\"mat-tab-body\"]], viewQuery: function MatTabBody_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Lc\" /* ɵɵviewQuery */](portal[\"c\" /* CdkPortalOutlet */], 1);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._portalHost = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-tab-body\"], features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]], decls: 3, vars: 6, consts: [[1, \"mat-tab-body-content\"], [\"content\", \"\"], [\"matTabBodyHost\", \"\"]], template: function MatTabBody_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Wb\" /* ɵɵelementStart */](0, \"div\", 0, 1);\n                core[\"ec\" /* ɵɵlistener */](\"@translateTab.start\", function MatTabBody_Template_div_animation_translateTab_start_0_listener($event) { return ctx._onTranslateTabStarted($event); })(\"@translateTab.done\", function MatTabBody_Template_div_animation_translateTab_done_0_listener($event) { return ctx._translateTabComplete.next($event); });\n                core[\"Gc\" /* ɵɵtemplate */](2, MatTabBody_ng_template_2_Template, 0, 0, \"ng-template\", 2);\n                core[\"Vb\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"pc\" /* ɵɵproperty */](\"@translateTab\", core[\"tc\" /* ɵɵpureFunction2 */](3, _c2, ctx._position, core[\"sc\" /* ɵɵpureFunction1 */](1, _c1, ctx.animationDuration)));\n            }\n        }, directives: [tabs_MatTabBodyPortal], styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\\n\"], encapsulation: 2, data: { animation: [matTabsAnimations.translateTab] } });\n    return MatTabBody;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token that can be used to provide the default options the tabs module. */\nconst MAT_TABS_CONFIG = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('MAT_TABS_CONFIG');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Used to generate unique ID's for each tab component */\nlet nextId = 0;\n/** A simple change event emitted on focus or selection changes. */\nclass MatTabChangeEvent {\n}\n// Boilerplate for applying mixins to MatTabGroup.\n/** @docs-private */\nclass MatTabGroupMixinBase {\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\nconst _MatTabGroupMixinBase = /*@__PURE__*/ Object(fesm2015_core[\"v\" /* mixinColor */])(/*@__PURE__*/ Object(fesm2015_core[\"w\" /* mixinDisableRipple */])(MatTabGroupMixinBase), 'primary');\nlet tabs_MatTabGroupBase = /*@__PURE__*/ (() => {\n    class _MatTabGroupBase extends _MatTabGroupMixinBase {\n        constructor(elementRef, _changeDetectorRef, defaultConfig, _animationMode) {\n            super(elementRef);\n            this._changeDetectorRef = _changeDetectorRef;\n            this._animationMode = _animationMode;\n            /** All of the tabs that belong to the group. */\n            this._tabs = new core[\"F\" /* QueryList */]();\n            /** The tab index that should be selected after the content has been checked. */\n            this._indexToSelect = 0;\n            /** Snapshot of the height of the tab body wrapper before another tab is activated. */\n            this._tabBodyWrapperHeight = 0;\n            /** Subscription to tabs being added/removed. */\n            this._tabsSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n            /** Subscription to changes in the tab labels. */\n            this._tabLabelSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n            this._selectedIndex = null;\n            /** Position of the tab header. */\n            this.headerPosition = 'above';\n            /** Output to enable support for two-way binding on `[(selectedIndex)]` */\n            this.selectedIndexChange = new core[\"o\" /* EventEmitter */]();\n            /** Event emitted when focus has changed within a tab group. */\n            this.focusChange = new core[\"o\" /* EventEmitter */]();\n            /** Event emitted when the body animation has completed */\n            this.animationDone = new core[\"o\" /* EventEmitter */]();\n            /** Event emitted when the tab selection has changed. */\n            this.selectedTabChange = new core[\"o\" /* EventEmitter */](true);\n            this._groupId = nextId++;\n            this.animationDuration = defaultConfig && defaultConfig.animationDuration ?\n                defaultConfig.animationDuration : '500ms';\n            this.disablePagination = defaultConfig && defaultConfig.disablePagination != null ?\n                defaultConfig.disablePagination : false;\n            this.dynamicHeight = defaultConfig && defaultConfig.dynamicHeight != null ?\n                defaultConfig.dynamicHeight : false;\n        }\n        /** Whether the tab group should grow to the size of the active tab. */\n        get dynamicHeight() { return this._dynamicHeight; }\n        set dynamicHeight(value) { this._dynamicHeight = Object(coercion[\"c\" /* coerceBooleanProperty */])(value); }\n        /** The index of the active tab. */\n        get selectedIndex() { return this._selectedIndex; }\n        set selectedIndex(value) {\n            this._indexToSelect = Object(coercion[\"f\" /* coerceNumberProperty */])(value, null);\n        }\n        /** Duration for the tab animation. Will be normalized to milliseconds if no units are set. */\n        get animationDuration() { return this._animationDuration; }\n        set animationDuration(value) {\n            this._animationDuration = /^\\d+$/.test(value) ? value + 'ms' : value;\n        }\n        /** Background color of the tab group. */\n        get backgroundColor() { return this._backgroundColor; }\n        set backgroundColor(value) {\n            const nativeElement = this._elementRef.nativeElement;\n            nativeElement.classList.remove(`mat-background-${this.backgroundColor}`);\n            if (value) {\n                nativeElement.classList.add(`mat-background-${value}`);\n            }\n            this._backgroundColor = value;\n        }\n        /**\n         * After the content is checked, this component knows what tabs have been defined\n         * and what the selected index should be. This is where we can know exactly what position\n         * each tab should be in according to the new selected index, and additionally we know how\n         * a new selected tab should transition in (from the left or right).\n         */\n        ngAfterContentChecked() {\n            // Don't clamp the `indexToSelect` immediately in the setter because it can happen that\n            // the amount of tabs changes before the actual change detection runs.\n            const indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);\n            // If there is a change in selected index, emit a change event. Should not trigger if\n            // the selected index has not yet been initialized.\n            if (this._selectedIndex != indexToSelect) {\n                const isFirstRun = this._selectedIndex == null;\n                if (!isFirstRun) {\n                    this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\n                }\n                // Changing these values after change detection has run\n                // since the checked content may contain references to them.\n                Promise.resolve().then(() => {\n                    this._tabs.forEach((tab, index) => tab.isActive = index === indexToSelect);\n                    if (!isFirstRun) {\n                        this.selectedIndexChange.emit(indexToSelect);\n                    }\n                });\n            }\n            // Setup the position for each tab and optionally setup an origin on the next selected tab.\n            this._tabs.forEach((tab, index) => {\n                tab.position = index - indexToSelect;\n                // If there is already a selected tab, then set up an origin for the next selected tab\n                // if it doesn't have one already.\n                if (this._selectedIndex != null && tab.position == 0 && !tab.origin) {\n                    tab.origin = indexToSelect - this._selectedIndex;\n                }\n            });\n            if (this._selectedIndex !== indexToSelect) {\n                this._selectedIndex = indexToSelect;\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        ngAfterContentInit() {\n            this._subscribeToAllTabChanges();\n            this._subscribeToTabLabels();\n            // Subscribe to changes in the amount of tabs, in order to be\n            // able to re-render the content as new tabs are added or removed.\n            this._tabsSubscription = this._tabs.changes.subscribe(() => {\n                const indexToSelect = this._clampTabIndex(this._indexToSelect);\n                // Maintain the previously-selected tab if a new tab is added or removed and there is no\n                // explicit change that selects a different tab.\n                if (indexToSelect === this._selectedIndex) {\n                    const tabs = this._tabs.toArray();\n                    for (let i = 0; i < tabs.length; i++) {\n                        if (tabs[i].isActive) {\n                            // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed\n                            // event, otherwise the consumer may end up in an infinite loop in some edge cases like\n                            // adding a tab within the `selectedIndexChange` event.\n                            this._indexToSelect = this._selectedIndex = i;\n                            break;\n                        }\n                    }\n                }\n                this._changeDetectorRef.markForCheck();\n            });\n        }\n        /** Listens to changes in all of the tabs. */\n        _subscribeToAllTabChanges() {\n            // Since we use a query with `descendants: true` to pick up the tabs, we may end up catching\n            // some that are inside of nested tab groups. We filter them out manually by checking that\n            // the closest group to the tab is the current one.\n            this._allTabs.changes\n                .pipe(Object(startWith[\"a\" /* startWith */])(this._allTabs))\n                .subscribe((tabs) => {\n                this._tabs.reset(tabs.filter(tab => tab._closestTabGroup === this));\n                this._tabs.notifyOnChanges();\n            });\n        }\n        ngOnDestroy() {\n            this._tabs.destroy();\n            this._tabsSubscription.unsubscribe();\n            this._tabLabelSubscription.unsubscribe();\n        }\n        /** Re-aligns the ink bar to the selected tab element. */\n        realignInkBar() {\n            if (this._tabHeader) {\n                this._tabHeader._alignInkBarToSelectedTab();\n            }\n        }\n        _focusChanged(index) {\n            this.focusChange.emit(this._createChangeEvent(index));\n        }\n        _createChangeEvent(index) {\n            const event = new MatTabChangeEvent;\n            event.index = index;\n            if (this._tabs && this._tabs.length) {\n                event.tab = this._tabs.toArray()[index];\n            }\n            return event;\n        }\n        /**\n         * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is\n         * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n         * binding to be updated, we need to subscribe to changes in it and trigger change detection\n         * manually.\n         */\n        _subscribeToTabLabels() {\n            if (this._tabLabelSubscription) {\n                this._tabLabelSubscription.unsubscribe();\n            }\n            this._tabLabelSubscription = Object(merge[\"a\" /* merge */])(...this._tabs.map(tab => tab._stateChanges))\n                .subscribe(() => this._changeDetectorRef.markForCheck());\n        }\n        /** Clamps the given index to the bounds of 0 and the tabs length. */\n        _clampTabIndex(index) {\n            // Note the `|| 0`, which ensures that values like NaN can't get through\n            // and which would otherwise throw the component into an infinite loop\n            // (since Math.max(NaN, 0) === NaN).\n            return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));\n        }\n        /** Returns a unique id for each tab label element */\n        _getTabLabelId(i) {\n            return `mat-tab-label-${this._groupId}-${i}`;\n        }\n        /** Returns a unique id for each tab content element */\n        _getTabContentId(i) {\n            return `mat-tab-content-${this._groupId}-${i}`;\n        }\n        /**\n         * Sets the height of the body wrapper to the height of the activating tab if dynamic\n         * height property is true.\n         */\n        _setTabBodyWrapperHeight(tabHeight) {\n            if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {\n                return;\n            }\n            const wrapper = this._tabBodyWrapper.nativeElement;\n            wrapper.style.height = this._tabBodyWrapperHeight + 'px';\n            // This conditional forces the browser to paint the height so that\n            // the animation to the new height can have an origin.\n            if (this._tabBodyWrapper.nativeElement.offsetHeight) {\n                wrapper.style.height = tabHeight + 'px';\n            }\n        }\n        /** Removes the height of the tab body wrapper. */\n        _removeTabBodyWrapperHeight() {\n            const wrapper = this._tabBodyWrapper.nativeElement;\n            this._tabBodyWrapperHeight = wrapper.clientHeight;\n            wrapper.style.height = '';\n            this.animationDone.emit();\n        }\n        /** Handle click events, setting new selected index if appropriate. */\n        _handleClick(tab, tabHeader, index) {\n            if (!tab.disabled) {\n                this.selectedIndex = tabHeader.focusIndex = index;\n            }\n        }\n        /** Retrieves the tabindex for the tab. */\n        _getTabIndex(tab, idx) {\n            if (tab.disabled) {\n                return null;\n            }\n            return this.selectedIndex === idx ? 0 : -1;\n        }\n    }\n    _MatTabGroupBase.ɵfac = function _MatTabGroupBase_Factory(t) { return new (t || _MatTabGroupBase)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](MAT_TABS_CONFIG, 8), core[\"Qb\" /* ɵɵdirectiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    _MatTabGroupBase.ɵdir = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineDirective */]({ type: _MatTabGroupBase, inputs: { headerPosition: \"headerPosition\", animationDuration: \"animationDuration\", disablePagination: \"disablePagination\", dynamicHeight: \"dynamicHeight\", selectedIndex: \"selectedIndex\", backgroundColor: \"backgroundColor\" }, outputs: { selectedIndexChange: \"selectedIndexChange\", focusChange: \"focusChange\", animationDone: \"animationDone\", selectedTabChange: \"selectedTabChange\" }, features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]] });\n    return _MatTabGroupBase;\n})();\nlet tabs_MatTabGroup = /*@__PURE__*/ (() => {\n    class MatTabGroup extends tabs_MatTabGroupBase {\n        constructor(elementRef, changeDetectorRef, defaultConfig, animationMode) {\n            super(elementRef, changeDetectorRef, defaultConfig, animationMode);\n        }\n    }\n    MatTabGroup.ɵfac = function MatTabGroup_Factory(t) { return new (t || MatTabGroup)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](MAT_TABS_CONFIG, 8), core[\"Qb\" /* ɵɵdirectiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatTabGroup.ɵcmp = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineComponent */]({ type: MatTabGroup, selectors: [[\"mat-tab-group\"]], contentQueries: function MatTabGroup_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Jb\" /* ɵɵcontentQuery */](dirIndex, tabs_MatTab, 1);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._allTabs = _t);\n            }\n        }, viewQuery: function MatTabGroup_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Lc\" /* ɵɵviewQuery */](_c3, 1);\n                core[\"Lc\" /* ɵɵviewQuery */](_c4, 1);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._tabBodyWrapper = _t.first);\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._tabHeader = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-tab-group\"], hostVars: 4, hostBindings: function MatTabGroup_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Ib\" /* ɵɵclassProp */](\"mat-tab-group-dynamic-height\", ctx.dynamicHeight)(\"mat-tab-group-inverted-header\", ctx.headerPosition === \"below\");\n            }\n        }, inputs: { color: \"color\", disableRipple: \"disableRipple\" }, exportAs: [\"matTabGroup\"], features: [/*@__PURE__*/ core[\"Cb\" /* ɵɵProvidersFeature */]([{\n                    provide: MAT_TAB_GROUP,\n                    useExisting: MatTabGroup\n                }]), core[\"Ab\" /* ɵɵInheritDefinitionFeature */]], decls: 6, vars: 7, consts: [[3, \"selectedIndex\", \"disableRipple\", \"disablePagination\", \"indexFocused\", \"selectFocusedIndex\"], [\"tabHeader\", \"\"], [\"class\", \"mat-tab-label mat-focus-indicator\", \"role\", \"tab\", \"matTabLabelWrapper\", \"\", \"mat-ripple\", \"\", \"cdkMonitorElementFocus\", \"\", 3, \"id\", \"mat-tab-label-active\", \"disabled\", \"matRippleDisabled\", \"click\", 4, \"ngFor\", \"ngForOf\"], [1, \"mat-tab-body-wrapper\"], [\"tabBodyWrapper\", \"\"], [\"role\", \"tabpanel\", 3, \"id\", \"mat-tab-body-active\", \"content\", \"position\", \"origin\", \"animationDuration\", \"_onCentered\", \"_onCentering\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"tab\", \"matTabLabelWrapper\", \"\", \"mat-ripple\", \"\", \"cdkMonitorElementFocus\", \"\", 1, \"mat-tab-label\", \"mat-focus-indicator\", 3, \"id\", \"disabled\", \"matRippleDisabled\", \"click\"], [1, \"mat-tab-label-content\"], [3, \"ngIf\"], [3, \"cdkPortalOutlet\"], [\"role\", \"tabpanel\", 3, \"id\", \"content\", \"position\", \"origin\", \"animationDuration\", \"_onCentered\", \"_onCentering\"]], template: function MatTabGroup_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Wb\" /* ɵɵelementStart */](0, \"mat-tab-header\", 0, 1);\n                core[\"ec\" /* ɵɵlistener */](\"indexFocused\", function MatTabGroup_Template_mat_tab_header_indexFocused_0_listener($event) { return ctx._focusChanged($event); })(\"selectFocusedIndex\", function MatTabGroup_Template_mat_tab_header_selectFocusedIndex_0_listener($event) { return ctx.selectedIndex = $event; });\n                core[\"Gc\" /* ɵɵtemplate */](2, MatTabGroup_div_2_Template, 4, 14, \"div\", 2);\n                core[\"Vb\" /* ɵɵelementEnd */]();\n                core[\"Wb\" /* ɵɵelementStart */](3, \"div\", 3, 4);\n                core[\"Gc\" /* ɵɵtemplate */](5, MatTabGroup_mat_tab_body_5_Template, 1, 8, \"mat-tab-body\", 5);\n                core[\"Vb\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"pc\" /* ɵɵproperty */](\"selectedIndex\", ctx.selectedIndex || 0)(\"disableRipple\", ctx.disableRipple)(\"disablePagination\", ctx.disablePagination);\n                core[\"Db\" /* ɵɵadvance */](2);\n                core[\"pc\" /* ɵɵproperty */](\"ngForOf\", ctx._tabs);\n                core[\"Db\" /* ɵɵadvance */](1);\n                core[\"Ib\" /* ɵɵclassProp */](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n                core[\"Db\" /* ɵɵadvance */](2);\n                core[\"pc\" /* ɵɵproperty */](\"ngForOf\", ctx._tabs);\n            }\n        }, directives: function () { return [tabs_MatTabHeader, common[\"l\" /* NgForOf */], tabs_MatTabLabelWrapper, fesm2015_core[\"q\" /* MatRipple */], a11y[\"e\" /* CdkMonitorFocus */], common[\"m\" /* NgIf */], portal[\"c\" /* CdkPortalOutlet */], tabs_MatTabBody]; }, styles: [\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\\n\"], encapsulation: 2 });\n    return MatTabGroup;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Boilerplate for applying mixins to MatTabLabelWrapper.\n/** @docs-private */\nclass MatTabLabelWrapperBase {\n}\nconst _MatTabLabelWrapperMixinBase = /*@__PURE__*/ Object(fesm2015_core[\"x\" /* mixinDisabled */])(MatTabLabelWrapperBase);\nlet tabs_MatTabLabelWrapper = /*@__PURE__*/ (() => {\n    class MatTabLabelWrapper extends _MatTabLabelWrapperMixinBase {\n        constructor(elementRef) {\n            super();\n            this.elementRef = elementRef;\n        }\n        /** Sets focus on the wrapper element */\n        focus() {\n            this.elementRef.nativeElement.focus();\n        }\n        getOffsetLeft() {\n            return this.elementRef.nativeElement.offsetLeft;\n        }\n        getOffsetWidth() {\n            return this.elementRef.nativeElement.offsetWidth;\n        }\n    }\n    MatTabLabelWrapper.ɵfac = function MatTabLabelWrapper_Factory(t) { return new (t || MatTabLabelWrapper)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */])); };\n    MatTabLabelWrapper.ɵdir = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineDirective */]({ type: MatTabLabelWrapper, selectors: [[\"\", \"matTabLabelWrapper\", \"\"]], hostVars: 3, hostBindings: function MatTabLabelWrapper_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Eb\" /* ɵɵattribute */](\"aria-disabled\", !!ctx.disabled);\n                core[\"Ib\" /* ɵɵclassProp */](\"mat-tab-disabled\", ctx.disabled);\n            }\n        }, inputs: { disabled: \"disabled\" }, features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatTabLabelWrapper;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Config used to bind passive event listeners */\nconst passiveEventListenerOptions = /*@__PURE__*/ Object(fesm2015_platform[\"f\" /* normalizePassiveListenerOptions */])({ passive: true });\n/**\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n */\nconst EXAGGERATED_OVERSCROLL = 60;\n/**\n * Amount of milliseconds to wait before starting to scroll the header automatically.\n * Set a little conservatively in order to handle fake events dispatched on touch devices.\n */\nconst HEADER_SCROLL_DELAY = 650;\n/**\n * Interval in milliseconds at which to scroll the header\n * while the user is holding their pointer.\n */\nconst HEADER_SCROLL_INTERVAL = 100;\nlet tabs_MatPaginatedTabHeader = /*@__PURE__*/ (() => {\n    class MatPaginatedTabHeader {\n        constructor(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone, _platform, _animationMode) {\n            this._elementRef = _elementRef;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._viewportRuler = _viewportRuler;\n            this._dir = _dir;\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            this._animationMode = _animationMode;\n            /** The distance in pixels that the tab labels should be translated to the left. */\n            this._scrollDistance = 0;\n            /** Whether the header should scroll to the selected index after the view has been checked. */\n            this._selectedIndexChanged = false;\n            /** Emits when the component is destroyed. */\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n            /** Whether the controls for pagination should be displayed */\n            this._showPaginationControls = false;\n            /** Whether the tab list can be scrolled more towards the end of the tab label list. */\n            this._disableScrollAfter = true;\n            /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */\n            this._disableScrollBefore = true;\n            /** Stream that will stop the automated scrolling. */\n            this._stopScrolling = new Subject[\"a\" /* Subject */]();\n            /**\n             * Whether pagination should be disabled. This can be used to avoid unnecessary\n             * layout recalculations if it's known that pagination won't be required.\n             */\n            this.disablePagination = false;\n            this._selectedIndex = 0;\n            /** Event emitted when the option is selected. */\n            this.selectFocusedIndex = new core[\"o\" /* EventEmitter */]();\n            /** Event emitted when a label is focused. */\n            this.indexFocused = new core[\"o\" /* EventEmitter */]();\n            // Bind the `mouseleave` event on the outside since it doesn't change anything in the view.\n            _ngZone.runOutsideAngular(() => {\n                Object(fromEvent[\"a\" /* fromEvent */])(_elementRef.nativeElement, 'mouseleave')\n                    .pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed))\n                    .subscribe(() => {\n                    this._stopInterval();\n                });\n            });\n        }\n        /** The index of the active tab. */\n        get selectedIndex() { return this._selectedIndex; }\n        set selectedIndex(value) {\n            value = Object(coercion[\"f\" /* coerceNumberProperty */])(value);\n            if (this._selectedIndex != value) {\n                this._selectedIndexChanged = true;\n                this._selectedIndex = value;\n                if (this._keyManager) {\n                    this._keyManager.updateActiveItem(value);\n                }\n            }\n        }\n        ngAfterViewInit() {\n            // We need to handle these events manually, because we want to bind passive event listeners.\n            Object(fromEvent[\"a\" /* fromEvent */])(this._previousPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n                .pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed))\n                .subscribe(() => {\n                this._handlePaginatorPress('before');\n            });\n            Object(fromEvent[\"a\" /* fromEvent */])(this._nextPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n                .pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed))\n                .subscribe(() => {\n                this._handlePaginatorPress('after');\n            });\n        }\n        ngAfterContentInit() {\n            const dirChange = this._dir ? this._dir.change : Object(of[\"a\" /* of */])(null);\n            const resize = this._viewportRuler.change(150);\n            const realign = () => {\n                this.updatePagination();\n                this._alignInkBarToSelectedTab();\n            };\n            this._keyManager = new a11y[\"g\" /* FocusKeyManager */](this._items)\n                .withHorizontalOrientation(this._getLayoutDirection())\n                .withHomeAndEnd()\n                .withWrap();\n            this._keyManager.updateActiveItem(this._selectedIndex);\n            // Defer the first call in order to allow for slower browsers to lay out the elements.\n            // This helps in cases where the user lands directly on a page with paginated tabs.\n            typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign();\n            // On dir change or window resize, realign the ink bar and update the orientation of\n            // the key manager if the direction has changed.\n            Object(merge[\"a\" /* merge */])(dirChange, resize, this._items.changes).pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed)).subscribe(() => {\n                // We need to defer this to give the browser some time to recalculate the element dimensions.\n                Promise.resolve().then(realign);\n                this._keyManager.withHorizontalOrientation(this._getLayoutDirection());\n            });\n            // If there is a change in the focus key manager we need to emit the `indexFocused`\n            // event in order to provide a public event that notifies about focus changes. Also we realign\n            // the tabs container by scrolling the new focused tab into the visible section.\n            this._keyManager.change.pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed)).subscribe(newFocusIndex => {\n                this.indexFocused.emit(newFocusIndex);\n                this._setTabFocus(newFocusIndex);\n            });\n        }\n        ngAfterContentChecked() {\n            // If the number of tab labels have changed, check if scrolling should be enabled\n            if (this._tabLabelCount != this._items.length) {\n                this.updatePagination();\n                this._tabLabelCount = this._items.length;\n                this._changeDetectorRef.markForCheck();\n            }\n            // If the selected index has changed, scroll to the label and check if the scrolling controls\n            // should be disabled.\n            if (this._selectedIndexChanged) {\n                this._scrollToLabel(this._selectedIndex);\n                this._checkScrollingControls();\n                this._alignInkBarToSelectedTab();\n                this._selectedIndexChanged = false;\n                this._changeDetectorRef.markForCheck();\n            }\n            // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n            // then translate the header to reflect this.\n            if (this._scrollDistanceChanged) {\n                this._updateTabScrollPosition();\n                this._scrollDistanceChanged = false;\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        ngOnDestroy() {\n            this._destroyed.next();\n            this._destroyed.complete();\n            this._stopScrolling.complete();\n        }\n        /** Handles keyboard events on the header. */\n        _handleKeydown(event) {\n            // We don't handle any key bindings with a modifier key.\n            if (Object(keycodes[\"r\" /* hasModifierKey */])(event)) {\n                return;\n            }\n            switch (event.keyCode) {\n                case keycodes[\"e\" /* ENTER */]:\n                case keycodes[\"m\" /* SPACE */]:\n                    if (this.focusIndex !== this.selectedIndex) {\n                        this.selectFocusedIndex.emit(this.focusIndex);\n                        this._itemSelected(event);\n                    }\n                    break;\n                default:\n                    this._keyManager.onKeydown(event);\n            }\n        }\n        /**\n         * Callback for when the MutationObserver detects that the content has changed.\n         */\n        _onContentChanges() {\n            const textContent = this._elementRef.nativeElement.textContent;\n            // We need to diff the text content of the header, because the MutationObserver callback\n            // will fire even if the text content didn't change which is inefficient and is prone\n            // to infinite loops if a poorly constructed expression is passed in (see #14249).\n            if (textContent !== this._currentTextContent) {\n                this._currentTextContent = textContent || '';\n                // The content observer runs outside the `NgZone` by default, which\n                // means that we need to bring the callback back in ourselves.\n                this._ngZone.run(() => {\n                    this.updatePagination();\n                    this._alignInkBarToSelectedTab();\n                    this._changeDetectorRef.markForCheck();\n                });\n            }\n        }\n        /**\n         * Updates the view whether pagination should be enabled or not.\n         *\n         * WARNING: Calling this method can be very costly in terms of performance. It should be called\n         * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n         * page.\n         */\n        updatePagination() {\n            this._checkPaginationEnabled();\n            this._checkScrollingControls();\n            this._updateTabScrollPosition();\n        }\n        /** Tracks which element has focus; used for keyboard navigation */\n        get focusIndex() {\n            return this._keyManager ? this._keyManager.activeItemIndex : 0;\n        }\n        /** When the focus index is set, we must manually send focus to the correct label */\n        set focusIndex(value) {\n            if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {\n                return;\n            }\n            this._keyManager.setActiveItem(value);\n        }\n        /**\n         * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n         * providing a valid index and return true.\n         */\n        _isValidIndex(index) {\n            if (!this._items) {\n                return true;\n            }\n            const tab = this._items ? this._items.toArray()[index] : null;\n            return !!tab && !tab.disabled;\n        }\n        /**\n         * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n         * scrolling is enabled.\n         */\n        _setTabFocus(tabIndex) {\n            if (this._showPaginationControls) {\n                this._scrollToLabel(tabIndex);\n            }\n            if (this._items && this._items.length) {\n                this._items.toArray()[tabIndex].focus();\n                // Do not let the browser manage scrolling to focus the element, this will be handled\n                // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\n                // should be the full width minus the offset width.\n                const containerEl = this._tabListContainer.nativeElement;\n                const dir = this._getLayoutDirection();\n                if (dir == 'ltr') {\n                    containerEl.scrollLeft = 0;\n                }\n                else {\n                    containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n                }\n            }\n        }\n        /** The layout direction of the containing app. */\n        _getLayoutDirection() {\n            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n        }\n        /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n        _updateTabScrollPosition() {\n            if (this.disablePagination) {\n                return;\n            }\n            const scrollDistance = this.scrollDistance;\n            const translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;\n            // Don't use `translate3d` here because we don't want to create a new layer. A new layer\n            // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar\n            // and ripples will exceed the boundaries of the visible tab bar.\n            // See: https://github.com/angular/components/issues/10276\n            // We round the `transform` here, because transforms with sub-pixel precision cause some\n            // browsers to blur the content of the element.\n            this._tabList.nativeElement.style.transform = `translateX(${Math.round(translateX)}px)`;\n            // Setting the `transform` on IE will change the scroll offset of the parent, causing the\n            // position to be thrown off in some cases. We have to reset it ourselves to ensure that\n            // it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing\n            // with the scroll position throws off Chrome 71+ in RTL mode (see #14689).\n            if (this._platform.TRIDENT || this._platform.EDGE) {\n                this._tabListContainer.nativeElement.scrollLeft = 0;\n            }\n        }\n        /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n        get scrollDistance() { return this._scrollDistance; }\n        set scrollDistance(value) {\n            this._scrollTo(value);\n        }\n        /**\n         * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n         * the end of the list, respectively). The distance to scroll is computed to be a third of the\n         * length of the tab list view window.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _scrollHeader(direction) {\n            const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n            // Move the scroll distance one-third the length of the tab list's viewport.\n            const scrollAmount = (direction == 'before' ? -1 : 1) * viewLength / 3;\n            return this._scrollTo(this._scrollDistance + scrollAmount);\n        }\n        /** Handles click events on the pagination arrows. */\n        _handlePaginatorClick(direction) {\n            this._stopInterval();\n            this._scrollHeader(direction);\n        }\n        /**\n         * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _scrollToLabel(labelIndex) {\n            if (this.disablePagination) {\n                return;\n            }\n            const selectedLabel = this._items ? this._items.toArray()[labelIndex] : null;\n            if (!selectedLabel) {\n                return;\n            }\n            // The view length is the visible width of the tab labels.\n            const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n            const { offsetLeft, offsetWidth } = selectedLabel.elementRef.nativeElement;\n            let labelBeforePos, labelAfterPos;\n            if (this._getLayoutDirection() == 'ltr') {\n                labelBeforePos = offsetLeft;\n                labelAfterPos = labelBeforePos + offsetWidth;\n            }\n            else {\n                labelAfterPos = this._tabList.nativeElement.offsetWidth - offsetLeft;\n                labelBeforePos = labelAfterPos - offsetWidth;\n            }\n            const beforeVisiblePos = this.scrollDistance;\n            const afterVisiblePos = this.scrollDistance + viewLength;\n            if (labelBeforePos < beforeVisiblePos) {\n                // Scroll header to move label to the before direction\n                this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n            }\n            else if (labelAfterPos > afterVisiblePos) {\n                // Scroll header to move label to the after direction\n                this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n            }\n        }\n        /**\n         * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n         * tab list is wider than the size of the header container, then the pagination controls should\n         * be shown.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _checkPaginationEnabled() {\n            if (this.disablePagination) {\n                this._showPaginationControls = false;\n            }\n            else {\n                const isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n                if (!isEnabled) {\n                    this.scrollDistance = 0;\n                }\n                if (isEnabled !== this._showPaginationControls) {\n                    this._changeDetectorRef.markForCheck();\n                }\n                this._showPaginationControls = isEnabled;\n            }\n        }\n        /**\n         * Evaluate whether the before and after controls should be enabled or disabled.\n         * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n         * before button. If the header is at the end of the list (scroll distance is equal to the\n         * maximum distance we can scroll), then disable the after button.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _checkScrollingControls() {\n            if (this.disablePagination) {\n                this._disableScrollAfter = this._disableScrollBefore = true;\n            }\n            else {\n                // Check if the pagination arrows should be activated.\n                this._disableScrollBefore = this.scrollDistance == 0;\n                this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        /**\n         * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n         * is equal to the difference in width between the tab list container and tab header container.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _getMaxScrollDistance() {\n            const lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n            const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n            return (lengthOfTabList - viewLength) || 0;\n        }\n        /** Tells the ink-bar to align itself to the current label wrapper */\n        _alignInkBarToSelectedTab() {\n            const selectedItem = this._items && this._items.length ?\n                this._items.toArray()[this.selectedIndex] : null;\n            const selectedLabelWrapper = selectedItem ? selectedItem.elementRef.nativeElement : null;\n            if (selectedLabelWrapper) {\n                this._inkBar.alignToElement(selectedLabelWrapper);\n            }\n            else {\n                this._inkBar.hide();\n            }\n        }\n        /** Stops the currently-running paginator interval.  */\n        _stopInterval() {\n            this._stopScrolling.next();\n        }\n        /**\n         * Handles the user pressing down on one of the paginators.\n         * Starts scrolling the header after a certain amount of time.\n         * @param direction In which direction the paginator should be scrolled.\n         */\n        _handlePaginatorPress(direction, mouseEvent) {\n            // Don't start auto scrolling for right mouse button clicks. Note that we shouldn't have to\n            // null check the `button`, but we do it so we don't break tests that use fake events.\n            if (mouseEvent && mouseEvent.button != null && mouseEvent.button !== 0) {\n                return;\n            }\n            // Avoid overlapping timers.\n            this._stopInterval();\n            // Start a timer after the delay and keep firing based on the interval.\n            Object(timer[\"a\" /* timer */])(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL)\n                // Keep the timer going until something tells it to stop or the component is destroyed.\n                .pipe(Object(takeUntil[\"a\" /* takeUntil */])(Object(merge[\"a\" /* merge */])(this._stopScrolling, this._destroyed)))\n                .subscribe(() => {\n                const { maxScrollDistance, distance } = this._scrollHeader(direction);\n                // Stop the timer if we've reached the start or the end.\n                if (distance === 0 || distance >= maxScrollDistance) {\n                    this._stopInterval();\n                }\n            });\n        }\n        /**\n         * Scrolls the header to a given position.\n         * @param position Position to which to scroll.\n         * @returns Information on the current scroll distance and the maximum.\n         */\n        _scrollTo(position) {\n            if (this.disablePagination) {\n                return { maxScrollDistance: 0, distance: 0 };\n            }\n            const maxScrollDistance = this._getMaxScrollDistance();\n            this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));\n            // Mark that the scroll distance has changed so that after the view is checked, the CSS\n            // transformation can move the header.\n            this._scrollDistanceChanged = true;\n            this._checkScrollingControls();\n            return { maxScrollDistance, distance: this._scrollDistance };\n        }\n    }\n    MatPaginatedTabHeader.ɵfac = function MatPaginatedTabHeader_Factory(t) { return new (t || MatPaginatedTabHeader)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](scrolling[\"h\" /* ViewportRuler */]), core[\"Qb\" /* ɵɵdirectiveInject */](bidi[\"b\" /* Directionality */], 8), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Qb\" /* ɵɵdirectiveInject */](fesm2015_platform[\"a\" /* Platform */]), core[\"Qb\" /* ɵɵdirectiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatPaginatedTabHeader.ɵdir = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineDirective */]({ type: MatPaginatedTabHeader, inputs: { disablePagination: \"disablePagination\" } });\n    return MatPaginatedTabHeader;\n})();\nlet tabs_MatTabHeaderBase = /*@__PURE__*/ (() => {\n    class _MatTabHeaderBase extends tabs_MatPaginatedTabHeader {\n        constructor(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) {\n            super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);\n            this._disableRipple = false;\n        }\n        /** Whether the ripple effect is disabled or not. */\n        get disableRipple() { return this._disableRipple; }\n        set disableRipple(value) { this._disableRipple = Object(coercion[\"c\" /* coerceBooleanProperty */])(value); }\n        _itemSelected(event) {\n            event.preventDefault();\n        }\n    }\n    _MatTabHeaderBase.ɵfac = function _MatTabHeaderBase_Factory(t) { return new (t || _MatTabHeaderBase)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](scrolling[\"h\" /* ViewportRuler */]), core[\"Qb\" /* ɵɵdirectiveInject */](bidi[\"b\" /* Directionality */], 8), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Qb\" /* ɵɵdirectiveInject */](fesm2015_platform[\"a\" /* Platform */]), core[\"Qb\" /* ɵɵdirectiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    _MatTabHeaderBase.ɵdir = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineDirective */]({ type: _MatTabHeaderBase, inputs: { disableRipple: \"disableRipple\" }, features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]] });\n    return _MatTabHeaderBase;\n})();\nlet tabs_MatTabHeader = /*@__PURE__*/ (() => {\n    class MatTabHeader extends tabs_MatTabHeaderBase {\n        constructor(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) {\n            super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);\n        }\n    }\n    MatTabHeader.ɵfac = function MatTabHeader_Factory(t) { return new (t || MatTabHeader)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](scrolling[\"h\" /* ViewportRuler */]), core[\"Qb\" /* ɵɵdirectiveInject */](bidi[\"b\" /* Directionality */], 8), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Qb\" /* ɵɵdirectiveInject */](fesm2015_platform[\"a\" /* Platform */]), core[\"Qb\" /* ɵɵdirectiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatTabHeader.ɵcmp = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineComponent */]({ type: MatTabHeader, selectors: [[\"mat-tab-header\"]], contentQueries: function MatTabHeader_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Jb\" /* ɵɵcontentQuery */](dirIndex, tabs_MatTabLabelWrapper, 0);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._items = _t);\n            }\n        }, viewQuery: function MatTabHeader_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Lc\" /* ɵɵviewQuery */](tabs_MatInkBar, 3);\n                core[\"Lc\" /* ɵɵviewQuery */](_c5, 3);\n                core[\"Lc\" /* ɵɵviewQuery */](_c6, 3);\n                core[\"Lc\" /* ɵɵviewQuery */](_c7, 1);\n                core[\"Lc\" /* ɵɵviewQuery */](_c8, 1);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._inkBar = _t.first);\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._tabListContainer = _t.first);\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._tabList = _t.first);\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._nextPaginator = _t.first);\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._previousPaginator = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-tab-header\"], hostVars: 4, hostBindings: function MatTabHeader_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Ib\" /* ɵɵclassProp */](\"mat-tab-header-pagination-controls-enabled\", ctx._showPaginationControls)(\"mat-tab-header-rtl\", ctx._getLayoutDirection() == \"rtl\");\n            }\n        }, inputs: { selectedIndex: \"selectedIndex\" }, outputs: { selectFocusedIndex: \"selectFocusedIndex\", indexFocused: \"indexFocused\" }, features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]], ngContentSelectors: _c0, decls: 13, vars: 8, consts: [[\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-before\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"click\", \"mousedown\", \"touchend\"], [\"previousPaginator\", \"\"], [1, \"mat-tab-header-pagination-chevron\"], [1, \"mat-tab-label-container\", 3, \"keydown\"], [\"tabListContainer\", \"\"], [\"role\", \"tablist\", 1, \"mat-tab-list\", 3, \"cdkObserveContent\"], [\"tabList\", \"\"], [1, \"mat-tab-labels\"], [\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-after\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"mousedown\", \"click\", \"touchend\"], [\"nextPaginator\", \"\"]], template: function MatTabHeader_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */]();\n                core[\"Wb\" /* ɵɵelementStart */](0, \"div\", 0, 1);\n                core[\"ec\" /* ɵɵlistener */](\"click\", function MatTabHeader_Template_div_click_0_listener() { return ctx._handlePaginatorClick(\"before\"); })(\"mousedown\", function MatTabHeader_Template_div_mousedown_0_listener($event) { return ctx._handlePaginatorPress(\"before\", $event); })(\"touchend\", function MatTabHeader_Template_div_touchend_0_listener() { return ctx._stopInterval(); });\n                core[\"Rb\" /* ɵɵelement */](2, \"div\", 2);\n                core[\"Vb\" /* ɵɵelementEnd */]();\n                core[\"Wb\" /* ɵɵelementStart */](3, \"div\", 3, 4);\n                core[\"ec\" /* ɵɵlistener */](\"keydown\", function MatTabHeader_Template_div_keydown_3_listener($event) { return ctx._handleKeydown($event); });\n                core[\"Wb\" /* ɵɵelementStart */](5, \"div\", 5, 6);\n                core[\"ec\" /* ɵɵlistener */](\"cdkObserveContent\", function MatTabHeader_Template_div_cdkObserveContent_5_listener() { return ctx._onContentChanges(); });\n                core[\"Wb\" /* ɵɵelementStart */](7, \"div\", 7);\n                core[\"nc\" /* ɵɵprojection */](8);\n                core[\"Vb\" /* ɵɵelementEnd */]();\n                core[\"Rb\" /* ɵɵelement */](9, \"mat-ink-bar\");\n                core[\"Vb\" /* ɵɵelementEnd */]();\n                core[\"Vb\" /* ɵɵelementEnd */]();\n                core[\"Wb\" /* ɵɵelementStart */](10, \"div\", 8, 9);\n                core[\"ec\" /* ɵɵlistener */](\"mousedown\", function MatTabHeader_Template_div_mousedown_10_listener($event) { return ctx._handlePaginatorPress(\"after\", $event); })(\"click\", function MatTabHeader_Template_div_click_10_listener() { return ctx._handlePaginatorClick(\"after\"); })(\"touchend\", function MatTabHeader_Template_div_touchend_10_listener() { return ctx._stopInterval(); });\n                core[\"Rb\" /* ɵɵelement */](12, \"div\", 2);\n                core[\"Vb\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"Ib\" /* ɵɵclassProp */](\"mat-tab-header-pagination-disabled\", ctx._disableScrollBefore);\n                core[\"pc\" /* ɵɵproperty */](\"matRippleDisabled\", ctx._disableScrollBefore || ctx.disableRipple);\n                core[\"Db\" /* ɵɵadvance */](5);\n                core[\"Ib\" /* ɵɵclassProp */](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n                core[\"Db\" /* ɵɵadvance */](5);\n                core[\"Ib\" /* ɵɵclassProp */](\"mat-tab-header-pagination-disabled\", ctx._disableScrollAfter);\n                core[\"pc\" /* ɵɵproperty */](\"matRippleDisabled\", ctx._disableScrollAfter || ctx.disableRipple);\n            }\n        }, directives: [fesm2015_core[\"q\" /* MatRipple */], observers[\"a\" /* CdkObserveContent */], tabs_MatInkBar], styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\\\"\\\";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-labels{display:flex}[mat-align-tabs=center]>.mat-tab-header .mat-tab-labels{justify-content:center}[mat-align-tabs=end]>.mat-tab-header .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{min-width:72px}}\\n\"], encapsulation: 2 });\n    return MatTabHeader;\n})();\nlet tabs_MatTabNavBase = /*@__PURE__*/ (() => {\n    class _MatTabNavBase extends tabs_MatPaginatedTabHeader {\n        constructor(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode) {\n            super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);\n            this._disableRipple = false;\n            /** Theme color of the nav bar. */\n            this.color = 'primary';\n        }\n        /** Background color of the tab nav. */\n        get backgroundColor() { return this._backgroundColor; }\n        set backgroundColor(value) {\n            const classList = this._elementRef.nativeElement.classList;\n            classList.remove(`mat-background-${this.backgroundColor}`);\n            if (value) {\n                classList.add(`mat-background-${value}`);\n            }\n            this._backgroundColor = value;\n        }\n        /** Whether the ripple effect is disabled or not. */\n        get disableRipple() { return this._disableRipple; }\n        set disableRipple(value) { this._disableRipple = Object(coercion[\"c\" /* coerceBooleanProperty */])(value); }\n        _itemSelected() {\n            // noop\n        }\n        ngAfterContentInit() {\n            // We need this to run before the `changes` subscription in parent to ensure that the\n            // selectedIndex is up-to-date by the time the super class starts looking for it.\n            this._items.changes.pipe(Object(startWith[\"a\" /* startWith */])(null), Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed)).subscribe(() => {\n                this.updateActiveLink();\n            });\n            super.ngAfterContentInit();\n        }\n        /** Notifies the component that the active link has been changed. */\n        updateActiveLink() {\n            if (!this._items) {\n                return;\n            }\n            const items = this._items.toArray();\n            for (let i = 0; i < items.length; i++) {\n                if (items[i].active) {\n                    this.selectedIndex = i;\n                    this._changeDetectorRef.markForCheck();\n                    return;\n                }\n            }\n            // The ink bar should hide itself if no items are active.\n            this.selectedIndex = -1;\n            this._inkBar.hide();\n        }\n    }\n    _MatTabNavBase.ɵfac = function _MatTabNavBase_Factory(t) { return new (t || _MatTabNavBase)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](bidi[\"b\" /* Directionality */], 8), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](scrolling[\"h\" /* ViewportRuler */]), core[\"Qb\" /* ɵɵdirectiveInject */](fesm2015_platform[\"a\" /* Platform */]), core[\"Qb\" /* ɵɵdirectiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    _MatTabNavBase.ɵdir = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineDirective */]({ type: _MatTabNavBase, inputs: { color: \"color\", backgroundColor: \"backgroundColor\", disableRipple: \"disableRipple\" }, features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]] });\n    return _MatTabNavBase;\n})();\nlet tabs_MatTabNav = /*@__PURE__*/ (() => {\n    class MatTabNav extends tabs_MatTabNavBase {\n        constructor(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode) {\n            super(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode);\n        }\n    }\n    MatTabNav.ɵfac = function MatTabNav_Factory(t) { return new (t || MatTabNav)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](bidi[\"b\" /* Directionality */], 8), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](scrolling[\"h\" /* ViewportRuler */]), core[\"Qb\" /* ɵɵdirectiveInject */](fesm2015_platform[\"a\" /* Platform */]), core[\"Qb\" /* ɵɵdirectiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatTabNav.ɵcmp = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineComponent */]({ type: MatTabNav, selectors: [[\"\", \"mat-tab-nav-bar\", \"\"]], contentQueries: function MatTabNav_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Jb\" /* ɵɵcontentQuery */](dirIndex, tabs_MatTabLink, 1);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._items = _t);\n            }\n        }, viewQuery: function MatTabNav_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Lc\" /* ɵɵviewQuery */](tabs_MatInkBar, 3);\n                core[\"Lc\" /* ɵɵviewQuery */](_c5, 3);\n                core[\"Lc\" /* ɵɵviewQuery */](_c6, 3);\n                core[\"Lc\" /* ɵɵviewQuery */](_c7, 1);\n                core[\"Lc\" /* ɵɵviewQuery */](_c8, 1);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._inkBar = _t.first);\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._tabListContainer = _t.first);\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._tabList = _t.first);\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._nextPaginator = _t.first);\n                core[\"uc\" /* ɵɵqueryRefresh */](_t = core[\"fc\" /* ɵɵloadQuery */]()) && (ctx._previousPaginator = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-tab-nav-bar\", \"mat-tab-header\"], hostVars: 10, hostBindings: function MatTabNav_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Ib\" /* ɵɵclassProp */](\"mat-tab-header-pagination-controls-enabled\", ctx._showPaginationControls)(\"mat-tab-header-rtl\", ctx._getLayoutDirection() == \"rtl\")(\"mat-primary\", ctx.color !== \"warn\" && ctx.color !== \"accent\")(\"mat-accent\", ctx.color === \"accent\")(\"mat-warn\", ctx.color === \"warn\");\n            }\n        }, inputs: { color: \"color\" }, exportAs: [\"matTabNavBar\", \"matTabNav\"], features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]], attrs: _c9, ngContentSelectors: _c0, decls: 13, vars: 8, consts: [[\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-before\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"click\", \"mousedown\", \"touchend\"], [\"previousPaginator\", \"\"], [1, \"mat-tab-header-pagination-chevron\"], [1, \"mat-tab-link-container\", 3, \"keydown\"], [\"tabListContainer\", \"\"], [1, \"mat-tab-list\", 3, \"cdkObserveContent\"], [\"tabList\", \"\"], [1, \"mat-tab-links\"], [\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-after\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"mousedown\", \"click\", \"touchend\"], [\"nextPaginator\", \"\"]], template: function MatTabNav_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */]();\n                core[\"Wb\" /* ɵɵelementStart */](0, \"div\", 0, 1);\n                core[\"ec\" /* ɵɵlistener */](\"click\", function MatTabNav_Template_div_click_0_listener() { return ctx._handlePaginatorClick(\"before\"); })(\"mousedown\", function MatTabNav_Template_div_mousedown_0_listener($event) { return ctx._handlePaginatorPress(\"before\", $event); })(\"touchend\", function MatTabNav_Template_div_touchend_0_listener() { return ctx._stopInterval(); });\n                core[\"Rb\" /* ɵɵelement */](2, \"div\", 2);\n                core[\"Vb\" /* ɵɵelementEnd */]();\n                core[\"Wb\" /* ɵɵelementStart */](3, \"div\", 3, 4);\n                core[\"ec\" /* ɵɵlistener */](\"keydown\", function MatTabNav_Template_div_keydown_3_listener($event) { return ctx._handleKeydown($event); });\n                core[\"Wb\" /* ɵɵelementStart */](5, \"div\", 5, 6);\n                core[\"ec\" /* ɵɵlistener */](\"cdkObserveContent\", function MatTabNav_Template_div_cdkObserveContent_5_listener() { return ctx._onContentChanges(); });\n                core[\"Wb\" /* ɵɵelementStart */](7, \"div\", 7);\n                core[\"nc\" /* ɵɵprojection */](8);\n                core[\"Vb\" /* ɵɵelementEnd */]();\n                core[\"Rb\" /* ɵɵelement */](9, \"mat-ink-bar\");\n                core[\"Vb\" /* ɵɵelementEnd */]();\n                core[\"Vb\" /* ɵɵelementEnd */]();\n                core[\"Wb\" /* ɵɵelementStart */](10, \"div\", 8, 9);\n                core[\"ec\" /* ɵɵlistener */](\"mousedown\", function MatTabNav_Template_div_mousedown_10_listener($event) { return ctx._handlePaginatorPress(\"after\", $event); })(\"click\", function MatTabNav_Template_div_click_10_listener() { return ctx._handlePaginatorClick(\"after\"); })(\"touchend\", function MatTabNav_Template_div_touchend_10_listener() { return ctx._stopInterval(); });\n                core[\"Rb\" /* ɵɵelement */](12, \"div\", 2);\n                core[\"Vb\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"Ib\" /* ɵɵclassProp */](\"mat-tab-header-pagination-disabled\", ctx._disableScrollBefore);\n                core[\"pc\" /* ɵɵproperty */](\"matRippleDisabled\", ctx._disableScrollBefore || ctx.disableRipple);\n                core[\"Db\" /* ɵɵadvance */](5);\n                core[\"Ib\" /* ɵɵclassProp */](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n                core[\"Db\" /* ɵɵadvance */](5);\n                core[\"Ib\" /* ɵɵclassProp */](\"mat-tab-header-pagination-disabled\", ctx._disableScrollAfter);\n                core[\"pc\" /* ɵɵproperty */](\"matRippleDisabled\", ctx._disableScrollAfter || ctx.disableRipple);\n            }\n        }, directives: [fesm2015_core[\"q\" /* MatRipple */], observers[\"a\" /* CdkObserveContent */], tabs_MatInkBar], styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\\\"\\\";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-tab-links{display:flex}[mat-align-tabs=center]>.mat-tab-link-container .mat-tab-links{justify-content:center}[mat-align-tabs=end]>.mat-tab-link-container .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:none}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-link:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-link.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-link.mat-tab-disabled{opacity:.5}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-link{opacity:1}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media(max-width: 599px){.mat-tab-link{min-width:72px}}\\n\"], encapsulation: 2 });\n    return MatTabNav;\n})();\n// Boilerplate for applying mixins to MatTabLink.\nclass MatTabLinkMixinBase {\n}\nconst _MatTabLinkMixinBase = /*@__PURE__*/ Object(fesm2015_core[\"A\" /* mixinTabIndex */])(/*@__PURE__*/ Object(fesm2015_core[\"w\" /* mixinDisableRipple */])(/*@__PURE__*/ Object(fesm2015_core[\"x\" /* mixinDisabled */])(MatTabLinkMixinBase)));\nlet tabs_MatTabLinkBase = /*@__PURE__*/ (() => {\n    class _MatTabLinkBase extends _MatTabLinkMixinBase {\n        constructor(_tabNavBar, \n        /** @docs-private */ elementRef, globalRippleOptions, tabIndex, _focusMonitor, animationMode) {\n            super();\n            this._tabNavBar = _tabNavBar;\n            this.elementRef = elementRef;\n            this._focusMonitor = _focusMonitor;\n            /** Whether the tab link is active or not. */\n            this._isActive = false;\n            this.rippleConfig = globalRippleOptions || {};\n            this.tabIndex = parseInt(tabIndex) || 0;\n            if (animationMode === 'NoopAnimations') {\n                this.rippleConfig.animation = { enterDuration: 0, exitDuration: 0 };\n            }\n        }\n        /** Whether the link is active. */\n        get active() { return this._isActive; }\n        set active(value) {\n            const newValue = Object(coercion[\"c\" /* coerceBooleanProperty */])(value);\n            if (newValue !== this._isActive) {\n                this._isActive = value;\n                this._tabNavBar.updateActiveLink();\n            }\n        }\n        /**\n         * Whether ripples are disabled on interaction.\n         * @docs-private\n         */\n        get rippleDisabled() {\n            return this.disabled || this.disableRipple || this._tabNavBar.disableRipple ||\n                !!this.rippleConfig.disabled;\n        }\n        /** Focuses the tab link. */\n        focus() {\n            this.elementRef.nativeElement.focus();\n        }\n        ngAfterViewInit() {\n            this._focusMonitor.monitor(this.elementRef);\n        }\n        ngOnDestroy() {\n            this._focusMonitor.stopMonitoring(this.elementRef);\n        }\n    }\n    _MatTabLinkBase.ɵfac = function _MatTabLinkBase_Factory(t) { return new (t || _MatTabLinkBase)(core[\"Qb\" /* ɵɵdirectiveInject */](tabs_MatTabNavBase), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](fesm2015_core[\"i\" /* MAT_RIPPLE_GLOBAL_OPTIONS */], 8), core[\"bc\" /* ɵɵinjectAttribute */]('tabindex'), core[\"Qb\" /* ɵɵdirectiveInject */](a11y[\"h\" /* FocusMonitor */]), core[\"Qb\" /* ɵɵdirectiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    _MatTabLinkBase.ɵdir = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineDirective */]({ type: _MatTabLinkBase, inputs: { active: \"active\" }, features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]] });\n    return _MatTabLinkBase;\n})();\nlet tabs_MatTabLink = /*@__PURE__*/ (() => {\n    class MatTabLink extends tabs_MatTabLinkBase {\n        constructor(tabNavBar, elementRef, ngZone, platform, globalRippleOptions, tabIndex, focusMonitor, animationMode) {\n            super(tabNavBar, elementRef, globalRippleOptions, tabIndex, focusMonitor, animationMode);\n            this._tabLinkRipple = new fesm2015_core[\"s\" /* RippleRenderer */](this, ngZone, elementRef, platform);\n            this._tabLinkRipple.setupTriggerEvents(elementRef.nativeElement);\n        }\n        ngOnDestroy() {\n            super.ngOnDestroy();\n            this._tabLinkRipple._removeTriggerEvents();\n        }\n    }\n    MatTabLink.ɵfac = function MatTabLink_Factory(t) { return new (t || MatTabLink)(core[\"Qb\" /* ɵɵdirectiveInject */](tabs_MatTabNav), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Qb\" /* ɵɵdirectiveInject */](fesm2015_platform[\"a\" /* Platform */]), core[\"Qb\" /* ɵɵdirectiveInject */](fesm2015_core[\"i\" /* MAT_RIPPLE_GLOBAL_OPTIONS */], 8), core[\"bc\" /* ɵɵinjectAttribute */]('tabindex'), core[\"Qb\" /* ɵɵdirectiveInject */](a11y[\"h\" /* FocusMonitor */]), core[\"Qb\" /* ɵɵdirectiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatTabLink.ɵdir = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineDirective */]({ type: MatTabLink, selectors: [[\"\", \"mat-tab-link\", \"\"], [\"\", \"matTabLink\", \"\"]], hostAttrs: [1, \"mat-tab-link\", \"mat-focus-indicator\"], hostVars: 7, hostBindings: function MatTabLink_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Eb\" /* ɵɵattribute */](\"aria-current\", ctx.active ? \"page\" : null)(\"aria-disabled\", ctx.disabled)(\"tabIndex\", ctx.tabIndex);\n                core[\"Ib\" /* ɵɵclassProp */](\"mat-tab-disabled\", ctx.disabled)(\"mat-tab-label-active\", ctx.active);\n            }\n        }, inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\", tabIndex: \"tabIndex\" }, exportAs: [\"matTabLink\"], features: [core[\"Ab\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatTabLink;\n})();\nlet tabs_MatTabsModule = /*@__PURE__*/ (() => {\n    class MatTabsModule {\n    }\n    MatTabsModule.ɵmod = /*@__PURE__*/ core[\"Ob\" /* ɵɵdefineNgModule */]({ type: MatTabsModule });\n    MatTabsModule.ɵinj = /*@__PURE__*/ core[\"Nb\" /* ɵɵdefineInjector */]({ factory: function MatTabsModule_Factory(t) { return new (t || MatTabsModule)(); }, imports: [[\n                common[\"c\" /* CommonModule */],\n                fesm2015_core[\"j\" /* MatCommonModule */],\n                portal[\"f\" /* PortalModule */],\n                fesm2015_core[\"r\" /* MatRippleModule */],\n                observers[\"c\" /* ObserversModule */],\n                a11y[\"a\" /* A11yModule */],\n            ], fesm2015_core[\"j\" /* MatCommonModule */]] });\n    return MatTabsModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Cc\" /* ɵɵsetNgModuleScope */](tabs_MatTabsModule, { declarations: function () { return [tabs_MatTabGroup, tabs_MatTabLabel, tabs_MatTab, tabs_MatInkBar, tabs_MatTabLabelWrapper, tabs_MatTabNav, tabs_MatTabLink, tabs_MatTabBody, tabs_MatTabBodyPortal, tabs_MatTabHeader, tabs_MatTabContent]; }, imports: function () {\n            return [common[\"c\" /* CommonModule */],\n                fesm2015_core[\"j\" /* MatCommonModule */],\n                portal[\"f\" /* PortalModule */],\n                fesm2015_core[\"r\" /* MatRippleModule */],\n                observers[\"c\" /* ObserversModule */],\n                a11y[\"a\" /* A11yModule */]];\n        }, exports: function () { return [fesm2015_core[\"j\" /* MatCommonModule */], tabs_MatTabGroup, tabs_MatTabLabel, tabs_MatTab, tabs_MatTabNav, tabs_MatTabLink, tabs_MatTabContent]; } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=tabs.js.map\n\n// EXTERNAL MODULE: ./content/src/index.ts + 1 modules\nvar src = __webpack_require__(\"g7MM\");\n\n// EXTERNAL MODULE: ./connect/src/lib/functions/client/index.ts + 3 modules\nvar client = __webpack_require__(\"kSUX\");\n\n// EXTERNAL MODULE: ./content/src/lib/streamer/content.directive.ts\nvar content_directive = __webpack_require__(\"Qfjl\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/flex-layout/esm2015/flex.js\nvar flex = __webpack_require__(\"VDRc\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/fesm2015/router.js + 1 modules\nvar router = __webpack_require__(\"iInd\");\n\n// CONCATENATED MODULE: ./wizdm/src/app/pages/admin/admin.component.ts\n\n\n\n\n\n\nfunction AdminComponent_ng_container_0_a_4_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Wb\" /* ɵɵelementStart */](0, \"a\", 4, 5);\n        core[\"Ic\" /* ɵɵtext */](2);\n        core[\"Vb\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const item_r3 = ctx.$implicit;\n        const _r4 = core[\"vc\" /* ɵɵreference */](1);\n        core[\"pc\" /* ɵɵproperty */](\"routerLink\", item_r3.link)(\"active\", _r4.isActive);\n        core[\"Db\" /* ɵɵadvance */](2);\n        core[\"Jc\" /* ɵɵtextInterpolate */](item_r3.label);\n    }\n}\nfunction AdminComponent_ng_container_0_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Ub\" /* ɵɵelementContainerStart */](0);\n        core[\"Wb\" /* ɵɵelementStart */](1, \"h2\");\n        core[\"Ic\" /* ɵɵtext */](2);\n        core[\"Vb\" /* ɵɵelementEnd */]();\n        core[\"Wb\" /* ɵɵelementStart */](3, \"nav\", 2);\n        core[\"Gc\" /* ɵɵtemplate */](4, AdminComponent_ng_container_0_a_4_Template, 3, 3, \"a\", 3);\n        core[\"Vb\" /* ɵɵelementEnd */]();\n        core[\"Tb\" /* ɵɵelementContainerEnd */]();\n    }\n    if (rf & 2) {\n        const msgs_r1 = ctx.$implicit;\n        core[\"Db\" /* ɵɵadvance */](2);\n        core[\"Jc\" /* ɵɵtextInterpolate */](msgs_r1.title || \"Admin tools\");\n        core[\"Db\" /* ɵɵadvance */](2);\n        core[\"pc\" /* ɵɵproperty */](\"ngForOf\", msgs_r1.menu);\n    }\n}\nlet admin_component_AdminComponent = /*@__PURE__*/ (() => {\n    class AdminComponent {\n    }\n    AdminComponent.ɵfac = function AdminComponent_Factory(t) { return new (t || AdminComponent)(); };\n    AdminComponent.ɵcmp = core[\"Kb\" /* ɵɵdefineComponent */]({ type: AdminComponent, selectors: [[\"wm-admin\"]], decls: 3, vars: 1, consts: [[4, \"wmContent\", \"wmContentSelect\"], [\"fxFlex\", \"1 1 auto\"], [\"mat-tab-nav-bar\", \"\"], [\"mat-tab-link\", \"\", \"routerLinkActive\", \"\", 3, \"routerLink\", \"active\", 4, \"ngFor\", \"ngForOf\"], [\"mat-tab-link\", \"\", \"routerLinkActive\", \"\", 3, \"routerLink\", \"active\"], [\"rla\", \"routerLinkActive\"]], template: function AdminComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Gc\" /* ɵɵtemplate */](0, AdminComponent_ng_container_0_Template, 5, 2, \"ng-container\", 0);\n                core[\"Wb\" /* ɵɵelementStart */](1, \"div\", 1);\n                core[\"Rb\" /* ɵɵelement */](2, \"router-outlet\");\n                core[\"Vb\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"pc\" /* ɵɵproperty */](\"wmContentSelect\", \"admin\");\n            }\n        }, directives: [content_directive[\"a\" /* ContentDirective */], flex[\"b\" /* DefaultFlexDirective */], router[\"l\" /* RouterOutlet */], tabs_MatTabNav, common[\"l\" /* NgForOf */], router[\"j\" /* RouterLinkWithHref */], tabs_MatTabLink, router[\"i\" /* RouterLinkActive */]], styles: [\"[_nghost-%COMP%]{width:100%;position:relative;display:flex;flex-direction:column;padding:32px}\"] });\n    return AdminComponent;\n})();\n\n// EXTERNAL MODULE: ./wizdm/src/app/utils/auth-guard/index.ts + 2 modules\nvar auth_guard = __webpack_require__(\"U9eP\");\n\n// EXTERNAL MODULE: ./wizdm/src/app/utils/admin/index.ts + 1 modules\nvar admin = __webpack_require__(\"1RzK\");\n\n// EXTERNAL MODULE: ./content/src/lib/router/content-router.module.ts\nvar content_router_module = __webpack_require__(\"J3Me\");\n\n// CONCATENATED MODULE: ./wizdm/src/app/pages/admin/admin.module.ts\n\n\n\n\n\n\n\n\n\n\n\n\nconst routes = [{\n        path: '',\n        content: 'admin',\n        component: admin_component_AdminComponent,\n        canActivate: [auth_guard[\"a\" /* AuthGuard */]], data: { authGuardPipe: admin[\"b\" /* isAdmin */] },\n        children: [\n            { path: '', redirectTo: 'access', pathMatch: 'full' },\n            { path: 'access', loadChildren: () => Promise.all(/* import() */[__webpack_require__.e(1), __webpack_require__.e(2), __webpack_require__.e(17)]).then(__webpack_require__.bind(null, \"Ok+D\")).then(m => m.UserAccessModule) },\n            { path: 'fixer', loadChildren: () => Promise.all(/* import() */[__webpack_require__.e(4), __webpack_require__.e(0), __webpack_require__.e(23)]).then(__webpack_require__.bind(null, \"joOy\")).then(m => m.ProfileFixerModule) }\n        ]\n    }];\nlet admin_module_AdminModule = /*@__PURE__*/ (() => {\n    class AdminModule {\n    }\n    AdminModule.ɵmod = core[\"Ob\" /* ɵɵdefineNgModule */]({ type: AdminModule });\n    AdminModule.ɵinj = core[\"Nb\" /* ɵɵdefineInjector */]({ factory: function AdminModule_Factory(t) { return new (t || AdminModule)(); }, imports: [[\n                common[\"c\" /* CommonModule */],\n                flex_layout[\"a\" /* FlexLayoutModule */],\n                icon[\"b\" /* MatIconModule */],\n                fesm2015_button[\"c\" /* MatButtonModule */],\n                tabs_MatTabsModule,\n                client[\"a\" /* ClientModule */],\n                src[\"e\" /* ContentRouterModule */].forChild(routes)\n            ]] });\n    return AdminModule;\n})();\n\n\n/***/ }),\n\n/***/ \"kSUX\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* reexport */ client_service_FunctionsClient; });\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* reexport */ client_module_ClientModule; });\n\n// UNUSED EXPORTS: AuthToken\n\n// EXTERNAL MODULE: ./connect/src/lib/auth/index.ts\nvar auth = __webpack_require__(\"R6uK\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js\nvar take = __webpack_require__(\"IzEk\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js\nvar switchMap = __webpack_require__(\"eIep\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/from.js\nvar from = __webpack_require__(\"Cfvw\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js\nvar of = __webpack_require__(\"LRne\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/fesm2015/core.js\nvar core = __webpack_require__(\"8Y7J\");\n\n// CONCATENATED MODULE: ./connect/src/lib/functions/client/auth-token.service.ts\n\n\n\n\n\n\n/** HTTP interceptor adding the authentication token to all the requests */\nlet auth_token_service_AuthToken = /*@__PURE__*/ (() => {\n    class AuthToken {\n        constructor(auth) {\n            this.auth = auth;\n        }\n        intercept(req, next) {\n            return this.auth.user$.pipe(Object(take[\"a\" /* take */])(1), Object(switchMap[\"a\" /* switchMap */])(user => user ? Object(from[\"a\" /* from */])(user.getIdToken()) : Object(of[\"a\" /* of */])(null)), Object(switchMap[\"a\" /* switchMap */])(token => {\n                if (!token) {\n                    return next.handle(req);\n                }\n                return next.handle(req.clone({ headers: req.headers.set('Authorization', 'Bearer ' + token) }));\n            }));\n        }\n    }\n    AuthToken.ɵfac = function AuthToken_Factory(t) { return new (t || AuthToken)(core[\"ac\" /* ɵɵinject */](auth[\"c\" /* AuthService */])); };\n    AuthToken.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: AuthToken, factory: AuthToken.ɵfac });\n    return AuthToken;\n})();\n\n// EXTERNAL MODULE: ./connect/src/lib/functions/functions.service.ts\nvar functions_service = __webpack_require__(\"Iw12\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/fesm2015/http.js\nvar http = __webpack_require__(\"IheW\");\n\n// CONCATENATED MODULE: ./connect/src/lib/functions/client/client.service.ts\n\n\n\n\n\n/** Http cloud functions API client */\nlet client_service_FunctionsClient = /*@__PURE__*/ (() => {\n    class FunctionsClient {\n        constructor(functions, http) {\n            this.functions = functions;\n            this.http = http;\n        }\n        /** Performs http GET */\n        get(endPoint) {\n            return this.http.get(this.functions.url + endPoint);\n        }\n        /** Performs http POST */\n        post(endPoint, data) {\n            return this.http.post(this.functions.url + endPoint, data);\n        }\n        /** Performs http PATCH */\n        patch(endPoint, data) {\n            return this.http.patch(this.functions.url + endPoint, data);\n        }\n        /** Performs http DELETE */\n        delete(endPoint) {\n            return this.http.delete(this.functions.url + endPoint);\n        }\n    }\n    FunctionsClient.ɵfac = function FunctionsClient_Factory(t) { return new (t || FunctionsClient)(core[\"ac\" /* ɵɵinject */](functions_service[\"a\" /* FunctionsService */]), core[\"ac\" /* ɵɵinject */](http[\"b\" /* HttpClient */])); };\n    FunctionsClient.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: FunctionsClient, factory: FunctionsClient.ɵfac });\n    return FunctionsClient;\n})();\n\n// EXTERNAL MODULE: ./connect/src/lib/functions/functions.module.ts + 1 modules\nvar functions_module = __webpack_require__(\"RZm4\");\n\n// EXTERNAL MODULE: ./connect/src/lib/auth/auth.module.ts + 1 modules\nvar auth_module = __webpack_require__(\"Yfbv\");\n\n// CONCATENATED MODULE: ./connect/src/lib/functions/client/client.module.ts\n\n\n\n\n\n\nlet client_module_ClientModule = /*@__PURE__*/ (() => {\n    class ClientModule {\n    }\n    ClientModule.ɵmod = core[\"Ob\" /* ɵɵdefineNgModule */]({ type: ClientModule });\n    ClientModule.ɵinj = core[\"Nb\" /* ɵɵdefineInjector */]({ factory: function ClientModule_Factory(t) { return new (t || ClientModule)(); }, providers: [\n            // Installs an HttpCLient interceptor to include the auth token along with the client requests\n            { provide: http[\"a\" /* HTTP_INTERCEPTORS */], useClass: auth_token_service_AuthToken, multi: true },\n            // Provides the client service\n            client_service_FunctionsClient\n        ], imports: [[auth_module[\"a\" /* AuthModule */], functions_module[\"a\" /* FunctionsModule */], http[\"c\" /* HttpClientModule */]]] });\n    return ClientModule;\n})();\n\n// CONCATENATED MODULE: ./connect/src/lib/functions/client/index.ts\n\n\n\n\n\n/***/ })\n\n}]);","inputSourceMap":null}