(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["default~dialogs-post-post-dlg-module~pages-chat-chat-module"],{

/***/ "0qK6":
/*!************************************************************!*\
  !*** ./emoji-keyboard/src/lib/emoji-keyboard.component.ts ***!
  \************************************************************/
/*! exports provided: EmojiKeyboardComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmojiKeyboardComponent", function() { return EmojiKeyboardComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "8Y7J");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs/operators */ "kU1M");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "qCKp");
/* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/scrolling */ "7KAL");
/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/coercion */ "8LU1");
/* harmony import */ var _emoji_keys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./emoji-keys */ "vKPu");
/* harmony import */ var _wizdm_rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @wizdm/rxjs */ "j8uH");
/* harmony import */ var _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/flex-layout/flex */ "VDRc");
/* harmony import */ var _angular_material_divider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/material/divider */ "BSbQ");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/common */ "SVse");
/* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/material/button */ "Dxy4");
/* harmony import */ var _angular_material_icon__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/material/icon */ "Tj54");














function EmojiKeyboardComponent_div_1_span_1_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "span", 8);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
} if (rf & 2) {
    const row_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;
    const ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](ctx_r4.labels && ctx_r4.labels[row_r3.id] || row_r3.name);
} }
function EmojiKeyboardComponent_div_1_ng_template_2_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 10);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("mousedown", function EmojiKeyboardComponent_div_1_ng_template_2_button_0_Template_button_mousedown_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r11); const key_r9 = ctx.$implicit; const ctx_r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3); return ctx_r10.press(key_r9); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "span", 11);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
} if (rf & 2) {
    const key_r9 = ctx.$implicit;
    const ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx_r8.disabled);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("mode", ctx_r8.mode)("key", key_r9);
} }
function EmojiKeyboardComponent_div_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, EmojiKeyboardComponent_div_1_ng_template_2_button_0_Template, 2, 3, "button", 9);
} if (rf & 2) {
    const row_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", row_r3);
} }
function EmojiKeyboardComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 5);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, EmojiKeyboardComponent_div_1_span_1_Template, 2, 1, "span", 6);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, EmojiKeyboardComponent_div_1_ng_template_2_Template, 1, 1, "ng-template", null, 7, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
} if (rf & 2) {
    const row_r3 = ctx.$implicit;
    const _r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](3);
    const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("height", ctx_r0.keySize, "px");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", row_r3.id)("ngIfElse", _r5);
} }
function EmojiKeyboardComponent_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 12);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function EmojiKeyboardComponent_button_5_Template_button_click_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r14); const ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](); return ctx_r13.scrollTo("recently_used"); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipe"](1, "async");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "mat-icon");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](3, "schedule");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
} if (rf & 2) {
    const ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("selected", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipeBind1"](1, 3, ctx_r1.currentId$) === "recently_used");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx_r1.disabled);
} }
function EmojiKeyboardComponent_button_6_Template(rf, ctx) { if (rf & 1) {
    const _r17 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "button", 12);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function EmojiKeyboardComponent_button_6_Template_button_click_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r17); const group_r15 = ctx.$implicit; const ctx_r16 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](); return ctx_r16.scrollTo(group_r15.id); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipe"](1, "async");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "mat-icon");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](3);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
} if (rf & 2) {
    const group_r15 = ctx.$implicit;
    const ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("selected", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipeBind1"](1, 4, ctx_r2.currentId$) === group_r15.id);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx_r2.disabled);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](group_r15.icon);
} }
class EmojiKeyboardComponent {
    constructor(emojis, elref, zone) {
        this.emojis = emojis;
        this.favorites$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__["BehaviorSubject"]([]);
        this.keySize = 40;
        /** Mode flag:
        * 'web' renders emoji as images
        * 'native' renders the text as it is relying on the OS native support
        */
        this.mode = 'web';
        this._disabled = false;
        /** Emits the selected emoji */
        this.keyPressed = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        // Rows observable adjusting on window resize to work with virtual scrolling
        this.rows$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["fromEvent"])(window, 'resize').pipe(
        // Makes sure to start with a value
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["startWith"])(null), 
        // Waits for rendering to complete
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["sample"])(zone.onStable), 
        // Computes the number of columns based on the actual width
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(() => Math.floor(elref.nativeElement.scrollWidth / this.keySize)), 
        // Filters for changes
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["distinctUntilChanged"])(), 
        // Combines favorites with all emoji keys
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["switchMap"])(cols => Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["combineLatest"])(
        // Splits the favorites first
        this.favorites$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(favs => {
            // Skips when no favorites
            if (!favs || favs.length <= 0) {
                return [];
            }
            // Returns the group of recently used 
            return [{
                    name: 'Recently used',
                    id: 'recently_used'
                }].concat(this.spliRows(favs, cols));
        })), 
        // Splits the emoji groups
        Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(this.emojis.reduce((out, group) => {
            // Pushes the group first 
            out.push({ name: group.name, id: group.id });
            // Concats the key rows next
            return out.concat(this.spliRows(group.keys, cols));
        }, [])))), 
        // Concatenates the recently Used with groups
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(([recentlyUsed, emojiGroups]) => recentlyUsed.concat(emojiGroups)), 
        // At last, computes the scrolling offset for each group
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["tap"])(rows => this.offsets = this.computeOffsets(rows)));
        // Builds the current group id observable
        this.currentId$ = zone.onStable.pipe(
        // Waits for the rendering to complete
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["take"])(1), 
        // Updates with scrolling
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["switchMap"])(() => this.scroller.elementScrolled()), 
        // Measures the scrolled offset
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(() => this.scroller.measureScrollOffset('top')), 
        // Makes sure to start with 0 offset
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["startWith"])(0), 
        // Detects the group based on the scrolled offset 
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(top => {
            // Computes a reversed array of group ids 
            const ids = Object.keys(this.offsets || {}).reverse();
            // Seeks for the current group id
            return ids.find(key => top >= this.offsets[key]) || 'recently_used';
        }), 
        // Filters for changes
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["distinctUntilChanged"])(), 
        // Runs within the angular's zone
        Object(_wizdm_rxjs__WEBPACK_IMPORTED_MODULE_6__["runInZone"])(zone), 
        // Shares the same observable among subscribers
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["shareReplay"])(1));
    }
    /** The latest favorites */
    get favorites() { return this.favorites$.value; }
    /** Array of favorites emoji for the 'Recenlty used' group */
    set favorites(favs) {
        this.favorites$.next(favs);
    }
    /** Disables the keyboard */
    set disabled(disabled) {
        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__["coerceBooleanProperty"])(disabled);
    }
    get disabled() { return this._disabled; }
    ngDoCheck() {
        //this.scroller?.checkViewportSize();
    }
    /** Splits the given array of emoji keys into chuncks of the proper length */
    spliRows(keys, count) {
        return Array(Math.ceil(keys.length / (count || 1)))
            .fill(0).map((_, i) => keys.slice(i * count, i * count + count));
    }
    /** Computes a map of emoji group offsets */
    computeOffsets(rows) {
        return this.emojis.reduce((map, group) => {
            map[group.id] = this.keySize * rows.findIndex(row => row.id === group.id);
            return map;
        }, {});
    }
    /** Scrolls to the given emoji group */
    scrollTo(id) {
        this.scroller.scrollTo({ top: this.offsets[id] || 0 });
    }
    /** Emits the emoji key */
    press(key) {
        return this.keyPressed.emit(key), false;
    }
}
EmojiKeyboardComponent.ɵfac = function EmojiKeyboardComponent_Factory(t) { return new (t || EmojiKeyboardComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_emoji_keys__WEBPACK_IMPORTED_MODULE_5__["EMOJI_KEYS"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"])); };
EmojiKeyboardComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({ type: EmojiKeyboardComponent, selectors: [["wm-emoji-keyboard"]], viewQuery: function EmojiKeyboardComponent_Query(rf, ctx) { if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_3__["CdkVirtualScrollViewport"], 1);
    } if (rf & 2) {
        let _t;
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.scroller = _t.first);
    } }, hostAttrs: [1, "wm-emoji-keyboard"], inputs: { mode: "mode", favorites: "favorites", labels: "labels", disabled: "disabled" }, outputs: { keyPressed: "keyPressed" }, decls: 7, vars: 6, consts: [["fxFlex", "1 1 auto", 3, "itemSize"], ["fxLayout", "row", "fxLayoutAlign", "start center", 3, "height", 4, "cdkVirtualFor", "cdkVirtualForOf"], ["fxFlex", "0 0 auto", "fxLayout", "row"], ["mat-button", "", "fxFlex", "100", 3, "selected", "disabled", "click", 4, "ngIf"], ["mat-button", "", "fxFlex", "100", 3, "selected", "disabled", "click", 4, "ngFor", "ngForOf"], ["fxLayout", "row", "fxLayoutAlign", "start center"], ["class", "group", 4, "ngIf", "ngIfElse"], ["keys", ""], [1, "group"], ["mat-icon-button", "", 3, "disabled", "mousedown", 4, "ngFor", "ngForOf"], ["mat-icon-button", "", 3, "disabled", "mousedown"], [1, "key"], ["mat-button", "", "fxFlex", "100", 3, "disabled", "click"]], template: function EmojiKeyboardComponent_Template(rf, ctx) { if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "cdk-virtual-scroll-viewport", 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, EmojiKeyboardComponent_div_1_Template, 4, 4, "div", 1);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipe"](2, "async");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](3, "mat-divider");
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](4, "nav", 2);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, EmojiKeyboardComponent_button_5_Template, 4, 5, "button", 3);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](6, EmojiKeyboardComponent_button_6_Template, 4, 6, "button", 4);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
    } if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("itemSize", ctx.keySize);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("cdkVirtualForOf", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpipeBind1"](2, 4, ctx.rows$));
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](4);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", (ctx.favorites == null ? null : ctx.favorites.length) > 0);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.emojis);
    } }, directives: [_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_3__["CdkVirtualScrollViewport"], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_3__["CdkFixedSizeVirtualScroll"], _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_7__["DefaultFlexDirective"], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_3__["CdkVirtualForOf"], _angular_material_divider__WEBPACK_IMPORTED_MODULE_8__["MatDivider"], _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_7__["DefaultLayoutDirective"], _angular_common__WEBPACK_IMPORTED_MODULE_9__["NgIf"], _angular_common__WEBPACK_IMPORTED_MODULE_9__["NgForOf"], _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_7__["DefaultLayoutAlignDirective"], _angular_material_button__WEBPACK_IMPORTED_MODULE_10__["MatButton"], _angular_material_icon__WEBPACK_IMPORTED_MODULE_11__["MatIcon"]], pipes: [_angular_common__WEBPACK_IMPORTED_MODULE_9__["AsyncPipe"]], styles: [".wm-emoji-keyboard {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  min-height: 240px;\n  height: 100%;\n  width: 100%;\n}\n.wm-emoji-keyboard .group {\n  padding: 0 10px;\n}\n.wm-emoji-keyboard .cdk-virtual-scroll-viewport {\n  overflow-x: hidden;\n  scroll-behavior: smooth;\n}\n.wm-emoji-keyboard .mat-button {\n  min-width: 40px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2Vtb2ppLWtleWJvYXJkLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBO0VBQ0Usa0JBQUE7RUFDQSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSxpQkFBQTtFQUNBLFlBQUE7RUFDQSxXQUFBO0FBQUY7QUFFRTtFQUFTLGVBQUE7QUFDWDtBQUNFO0VBQ0Usa0JBQUE7RUFDQSx1QkFBQTtBQUNKO0FBRUU7RUFDRSxlQUFBO0FBQUoiLCJmaWxlIjoiZW1vamkta2V5Ym9hcmQuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyJcbi53bS1lbW9qaS1rZXlib2FyZCB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIG1pbi1oZWlnaHQ6IDI0MHB4O1xuICBoZWlnaHQ6IDEwMCU7XG4gIHdpZHRoOiAxMDAlO1xuXG4gIC5ncm91cCB7IHBhZGRpbmc6IDAgMTBweDsgfVxuXG4gIC5jZGstdmlydHVhbC1zY3JvbGwtdmlld3BvcnQge1xuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgICBzY3JvbGwtYmVoYXZpb3I6IHNtb290aDtcbiAgfVxuXG4gIC5tYXQtYnV0dG9uIHtcbiAgICBtaW4td2lkdGg6IDQwcHg7XG4gIH1cbn0iXX0= */"], encapsulation: 2 });


/***/ }),

/***/ "0zyZ":
/*!***********************************************!*\
  !*** ./wizdm/src/app/utils/textarea/index.ts ***!
  \***********************************************/
/*! exports provided: TextareaNewline, TypeinAdapter, TextareaModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _textarea_newline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./textarea-newline */ "RkJ1");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextareaNewline", function() { return _textarea_newline__WEBPACK_IMPORTED_MODULE_0__["TextareaNewline"]; });

/* harmony import */ var _typein_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typein-adapter */ "8mPa");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TypeinAdapter", function() { return _typein_adapter__WEBPACK_IMPORTED_MODULE_1__["TypeinAdapter"]; });

/* harmony import */ var _textarea_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./textarea.module */ "qM05");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextareaModule", function() { return _textarea_module__WEBPACK_IMPORTED_MODULE_2__["TextareaModule"]; });






/***/ }),

/***/ "8mPa":
/*!**************************************************************!*\
  !*** ./wizdm/src/app/utils/textarea/typein-adapter/index.ts ***!
  \**************************************************************/
/*! exports provided: TypeinAdapter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _typein_adapter_directive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typein-adapter.directive */ "nGdH");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TypeinAdapter", function() { return _typein_adapter_directive__WEBPACK_IMPORTED_MODULE_0__["TypeinAdapter"]; });




/***/ }),

/***/ "H7fF":
/*!******************************************************!*\
  !*** ./emoji/src/lib/input/emoji-input.component.ts ***!
  \******************************************************/
/*! exports provided: EmojiInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmojiInput", function() { return EmojiInput; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "8Y7J");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "qCKp");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ "kU1M");
/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "8LU1");
/* harmony import */ var _wizdm_emoji_text__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wizdm/emoji/text */ "WIkw");
/* harmony import */ var _wizdm_emoji_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wizdm/emoji/utils */ "eyIN");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/common */ "SVse");
/* harmony import */ var _image_emoji_image_directive__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../image/emoji-image.directive */ "RYAK");












function EmojiInput_ng_container_0_img_2_Template(rf, ctx) { if (rf & 1) {
    const _r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "img", 4);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("hit", function EmojiInput_ng_container_0_img_2_Template_img_hit_0_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r6); const segment_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit; const ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](); return ctx_r4.cursorAt(segment_r1, $event); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
} if (rf & 2) {
    const segment_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("wm-emoji", segment_r1.content);
} }
function EmojiInput_ng_container_0_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
} if (rf & 2) {
    const segment_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](segment_r1.content || "\n");
} }
function EmojiInput_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](1, 1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, EmojiInput_ng_container_0_img_2_Template, 1, 1, "img", 2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, EmojiInput_ng_container_0_ng_container_3_Template, 2, 1, "ng-container", 3);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
} if (rf & 2) {
    const segment_r1 = ctx.$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitch", segment_r1.type);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "emoji");
} }
/** @dynamic - tells ngc to ignore the error on type Document generated by strictEmitMetadata: true */
class EmojiInput extends _wizdm_emoji_text__WEBPACK_IMPORTED_MODULE_4__["EmojiText"] {
    constructor(document, elref, zone, utils) {
        super(utils);
        this.document = document;
        this.elref = elref;
        this.zone = zone;
        /** Emits the new text on changes */
        this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.disabled = false;
        this.required = false;
        /** Selects the newline mode.
         * - None: enter does nothig.
         * - Always: enter always inserts a new line.
         * - Shift: enter inserts newline in conjunction with the shift key only */
        this.newline = 'always';
        /** Undo history bouncing time */
        this.historyTime = 1000;
        /** Undo history limits */
        this.historyLimit = 128;
        /********** HISTORY UNDO/REDO ***********/
        this.store$ = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
    }
    /** True whenever the curernt selection is collapsed in a cursor */
    get collapsed() { return this.start === this.end; }
    /** Input's HTMLElement */
    get element() { return this.elref.nativeElement; }
    /** The Document's Selection object */
    get selection() { return this.document.getSelection(); }
    /** The Window object */
    get window() { return this.document.defaultView; }
    /** True whenever the platform is Mac, iPhone or iPad */
    get mac() { return /Mac|^iP/.test(this.window.navigator.platform); }
    /** True whenever this input has focus */
    get focused() { return this.document.activeElement === this.element; }
    /** Sets the focus on the input's element */
    focus() { this.element.focus(); }
    /** Removes focus from the input's element; keystrokes will subsequently go nowhere. */
    blur() { this.element.blur(); }
    // Applies the contentediable attribute unless the input is disabled
    get editable() {
        return this.disabled ? undefined : '';
    }
    // Marks the input as empty supporting displaying/hiding of the placeholder text
    get showPlaceholder() {
        return !this.value;
    }
    /** The input value */
    set value(value) {
        // Avoids unecessary changes
        if (value === this.value) {
            return;
        }
        // Restarts the undo history whenevevr the input value changes.
        this.enableHistory(this.historyTime, this.historyLimit);
        // Compiles the new text and emits the update
        this.compile(this._value = value);
    }
    // Clears the history while leaving 
    ngOnDestroy() { this.clearHistory(); }
    /** Disables the input */
    set disableInput(value) { this.disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value); }
    /** Marks the input as required */
    set requireInput(value) { this.required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value); }
    // Handles beforeinput event
    beforeInput(ev) {
        // Divert the insertion content to the internal implementation
        if (ev.data) {
            this.insert(ev.data);
        }
        // Prevents the default behavior
        return false;
    }
    // Handles keydown event
    keyDown(ev) {
        switch (ev.key) {
            // Reverts navigation to default
            case 'ArrowDown':
            case 'ArrowLeft':
            case 'ArrowRight':
            case 'ArrowUp':
            case 'Tab':
            case 'Home':
            case 'End':
            case 'PageUp':
            case 'PageDown':
                return true;
            // Deletes the current selection
            case 'Delete':
                this.del();
                break;
            // Deletes back
            case 'Backspace':
                this.backspace();
                break;
            // Insert a newline according to the newline input mode
            case 'Enter':
                if (this.newline === 'always' || (this.newline === 'shift' && ev.shiftKey)) {
                    this.insert('\n');
                }
                break;
            // Editing
            default: if (ev.key.length === 1 || this.utils.isEmoji(ev.key)) {
                // Prevents keyboard repeating giving a chance to Mac's press&hold to work
                if (ev.repeat && this.mac) {
                    return false;
                }
                // Intercepts accelerators
                if (ev.metaKey && this.mac || ev.ctrlKey) {
                    return this.keyAccellerators(ev);
                }
                // Inserts new content
                this.insert(ev.key);
            }
        }
        // Prevents default
        return false;
    }
    /** Handles keayboard accellerators */
    keyAccellerators(ev) {
        switch (ev.key) {
            // Ctrl/Cmd Z -> Undo
            case 'z':
            case 'Z':
                // Reverts to Redo whenever shift is pressed on a Mac
                if (ev.shiftKey && this.mac) {
                    return this.redo(), false;
                }
                // Performs thr Undo
                return this.undo(), false;
            // Ctrl/Cmd Y -> Redo 
            case 'y':
            case 'Y':
                // Performs the Redo unless its a Mac
                if (!this.mac) {
                    return this.redo(), false;
                }
        }
        // Reverts to default
        return true;
    }
    // Handles cut event
    editCut(ev) {
        // Reverts the cut request to copy the content first...
        this.editCopy(ev);
        // Deletes the selection
        this.del();
        // Always prevent default
        return false;
    }
    // Handles copy event
    editCopy(ev) {
        // Gets the clipboard object
        const cp = ev.clipboardData || this.window.clipboardData;
        if (!cp) {
            return true;
        }
        // Copies the selected text
        try {
            cp.setData('text', this.query().value.slice(this.start, this.end));
        }
        catch (e) { /*console.error(e);*/ }
        // Prevents default
        return false;
    }
    // Handles paste event
    editPaste(ev) {
        // Gets the clipboard object
        const cp = (ev.clipboardData || window.clipboardData);
        if (!cp) {
            return false;
        }
        // Pastes the data from the clipboard
        try {
            this.insert(cp.getData('text'));
        }
        catch (e) { /*console.error(e);*/ }
        // Prevents default
        return false;
    }
    /** Compiles the input text into segment accounting for multiple lines */
    compile(source) {
        // Appends an extra '\n' forcing the browser displaying a new line normally omitted when at the end
        return super.compile(source + (source && source.endsWith('\n') ? '\n' : ''));
    }
    /** Wait for the current queue of microtaks to be emptied. The async funtion will than be called after the rendering completed */
    whenDone(async) {
        this.zone.onStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["take"])(1)).subscribe(() => async());
    }
    /** Selects the text between start and end when specified.
     * Sets the cursor position otherwise */
    select(start, end) {
        this.start = Math.max(start, 0);
        this.end = Math.min(end || this.start, this.value.length);
        return this.sort().apply();
    }
    /** Insert a new text at the current cursor position */
    insert(key) {
        // Skips empty insertions when unfruitful
        if (!key && this.collapsed) {
            return this;
        }
        // Stores the current values in history
        return this.query().store().ins(key);
    }
    /** Deletes the current selection (Del-like) */
    del() {
        // Stores the current values in history
        this.query().store();
        // Whenevevr collapsed...
        if (this.collapsed) {
            // Skips when at the end of the text
            if (this.end === this.value.length) {
                return;
            }
            // Moves the end side of the selection ahead otherwise
            this.end = this.next(this.end);
        }
        // Removes the selected text
        return this.ins('');
    }
    /** Deletes the previous character (Backspace-like) */
    backspace() {
        // Stores the current values in history
        this.query().store();
        // Whenevevr collapsed...
        if (this.collapsed) {
            // Skips when at the start of the text
            if (this.start <= 0) {
                return;
            }
            // Moves the start side of the selection back otherwise
            this.start = this.prev(this.start);
        }
        // Deletes the selected block 
        return this.ins('');
    }
    /** Internal insertion/deletion helper */
    ins(key) {
        // Computes the new text value
        const text = this.value.slice(0, this.start) + key + this.value.slice(this.end);
        // Computes the new cursor location
        const caret = this.start + key.length;
        // Updates the content
        return this.update(text, caret, caret);
    }
    /** Updates the value of the text and selection  */
    update(value, start, end) {
        // Restores the selection
        this.start = start;
        this.end = end;
        // Restores the content
        this.compile(this._value = value);
        // Applies the selection back when rendering is done
        this.focused && this.whenDone(() => this.apply());
        // Emits the ne value
        this.valueChange.emit(this.value);
        // Returns this for chaining purposes
        return this;
    }
    /** Moves the given selection index ahead by one character */
    next(pos) {
        // Moving ahead requires to jump one or more character depending on the letngh of the emoji, if any.
        // So, search for a match with an emoij, first
        const match = this.utils.matchEmojiCodes(this.value.slice(pos));
        // Updates the position accordingly
        return pos + ((match && match.index === 0) ? match[0].length : 1);
    }
    /** Moves the given selection index back by one character */
    prev(pos) {
        // Moving the cursor backwards is performed by moving forward from index 0 up until one step before the starting position.
        // This accounts for the variable length of emoji(s) that can't be successfully matched backwards
        let offset = 0;
        let next = 0;
        while ((next = this.next(next)) < pos) {
            offset = next;
        }
        return offset;
    }
    /** Sorts the selection edges */
    sort() {
        if (this.start <= this.end) {
            return this;
        }
        const tmp = this.start;
        this.start = this.end;
        this.end = tmp;
        return this;
    }
    /** Queries the current selection */
    query() {
        try {
            // Gets the current document selection first
            const sel = this.selection;
            // Computes the start offset from the anchor node
            this.start = this.offset(sel.anchorNode, sel.anchorOffset);
            // Computes the end offset from the focus node
            this.end = sel.isCollapsed ? this.start : this.offset(sel.focusNode, sel.focusOffset);
        }
        catch (e) {
            this.start = this.end = 0; /*console.error(e);*/
        }
        // Sorts the edges and returns this for chaining purposes
        return this.sort();
    }
    /** Applies the current selection back to the dom */
    apply() {
        try {
            // Gets the current document selection first
            const sel = this.selection;
            // Computes the dom node/offset selection pair for the start offset only
            const [node, offset] = this.range(this.start);
            // Applies the selection as a collapsed cursor
            sel.collapse(node, offset);
            // Check for the seleciton to be applied correctly...
            if (sel.anchorNode !== node || sel.anchorOffset !== offset) {
                // ...otherwise schedule a second attempt during the next animation frame update to cope with
                // browsers (Safari) requiring the dome to be actually rendered for the selection to work
                rxjs__WEBPACK_IMPORTED_MODULE_1__["animationFrameScheduler"].schedule(() => this.apply());
            }
        }
        catch (e) { /*console.error(e);*/ }
        // Returns this for chaining purposes
        return this;
    }
    /** Forces the cursor position to fall right before or after the emoji image the user clicked onto */
    cursorAt(segment, at) {
        // Updates the current cursor position based on the emoji image the user clicked onto
        this.start = this.end = this.abs(segment, at === 'right' ? segment.content.length : 0);
        this.selection.collapse(...this.range(this.start));
    }
    /** Selection helper function: Computes the absolute offset from the given segment and relative offset */
    abs(segment, offset = 0) {
        // Skips invalid segments
        if (!segment) {
            return 0;
        }
        // Loops on all the segments
        for (let seg of this.segments) {
            // Stops when the requested segment matches
            if (segment === seg) {
                break;
            }
            // Accumulates the offset by the segment's content length
            offset += (seg.content || '').length;
        }
        // Returns the accumulated offset
        return offset;
    }
    /** Computes the absolute text offset from the Node/offset dom selection pair */
    offset(node, offset) {
        var _a, _b;
        // Short-circuits for invalid nodes
        if (!node) {
            return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.length) || 0;
        }
        // Case #1: The given node is a text node, meaning the dom selection is expressed as the text-node and the relative offset whithin such text. We keep the pair unchanged and move forward.
        if (node.nodeType !== Node.TEXT_NODE) {
            // Cases #2: The given node isn't a text node (likely is the host container element), meaning the dom selection is expressed as the containing node while the offseet is the index of the selected element.
            // Ensures the given node has chilldren
            const count = node.childNodes.length;
            if (!count) {
                return 0;
            }
            // Gets the selected child node (saturating to the last child) and resets the offset for the furtner calculations
            node = node.childNodes.item(Math.min(offset, count - 1));
            offset = 0;
        }
        // Loops on the nodes composing the rendered output
        let child = this.element.firstChild;
        let text = '';
        while (child) {
            // When we match the requested node, we are done. The offset is calculated as the accumulated text length.
            if (child == node) {
                return text.length + offset;
            }
            // Appends the text content depending on the node type
            text += this.nodeText(child);
            // Skips to the next node
            child = child.nextSibling;
        }
        return ((_b = this.value) === null || _b === void 0 ? void 0 : _b.length) || 0;
    }
    /** Computes a Node/offset dom selection pair from an absolute offset */
    range(offset) {
        // Starts with the first child node of the input's element
        let node = this.element.firstChild;
        // Seeks for the relevan node matching the index
        let count = 0;
        while (node) {
            // Gets the node text content, if any 
            const text = this.nodeText(node);
            // When the offset fits within the node we are done
            if (offset <= text.length) {
                // Case #1: When the matching node is a text node...
                if (node.nodeType === Node.TEXT_NODE) {
                    // Returns the text node kind of selection with the content based offset
                    return [node, offset];
                }
                // Case #2: We must be at the IMG, so, return the element offset instead
                return [this.element, count + 1];
            }
            // Decreses the absolute offset
            offset -= text.length;
            // Counts the number of child nodes otherwise (including comments)
            count++;
            // Goes to the next sibling
            node = node.nextSibling;
        }
        // Case #3: No matches found, return a zero based offset
        return [this.element, 0];
    }
    /** Returns the text associated with the given node */
    nodeText(node) {
        switch (node.nodeType) {
            // The value of the tetxt node
            case Node.TEXT_NODE:
                return node.nodeValue;
                break;
            // The alt of an image element
            case Node.ELEMENT_NODE:
                switch (node.tagName) {
                    case 'IMG':
                        return node.alt || '';
                        break;
                }
        }
        return '';
    }
    /** Clears the history buffer */
    clearHistory() {
        // Unsubscribe the previous subscription, if any
        if (!!this.sub$) {
            this.sub$.unsubscribe();
        }
        // Initializes the history buffer
        this.timeIndex = 0;
        this.history = [];
        return this;
    }
    /** Initilizes the history buffer */
    enableHistory(debounce = 1000, limit = 128) {
        // Clears the history buffer
        this.clearHistory();
        // Builts up the stream optimizing the amout of snapshot saved in the history 
        this.sub$ = this.store$.pipe(
        // Append a time interval between storing emissions
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["timeInterval"])(), 
        // Filters requests coming too fast (within 'debounce time')
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["filter"])(payload => this.history.length === 0 || payload.interval > debounce), 
        // Gets a snapshot of the value with updated selection
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["map"])(payload => payload.value)).subscribe(snapshot => {
            // Wipes the further future undoed snapshots since they are now 
            if (this.timeIndex > 0) {
                // Save the last snapshot wiping the further future undoed once
                this.history.splice(0, this.timeIndex + 1, snapshot);
                // Resets the time index
                this.timeIndex = 0;
            }
            // Saves the last snapshot in the history
            else {
                this.history.unshift(snapshot);
            }
            // Removes the oldest snapshot when exceeeding the history limit
            if (this.history.length > limit) {
                this.history.pop();
            }
        });
        return this;
    }
    /** Stores a snapshot in the undo/redo history buffer
     * @param force (option) when true forces the storage unconditionally.
     * Storage will be performed conditionally to the time elapsed since
     * the last modification otherwise.
    */
    store(force) {
        if (!!force) {
            // Pushes a snapshot into the history buffer unconditionally
            this.history.unshift({ value: this.value, selection: [this.start, this.end] });
            return this;
        }
        // Pushes the document for conditional history save
        this.store$.next({ value: this.value, selection: [this.start, this.end] });
        return this;
    }
    /** Returns true whenever the last modifications can be undone */
    get undoable() { return this.history.length > 0 && this.timeIndex < this.history.length - (!!this.timeIndex ? 1 : 0); }
    /** Undoes the latest changes. It requires enableHistory() to be called */
    undo() {
        // Stops undoing when history is finished
        if (!this.undoable) {
            return this;
        }
        // Saves the present moment to be restored eventually
        if (this.timeIndex === 0) {
            this.store(true);
        }
        // Gets the latest snapshot from the history
        const snapshot = this.history[++this.timeIndex];
        // Reloads the snapshot's content restoring the selection too
        return this.update(snapshot.value, ...snapshot.selection);
    }
    /** Returns true whenever the last undone modifications can be redone */
    get redoable() { return this.history.length > 0 && this.timeIndex > 0; }
    /** Redoes the last undone modifications. It requires enableHistory() to be called */
    redo() {
        // Stops redoing when back to the present
        if (!this.redoable) {
            return this;
        }
        // Gets the previous snapshot from the history
        const snapshot = this.history[--this.timeIndex];
        // Removes the newest snapshot when back to the present
        if (this.timeIndex === 0) {
            this.history.shift();
        }
        // Reloads the snapshot's content restoring the selection too
        return this.update(snapshot.value, ...snapshot.selection);
    }
}
EmojiInput.ɵfac = function EmojiInput_Factory(t) { return new (t || EmojiInput)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_6__["DOCUMENT"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_wizdm_emoji_utils__WEBPACK_IMPORTED_MODULE_5__["EmojiUtils"])); };
EmojiInput.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({ type: EmojiInput, selectors: [["wm-emoji-input"]], hostAttrs: [1, "wm-emoji-input"], hostVars: 4, hostBindings: function EmojiInput_HostBindings(rf, ctx) { if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("beforeinput", function EmojiInput_beforeinput_HostBindingHandler($event) { return ctx.beforeInput($event); })("keydown", function EmojiInput_keydown_HostBindingHandler($event) { return ctx.keyDown($event); })("cut", function EmojiInput_cut_HostBindingHandler($event) { return ctx.editCut($event); })("copy", function EmojiInput_copy_HostBindingHandler($event) { return ctx.editCopy($event); })("paste", function EmojiInput_paste_HostBindingHandler($event) { return ctx.editPaste($event); });
    } if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("contenteditable", ctx.editable)("placeholder", ctx.placeholder);
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("empty", ctx.showPlaceholder);
    } }, inputs: { mode: "mode", placeholder: "placeholder", value: "value", disableInput: ["disabled", "disableInput"], requireInput: ["required", "requireInput"], newline: "newline", historyTime: "historyTime", historyLimit: "historyLimit" }, outputs: { valueChange: "valueChange" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]], decls: 1, vars: 2, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngSwitch"], ["draggable", "false", 3, "wm-emoji", "hit", 4, "ngSwitchCase"], [4, "ngSwitchDefault"], ["draggable", "false", 3, "wm-emoji", "hit"]], template: function EmojiInput_Template(rf, ctx) { if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, EmojiInput_ng_container_0_Template, 4, 2, "ng-container", 0);
    } if (rf & 2) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.segments)("ngForTrackBy", ctx.trackByFn);
    } }, directives: [_angular_common__WEBPACK_IMPORTED_MODULE_6__["NgForOf"], _angular_common__WEBPACK_IMPORTED_MODULE_6__["NgSwitch"], _angular_common__WEBPACK_IMPORTED_MODULE_6__["NgSwitchCase"], _angular_common__WEBPACK_IMPORTED_MODULE_6__["NgSwitchDefault"], _image_emoji_image_directive__WEBPACK_IMPORTED_MODULE_7__["EmojiImage"]], styles: [".wm-emoji-input {\n  display: inline-block;\n  white-space: pre-wrap;\n  min-height: 1em;\n  outline: none;\n}\n.wm-emoji-input::before {\n  content: attr(placeholder);\n  position: absolute;\n  opacity: 0.5;\n  visibility: hidden;\n}\n.wm-emoji-input.empty::before {\n  visibility: visible;\n}\n.mat-form-field .wm-emoji-input::before {\n  transition: opacity 150ms ease 200ms;\n}\n.mat-form-field.mat-form-field-hide-placeholder .wm-emoji-input::before {\n  transition: unset;\n  opacity: 0;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2Vtb2ppLWlucHV0LmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBO0VBRUUscUJBQUE7RUFDQSxxQkFBQTtFQUNBLGVBQUE7RUFDQSxhQUFBO0FBREY7QUFJRTtFQUVFLDBCQUFBO0VBQ0Esa0JBQUE7RUFDQSxZQUFBO0VBR0Esa0JBQUE7QUFMSjtBQVNFO0VBQ0UsbUJBQUE7QUFQSjtBQWVFO0VBQ0Usb0NBQUE7QUFaSjtBQWdCRTtFQUNFLGlCQUFBO0VBQ0EsVUFBQTtBQWRKIiwiZmlsZSI6ImVtb2ppLWlucHV0LmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiXG4ud20tZW1vamktaW5wdXQge1xuXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICBtaW4taGVpZ2h0OiAxZW07XG4gIG91dGxpbmU6IG5vbmU7XG5cbiAgLy8gVXNlcyA6OmJlZm9yZSBtZXRhLWVsZW1lbnQgdG8gc2ltdWxhdGUgdGhlIHBsYWNlaG9kZXJcbiAgJjo6YmVmb3JlIHtcbiAgICAvLyBDb250ZW50cyBjb21lcyBmcm9tIHRoZSBwbGFjZWhvZGVyIGF0dHJpYnV0ZVxuICAgIGNvbnRlbnQ6IGF0dHIocGxhY2Vob2xkZXIpOyBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgb3BhY2l0eTogMC41O1xuXG4gICAgLy8gVGhlIHBsYWNlaG9sZGVyIGlzIG5vcm1hbGx5IGhpZGRlblxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxuXG4gIC8vIERpc3BsYXlzIHRoZSBwbGFjZWhvbGRlciB3aGVuIGVtcHR5XG4gICYuZW1wdHk6OmJlZm9yZSB7XG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcbiAgfVxufVxuXG4vLyBUaGlzIGlzIHByb3ZpZGVkIHRvIHN1cHBvcnQgc3R5bGluZyBmb3IgbWF0RW1vamkgZGlyZWN0aXZlIHNpbmNlIHRoZSBkaXJlY3RpdmUgY2FuJ3QgaGF2ZSBzdHlsZXMgb2YgaXRzIG93bi4gXG4ubWF0LWZvcm0tZmllbGQge1xuXG4gIC8vIEFkZHMgdHJhbnN0aW9uIHRpbWluaWcgb24gb3BhY2l0eSB0byBjb3BlIHdpdGggdGhlIGZsb2F0aW5nIGxhYmVsXG4gIC53bS1lbW9qaS1pbnB1dDo6YmVmb3JlIHtcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDE1MG1zIGVhc2UgMjAwbXM7XG4gIH1cblxuICAvLyBIaWRlcyB0aGUgcGxhY2Vob2xkZXIgaW1tZWRpYXRlbHlcbiAgJi5tYXQtZm9ybS1maWVsZC1oaWRlLXBsYWNlaG9sZGVyIC53bS1lbW9qaS1pbnB1dDo6YmVmb3JlIHtcbiAgICB0cmFuc2l0aW9uOiB1bnNldDtcbiAgICBvcGFjaXR5OiAwO1xuICB9XG59Il19 */"], encapsulation: 2 });


/***/ }),

/***/ "KRLS":
/*!*****************************************!*\
  !*** ./emoji/src/lib/material/index.ts ***!
  \*****************************************/
/*! exports provided: EmojiMaterial, EmojiMaterialModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _emoji_material_directive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./emoji-material.directive */ "XtK9");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EmojiMaterial", function() { return _emoji_material_directive__WEBPACK_IMPORTED_MODULE_0__["EmojiMaterial"]; });

/* harmony import */ var _emoji_material_module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./emoji-material.module */ "omZD");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EmojiMaterialModule", function() { return _emoji_material_module__WEBPACK_IMPORTED_MODULE_1__["EmojiMaterialModule"]; });





/***/ }),

/***/ "RkJ1":
/*!****************************************************************!*\
  !*** ./wizdm/src/app/utils/textarea/textarea-newline/index.ts ***!
  \****************************************************************/
/*! exports provided: TextareaNewline */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _textarea_newline_directive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./textarea-newline.directive */ "gX7t");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextareaNewline", function() { return _textarea_newline_directive__WEBPACK_IMPORTED_MODULE_0__["TextareaNewline"]; });




/***/ }),

/***/ "TDrZ":
/*!***************************************************!*\
  !*** ./emoji/src/lib/input/emoji-input.module.ts ***!
  \***************************************************/
/*! exports provided: EmojiInputModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmojiInputModule", function() { return EmojiInputModule; });
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/common */ "SVse");
/* harmony import */ var _wizdm_emoji_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wizdm/emoji/image */ "W6g8");
/* harmony import */ var _emoji_input_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./emoji-input.component */ "H7fF");
/* harmony import */ var _emoji_control_directive__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./emoji-control.directive */ "owKJ");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/core */ "8Y7J");





class EmojiInputModule {
}
EmojiInputModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineNgModule"]({ type: EmojiInputModule });
EmojiInputModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjector"]({ factory: function EmojiInputModule_Factory(t) { return new (t || EmojiInputModule)(); }, imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"], _wizdm_emoji_image__WEBPACK_IMPORTED_MODULE_1__["EmojiImageModule"]]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵsetNgModuleScope"](EmojiInputModule, { declarations: [_emoji_input_component__WEBPACK_IMPORTED_MODULE_2__["EmojiInput"], _emoji_control_directive__WEBPACK_IMPORTED_MODULE_3__["EmojiControl"]], imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"], _wizdm_emoji_image__WEBPACK_IMPORTED_MODULE_1__["EmojiImageModule"]], exports: [_emoji_input_component__WEBPACK_IMPORTED_MODULE_2__["EmojiInput"], _emoji_control_directive__WEBPACK_IMPORTED_MODULE_3__["EmojiControl"]] }); })();


/***/ }),

/***/ "UYqx":
/*!**************************************!*\
  !*** ./emoji/src/lib/input/index.ts ***!
  \**************************************/
/*! exports provided: EmojiControl, EmojiInput, EmojiInputModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _emoji_control_directive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./emoji-control.directive */ "owKJ");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EmojiControl", function() { return _emoji_control_directive__WEBPACK_IMPORTED_MODULE_0__["EmojiControl"]; });

/* harmony import */ var _emoji_input_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./emoji-input.component */ "H7fF");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EmojiInput", function() { return _emoji_input_component__WEBPACK_IMPORTED_MODULE_1__["EmojiInput"]; });

/* harmony import */ var _emoji_input_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./emoji-input.module */ "TDrZ");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EmojiInputModule", function() { return _emoji_input_module__WEBPACK_IMPORTED_MODULE_2__["EmojiInputModule"]; });






/***/ }),

/***/ "XtK9":
/*!************************************************************!*\
  !*** ./emoji/src/lib/material/emoji-material.directive.ts ***!
  \************************************************************/
/*! exports provided: EmojiMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmojiMaterial", function() { return EmojiMaterial; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "8Y7J");
/* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/material/form-field */ "Q2Ze");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "qCKp");
/* harmony import */ var _wizdm_emoji_input__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @wizdm/emoji/input */ "UYqx");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "s7LF");









class EmojiMaterial {
    /** Gets the NgControl for this control or null. */
    constructor(formField, ngControl, input) {
        this.formField = formField;
        this.ngControl = ngControl;
        this.input = input;
        if (!formField) {
            throw new Error("matEmoji directive is ment to be used within a mat-form-field component!");
        }
        this.stateChanges = Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["merge"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["fromEvent"])(this.input.element, 'blur'), this.input.valueChange);
    }
    /** The value of the control. */
    get value() { return this.input.value; }
    ;
    /** The placeholder for this control. */
    get placeholder() { return this.input.placeholder; }
    ;
    /** Whether the control is focused. */
    get focused() { return this.input.focused; }
    /** Whether the control is empty. */
    get empty() { return !this.input.value; }
    /** Whether the control is disabled. */
    get disabled() {
        if (this.ngControl && this.ngControl.disabled !== null) {
            return this.ngControl.disabled;
        }
        return this.input.disabled;
    }
    /** Whether the control is required. */
    get required() { return this.input.required; }
    /** Whether the `MatFormField` label should try to float. */
    get shouldLabelFloat() { return this.focused || !this.empty; }
    /** Whether the control is in an error state. */
    get errorState() { return !!this.ngControl && !!this.ngControl.errors; }
    /** Sets the list of element IDs that currently describe this control. */
    setDescribedByIds(ids) { }
    /** Handles a click on the control's container. */
    onContainerClick(event) {
        this.input.focus();
    }
}
EmojiMaterial.ɵfac = function EmojiMaterial_Factory(t) { return new (t || EmojiMaterial)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_material_form_field__WEBPACK_IMPORTED_MODULE_1__["MatFormField"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_forms__WEBPACK_IMPORTED_MODULE_4__["NgControl"], 10), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_wizdm_emoji_input__WEBPACK_IMPORTED_MODULE_3__["EmojiInput"])); };
EmojiMaterial.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({ type: EmojiMaterial, selectors: [["wm-emoji-input", "matEmoji", ""]], hostAttrs: [1, "mat-input-element"], exportAs: ["EmojiMaterial"], features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([
            { provide: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_1__["MatFormFieldControl"], useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(() => EmojiMaterial) }
        ])] });


/***/ }),

/***/ "gX7t":
/*!*************************************************************************************!*\
  !*** ./wizdm/src/app/utils/textarea/textarea-newline/textarea-newline.directive.ts ***!
  \*************************************************************************************/
/*! exports provided: TextareaNewline */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextareaNewline", function() { return TextareaNewline; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "8Y7J");

class TextareaNewline {
    constructor() {
        /** Selects the newline mode.
         * - None: enter does nothig.
         * - Always: enter always inserts a new line.
         * - Shift: enter inserts newline in conjunction with the shift key only */
        this.newline = 'always';
    }
    /** Intercepts the keydown event to customize the textarea behavior */
    keyDown(ev) {
        // Prevents the default behavior according to the newline input value
        switch (ev.code === 'Enter' ? this.newline : 'always') {
            case 'none':
                return false;
            case 'shift':
                return ev.shiftKey;
        }
        return true;
    }
}
TextareaNewline.ɵfac = function TextareaNewline_Factory(t) { return new (t || TextareaNewline)(); };
TextareaNewline.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({ type: TextareaNewline, selectors: [["textarea", "newline", ""]], hostBindings: function TextareaNewline_HostBindings(rf, ctx) { if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("keydown", function TextareaNewline_keydown_HostBindingHandler($event) { return ctx.keyDown($event); });
    } }, inputs: { newline: "newline" } });


/***/ }),

/***/ "glvt":
/*!*************************************!*\
  !*** ./emoji-keyboard/src/index.ts ***!
  \*************************************/
/*! exports provided: EmojiKeyboardComponent, EmojiKeyboardModule, EMOJI_KEYS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_emoji_keyboard_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/emoji-keyboard.component */ "0qK6");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EmojiKeyboardComponent", function() { return _lib_emoji_keyboard_component__WEBPACK_IMPORTED_MODULE_0__["EmojiKeyboardComponent"]; });

/* harmony import */ var _lib_emoji_keyboard_module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/emoji-keyboard.module */ "niQ8");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EmojiKeyboardModule", function() { return _lib_emoji_keyboard_module__WEBPACK_IMPORTED_MODULE_1__["EmojiKeyboardModule"]; });

/* harmony import */ var _lib_emoji_keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/emoji-keys */ "vKPu");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EMOJI_KEYS", function() { return _lib_emoji_keys__WEBPACK_IMPORTED_MODULE_2__["EMOJI_KEYS"]; });






/***/ }),

/***/ "nGdH":
/*!*********************************************************************************!*\
  !*** ./wizdm/src/app/utils/textarea/typein-adapter/typein-adapter.directive.ts ***!
  \*********************************************************************************/
/*! exports provided: TypeinAdapter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypeinAdapter", function() { return TypeinAdapter; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "8Y7J");
/* harmony import */ var _wizdm_emoji_input__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wizdm/emoji/input */ "UYqx");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "SVse");





/** Typing In Adapter for texarea and EmojiInput */
class TypeinAdapter {
    constructor(document, elref, emoji) {
        this.document = document;
        this.elref = elref;
        this.emoji = emoji;
        /** Emits for valua changes */
        this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
    }
    /** The host element */
    get element() { return this.elref.nativeElement; }
    /** The host element as a textarea */
    get textarea() {
        // Assert the element is a texarea
        if (this.element.tagName !== 'TEXTAREA') {
            throw new Error('This element expected to be a textarea!');
        }
        // Return the element as a textarea
        return this.element;
    }
    /** True whenever the element has focus */
    get hasFocus() { return this.element === this.document.activeElement; }
    /** Returns the input value */
    get value() {
        return (this.emoji || this.textarea).value;
    }
    ensureFocus() {
        // Do nothing whenever the elment already has focus
        if (this.hasFocus) {
            return;
        }
        // Focuses the element
        this.element.focus();
        // Moves the selection at the end of the current text
        if (this.emoji) {
            this.emoji.select(this.value.length);
        }
        else {
            this.textarea.selectionStart = this.textarea.selectionEnd = this.value.length;
        }
    }
    // Hooks on the input event (textarea only)
    onInput(ev) {
        // Redirects the textarea oninput event to the valueChange
        this.valueChange.emit(this.textarea.value);
    }
    /** Types the given text in the textarea/emoji-input at the current cursor position */
    typein(key) {
        // Ensure the input has focus
        this.ensureFocus();
        // Redirects the input to the EmojiInput.insert()
        if (this.emoji) {
            this.emoji.insert(key);
        }
        else {
            // Insert the given text into the textarea
            this.textarea.setRangeText(key, this.textarea.selectionStart, this.textarea.selectionEnd, 'end');
            // Force the new value emission since there's no input event triggering
            this.valueChange.emit(this.textarea.value);
        }
    }
}
TypeinAdapter.ɵfac = function TypeinAdapter_Factory(t) { return new (t || TypeinAdapter)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_wizdm_emoji_input__WEBPACK_IMPORTED_MODULE_1__["EmojiInput"], 10)); };
TypeinAdapter.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({ type: TypeinAdapter, selectors: [["textarea", "typein", ""], ["wm-emoji-input", "typein", ""]], hostBindings: function TypeinAdapter_HostBindings(rf, ctx) { if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("input", function TypeinAdapter_input_HostBindingHandler() { return ctx.onInput(ctx.event$); });
    } }, outputs: { valueChange: "valueChange" } });


/***/ }),

/***/ "niQ8":
/*!*********************************************************!*\
  !*** ./emoji-keyboard/src/lib/emoji-keyboard.module.ts ***!
  \*********************************************************/
/*! exports provided: EmojiKeyboardModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmojiKeyboardModule", function() { return EmojiKeyboardModule; });
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/common */ "SVse");
/* harmony import */ var _angular_flex_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/flex-layout */ "u9T3");
/* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/scrolling */ "7KAL");
/* harmony import */ var _angular_material_icon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/icon */ "Tj54");
/* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/button */ "Dxy4");
/* harmony import */ var _angular_material_divider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/divider */ "BSbQ");
/* harmony import */ var _emoji_keyboard_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./emoji-keyboard.component */ "0qK6");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/core */ "8Y7J");








class EmojiKeyboardModule {
}
EmojiKeyboardModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdefineNgModule"]({ type: EmojiKeyboardModule });
EmojiKeyboardModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdefineInjector"]({ factory: function EmojiKeyboardModule_Factory(t) { return new (t || EmojiKeyboardModule)(); }, imports: [[
            _angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"],
            _angular_flex_layout__WEBPACK_IMPORTED_MODULE_1__["FlexLayoutModule"],
            _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_2__["ScrollingModule"],
            _angular_material_icon__WEBPACK_IMPORTED_MODULE_3__["MatIconModule"],
            _angular_material_button__WEBPACK_IMPORTED_MODULE_4__["MatButtonModule"],
            _angular_material_divider__WEBPACK_IMPORTED_MODULE_5__["MatDividerModule"]
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵsetNgModuleScope"](EmojiKeyboardModule, { declarations: [_emoji_keyboard_component__WEBPACK_IMPORTED_MODULE_6__["EmojiKeyboardComponent"]], imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"],
        _angular_flex_layout__WEBPACK_IMPORTED_MODULE_1__["FlexLayoutModule"],
        _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_2__["ScrollingModule"],
        _angular_material_icon__WEBPACK_IMPORTED_MODULE_3__["MatIconModule"],
        _angular_material_button__WEBPACK_IMPORTED_MODULE_4__["MatButtonModule"],
        _angular_material_divider__WEBPACK_IMPORTED_MODULE_5__["MatDividerModule"]], exports: [_emoji_keyboard_component__WEBPACK_IMPORTED_MODULE_6__["EmojiKeyboardComponent"]] }); })();


/***/ }),

/***/ "omZD":
/*!*********************************************************!*\
  !*** ./emoji/src/lib/material/emoji-material.module.ts ***!
  \*********************************************************/
/*! exports provided: EmojiMaterialModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmojiMaterialModule", function() { return EmojiMaterialModule; });
/* harmony import */ var _emoji_material_directive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./emoji-material.directive */ "XtK9");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "8Y7J");


class EmojiMaterialModule {
}
EmojiMaterialModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({ type: EmojiMaterialModule });
EmojiMaterialModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({ factory: function EmojiMaterialModule_Factory(t) { return new (t || EmojiMaterialModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](EmojiMaterialModule, { declarations: [_emoji_material_directive__WEBPACK_IMPORTED_MODULE_0__["EmojiMaterial"]], exports: [_emoji_material_directive__WEBPACK_IMPORTED_MODULE_0__["EmojiMaterial"]] }); })();


/***/ }),

/***/ "owKJ":
/*!********************************************************!*\
  !*** ./emoji/src/lib/input/emoji-control.directive.ts ***!
  \********************************************************/
/*! exports provided: EmojiControl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmojiControl", function() { return EmojiControl; });
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/forms */ "s7LF");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "8Y7J");
/* harmony import */ var _input_emoji_input_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../input/emoji-input.component */ "H7fF");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "qCKp");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "kU1M");







/**
 * Bridges the EmojiInput with the Angular's form API implementing a ControlValueAccessor
 */
class EmojiControl {
    constructor(input) {
        this.input = input;
        this.dispose$ = new rxjs__WEBPACK_IMPORTED_MODULE_3__["Subject"]();
        // Creates an observable from the input's element blur event for further use 
        this.blur$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["fromEvent"])(input.element, 'blur').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["takeUntil"])(this.dispose$));
        // Creates an observable from the input valueChange event for further use 
        this.change$ = input.valueChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["takeUntil"])(this.dispose$));
    }
    /** Called by the forms API to write to the view when programmatic changes from model to view are requested */
    writeValue(value) {
        //if(typeof value === 'string') {
        this.input.value = value;
        //}
    }
    /** Registers a callback function that is called when the control's value changes in the UI */
    registerOnChange(fn) {
        this.change$.subscribe(value => fn(value));
    }
    /** Registers a callback function is called by the forms API on initialization to update the form model on blur. */
    registerOnTouched(fn) {
        this.blur$.subscribe(() => fn());
    }
    /**
     * Function that is called by the forms API when the control status changes to or from 'DISABLED'.
     * Depending on the status, it enables or disables the appropriate DOM element.
     */
    setDisabledState(disabled) {
        this.input.disabled = disabled;
    }
    // Disposes of the observables on destroy
    ngOnDestroy() {
        this.dispose$.next();
        this.dispose$.complete();
    }
}
EmojiControl.ɵfac = function EmojiControl_Factory(t) { return new (t || EmojiControl)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_input_emoji_input_component__WEBPACK_IMPORTED_MODULE_2__["EmojiInput"])); };
EmojiControl.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({ type: EmojiControl, selectors: [["wm-emoji-input", "ngModel", ""], ["wm-emoji-input", "formControl", ""], ["wm-emoji-input", "formControlName", ""]], exportAs: ["EmojiControl"], features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵProvidersFeature"]([
            { provide: _angular_forms__WEBPACK_IMPORTED_MODULE_0__["NG_VALUE_ACCESSOR"], useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(() => EmojiControl), multi: true }
        ])] });


/***/ }),

/***/ "qM05":
/*!*********************************************************!*\
  !*** ./wizdm/src/app/utils/textarea/textarea.module.ts ***!
  \*********************************************************/
/*! exports provided: TextareaModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextareaModule", function() { return TextareaModule; });
/* harmony import */ var _textarea_newline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./textarea-newline */ "RkJ1");
/* harmony import */ var _typein_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typein-adapter */ "8mPa");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ "8Y7J");



class TextareaModule {
}
TextareaModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]({ type: TextareaModule });
TextareaModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjector"]({ factory: function TextareaModule_Factory(t) { return new (t || TextareaModule)(); }, imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵsetNgModuleScope"](TextareaModule, { declarations: [_textarea_newline__WEBPACK_IMPORTED_MODULE_0__["TextareaNewline"], _typein_adapter__WEBPACK_IMPORTED_MODULE_1__["TypeinAdapter"]], exports: [_textarea_newline__WEBPACK_IMPORTED_MODULE_0__["TextareaNewline"], _typein_adapter__WEBPACK_IMPORTED_MODULE_1__["TypeinAdapter"]] }); })();


/***/ }),

/***/ "vKPu":
/*!**********************************************!*\
  !*** ./emoji-keyboard/src/lib/emoji-keys.ts ***!
  \**********************************************/
/*! exports provided: EMOJI_KEYS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMOJI_KEYS", function() { return EMOJI_KEYS; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "8Y7J");

;
const EMOJI_KEYS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('wizdm.emoji.keys', {
    providedIn: 'root',
    factory: () => [
        {
            id: "smileys_and_people",
            name: "Smileys & People",
            icon: "sentiment_satisfied_alt",
            keys: ["😀", "😃", "😄", "😁", "😆", "😅", "🤣", "😂", "🙂", "🙃", "😉", "😊", "😇", "🥰", "😍", "🤩", "😘", "😗", "😚", "😙", "😋", "😛", "😜", "🤪", "😝", "🤑", "🤗", "🤭", "🤫", "🤔", "🤐", "🤨", "😐", "😑", "😶", "😏", "😒", "🙄", "😬", "🤥", "😌", "😔", "😪", "🤤", "😴", "😷", "🤒", "🤕", "🤢", "🤮", "🤧", "🥵", "🥶", "🥴", "😵", "🤯", "🤠", "🥳", "😎", "🤓", "🧐", "😕", "😟", "🙁", "😮", "😯", "😲", "😳", "🥺", "😦", "😧", "😨", "😰", "😥", "😢", "😭", "😱", "😖", "😣", "😞", "😓", "😩", "😫", "🥱", "😤", "😡", "😠", "🤬", "😈", "👿", "💀", "☠️", "💩", "🤡", "👹", "👺", "👻", "👽", "👾", "🤖", "😺", "😸", "😹", "😻", "😼", "😽", "🙀", "😿", "😾", "🙈", "🙉", "🙊", "💋", "💌", "💘", "💝", "💖", "💗", "💓", "💞", "💕", "💟", "❣️", "💔", "❤️", "🧡", "💛", "💚", "💙", "💜", "🤎", "🖤", "🤍", "💯", "💢", "💥", "💫", "💦", "💨", "🕳️", "💣", "💬", "👁️‍🗨️", "🗨️", "🗯️", "💭", "💤", "👋", "🤚", "🖐️", "✋", "🖖", "👌", "🤏", "✌️", "🤞", "🤟", "🤘", "🤙", "👈", "👉", "👆", "🖕", "👇", "☝️", "👍", "👎", "✊", "👊", "🤛", "🤜", "👏", "🙌", "👐", "🤲", "🤝", "🙏", "✍️", "💅", "🤳", "💪", "🦾", "🦿", "🦵", "🦶", "👂", "🦻", "👃", "🧠", "🦷", "🦴", "👀", "👁️", "👅", "👄", "👶", "🧒", "👦", "👧", "🧑", "👱", "👨", "🧔", "👨‍🦰", "👨‍🦱", "👨‍🦳", "👨‍🦲", "👩", "👩‍🦰", "🧑‍🦰", "👩‍🦱", "🧑‍🦱", "👩‍🦳", "🧑‍🦳", "👩‍🦲", "🧑‍🦲", "👱‍♀️", "👱‍♂️", "🧓", "👴", "👵", "🙍", "🙍‍♂️", "🙍‍♀️", "🙎", "🙎‍♂️", "🙎‍♀️", "🙅", "🙅‍♂️", "🙅‍♀️", "🙆", "🙆‍♂️", "🙆‍♀️", "💁", "💁‍♂️", "💁‍♀️", "🙋", "🙋‍♂️", "🙋‍♀️", "🧏", "🧏‍♂️", "🧏‍♀️", "🙇", "🙇‍♂️", "🙇‍♀️", "🤦", "🤦‍♂️", "🤦‍♀️", "🤷", "🤷‍♂️", "🤷‍♀️", "🧑‍⚕️", "👨‍⚕️", "👩‍⚕️", "🧑‍🎓", "👨‍🎓", "👩‍🎓", "🧑‍🏫", "👨‍🏫", "👩‍🏫", "🧑‍⚖️", "👨‍⚖️", "👩‍⚖️", "🧑‍🌾", "👨‍🌾", "👩‍🌾", "🧑‍🍳", "👨‍🍳", "👩‍🍳", "🧑‍🔧", "👨‍🔧", "👩‍🔧", "🧑‍🏭", "👨‍🏭", "👩‍🏭", "🧑‍💼", "👨‍💼", "👩‍💼", "🧑‍🔬", "👨‍🔬", "👩‍🔬", "🧑‍💻", "👨‍💻", "👩‍💻", "🧑‍🎤", "👨‍🎤", "👩‍🎤", "🧑‍🎨", "👨‍🎨", "👩‍🎨", "🧑‍✈️", "👨‍✈️", "👩‍✈️", "🧑‍🚀", "👨‍🚀", "👩‍🚀", "🧑‍🚒", "👨‍🚒", "👩‍🚒", "👮", "👮‍♂️", "👮‍♀️", "🕵️", "🕵️‍♂️", "🕵️‍♀️", "💂", "💂‍♂️", "💂‍♀️", "👷", "👷‍♂️", "👷‍♀️", "🤴", "👸", "👳", "👳‍♂️", "👳‍♀️", "👲", "🧕", "🤵", "👰", "🤰", "🤱", "👼", "🎅", "🤶", "🦸", "🦸‍♂️", "🦸‍♀️", "🦹", "🦹‍♂️", "🦹‍♀️", "🧙", "🧙‍♂️", "🧙‍♀️", "🧚", "🧚‍♂️", "🧚‍♀️", "🧛", "🧛‍♂️", "🧛‍♀️", "🧜", "🧜‍♂️", "🧜‍♀️", "🧝", "🧝‍♂️", "🧝‍♀️", "🧞", "🧞‍♂️", "🧞‍♀️", "🧟", "🧟‍♂️", "🧟‍♀️", "💆", "💆‍♂️", "💆‍♀️", "💇", "💇‍♂️", "💇‍♀️", "🚶", "🚶‍♂️", "🚶‍♀️", "🧍", "🧍‍♂️", "🧍‍♀️", "🧎", "🧎‍♂️", "🧎‍♀️", "🧑‍🦯", "👨‍🦯", "👩‍🦯", "🧑‍🦼", "👨‍🦼", "👩‍🦼", "🧑‍🦽", "👨‍🦽", "👩‍🦽", "🏃", "🏃‍♂️", "🏃‍♀️", "💃", "🕺", "🕴️", "👯", "👯‍♂️", "👯‍♀️", "🧖", "🧖‍♂️", "🧖‍♀️", "🧗", "🧗‍♂️", "🧗‍♀️", "🤺", "🏇", "⛷️", "🏂", "🏌️", "🏌️‍♂️", "🏌️‍♀️", "🏄", "🏄‍♂️", "🏄‍♀️", "🚣", "🚣‍♂️", "🚣‍♀️", "🏊", "🏊‍♂️", "🏊‍♀️", "⛹️", "⛹️‍♂️", "⛹️‍♀️", "🏋️", "🏋️‍♂️", "🏋️‍♀️", "🚴", "🚴‍♂️", "🚴‍♀️", "🚵", "🚵‍♂️", "🚵‍♀️", "🤸", "🤸‍♂️", "🤸‍♀️", "🤼", "🤼‍♂️", "🤼‍♀️", "🤽", "🤽‍♂️", "🤽‍♀️", "🤾", "🤾‍♂️", "🤾‍♀️", "🤹", "🤹‍♂️", "🤹‍♀️", "🧘", "🧘‍♂️", "🧘‍♀️", "🛀", "🛌", "🧑‍🤝‍🧑", "👭", "👫", "👬", "💏", "👩‍❤️‍💋‍👨", "👨‍❤️‍💋‍👨", "👩‍❤️‍💋‍👩", "💑", "👩‍❤️‍👨", "👨‍❤️‍👨", "👩‍❤️‍👩", "👪", "👨‍👩‍👦", "👨‍👩‍👧", "👨‍👩‍👧‍👦", "👨‍👩‍👦‍👦", "👨‍👩‍👧‍👧", "👨‍👨‍👦", "👨‍👨‍👧", "👨‍👨‍👧‍👦", "👨‍👨‍👦‍👦", "👨‍👨‍👧‍👧", "👩‍👩‍👦", "👩‍👩‍👧", "👩‍👩‍👧‍👦", "👩‍👩‍👦‍👦", "👩‍👩‍👧‍👧", "👨‍👦", "👨‍👦‍👦", "👨‍👧", "👨‍👧‍👦", "👨‍👧‍👧", "👩‍👦", "👩‍👦‍👦", "👩‍👧", "👩‍👧‍👦", "👩‍👧‍👧", "🗣️", "👤", "👥", "👣"]
        },
        {
            id: "animals_and_nature",
            name: "Animals & Nature",
            icon: "pets",
            keys: ["🐵", "🐒", "🦍", "🦧", "🐶", "🐕", "🦮", "🐕‍🦺", "🐩", "🐺", "🦊", "🦝", "🐱", "🐈", "🦁", "🐯", "🐅", "🐆", "🐴", "🐎", "🦄", "🦓", "🦌", "🐮", "🐂", "🐃", "🐄", "🐷", "🐖", "🐗", "🐽", "🐏", "🐑", "🐐", "🐪", "🐫", "🦙", "🦒", "🐘", "🦏", "🦛", "🐭", "🐁", "🐀", "🐹", "🐰", "🐇", "🐿️", "🦔", "🦇", "🐻", "🐨", "🐼", "🦥", "🦦", "🦨", "🦘", "🦡", "🐾", "🦃", "🐔", "🐓", "🐣", "🐤", "🐥", "🐦", "🐧", "🕊️", "🦅", "🦆", "🦢", "🦉", "🦩", "🦚", "🦜", "🐸", "🐊", "🐢", "🦎", "🐍", "🐲", "🐉", "🦕", "🦖", "🐳", "🐋", "🐬", "🐟", "🐠", "🐡", "🦈", "🐙", "🐚", "🐌", "🦋", "🐛", "🐜", "🐝", "🐞", "🦗", "🕷️", "🕸️", "🦂", "🦟", "🦠", "💐", "🌸", "💮", "🏵️", "🌹", "🥀", "🌺", "🌻", "🌼", "🌷", "🌱", "🌲", "🌳", "🌴", "🌵", "🌾", "🌿", "☘️", "🍀", "🍁", "🍂", "🍃"]
        },
        {
            id: "food_and_drink",
            name: "Food & Drink",
            icon: "fastfood",
            keys: ["🍇", "🍈", "🍉", "🍊", "🍋", "🍌", "🍍", "🥭", "🍎", "🍏", "🍐", "🍑", "🍒", "🍓", "🥝", "🍅", "🥥", "🥑", "🍆", "🥔", "🥕", "🌽", "🌶️", "🥒", "🥬", "🥦", "🧄", "🧅", "🍄", "🥜", "🌰", "🍞", "🥐", "🥖", "🥨", "🥯", "🥞", "🧇", "🧀", "🍖", "🍗", "🥩", "🥓", "🍔", "🍟", "🍕", "🌭", "🥪", "🌮", "🌯", "🥙", "🧆", "🥚", "🍳", "🥘", "🍲", "🥣", "🥗", "🍿", "🧈", "🧂", "🥫", "🍱", "🍘", "🍙", "🍚", "🍛", "🍜", "🍝", "🍠", "🍢", "🍣", "🍤", "🍥", "🥮", "🍡", "🥟", "🥠", "🥡", "🦀", "🦞", "🦐", "🦑", "🦪", "🍦", "🍧", "🍨", "🍩", "🍪", "🎂", "🍰", "🧁", "🥧", "🍫", "🍬", "🍭", "🍮", "🍯", "🍼", "🥛", "☕", "🍵", "🍶", "🍾", "🍷", "🍸", "🍹", "🍺", "🍻", "🥂", "🥃", "🥤", "🧃", "🧉", "🧊", "🥢", "🍽️", "🍴", "🥄", "🔪", "🏺"]
        },
        {
            id: "travel_and_places",
            name: "Travel & Places",
            icon: "beach_access",
            keys: ["🌍", "🌎", "🌏", "🌐", "🗺️", "🗾", "🧭", "🏔️", "⛰️", "🌋", "🗻", "🏕️", "🏖️", "🏜️", "🏝️", "🏞️", "🏟️", "🏛️", "🏗️", "🧱", "🏘️", "🏚️", "🏠", "🏡", "🏢", "🏣", "🏤", "🏥", "🏦", "🏨", "🏩", "🏪", "🏫", "🏬", "🏭", "🏯", "🏰", "💒", "🗼", "🗽", "⛪", "🕌", "🛕", "🕍", "⛩️", "🕋", "⛲", "⛺", "🌁", "🌃", "🏙️", "🌄", "🌅", "🌆", "🌇", "🌉", "♨️", "🎠", "🎡", "🎢", "💈", "🎪", "🚂", "🚃", "🚄", "🚅", "🚆", "🚇", "🚈", "🚉", "🚊", "🚝", "🚞", "🚋", "🚌", "🚍", "🚎", "🚐", "🚑", "🚒", "🚓", "🚔", "🚕", "🚖", "🚗", "🚘", "🚙", "🚚", "🚛", "🚜", "🏎️", "🏍️", "🛵", "🦽", "🦼", "🛺", "🚲", "🛴", "🛹", "🚏", "🛣️", "🛤️", "🛢️", "⛽", "🚨", "🚥", "🚦", "🛑", "🚧", "⚓", "⛵", "🛶", "🚤", "🛳️", "⛴️", "🛥️", "🚢", "✈️", "🛩️", "🛫", "🛬", "🪂", "💺", "🚁", "🚟", "🚠", "🚡", "🛰️", "🚀", "🛸", "🛎️", "🧳", "⌛", "⏳", "⌚", "⏰", "⏱️", "⏲️", "🕰️", "🕛", "🕧", "🕐", "🕜", "🕑", "🕝", "🕒", "🕞", "🕓", "🕟", "🕔", "🕠", "🕕", "🕡", "🕖", "🕢", "🕗", "🕣", "🕘", "🕤", "🕙", "🕥", "🕚", "🕦", "🌑", "🌒", "🌓", "🌔", "🌕", "🌖", "🌗", "🌘", "🌙", "🌚", "🌛", "🌜", "🌡️", "☀️", "🌝", "🌞", "🪐", "⭐", "🌟", "🌠", "🌌", "☁️", "⛅", "⛈️", "🌤️", "🌥️", "🌦️", "🌧️", "🌨️", "🌩️", "🌪️", "🌫️", "🌬️", "🌀", "🌈", "🌂", "☂️", "☔", "⛱️", "⚡", "❄️", "☃️", "⛄", "☄️", "🔥", "💧", "🌊"]
        },
        {
            id: "activities",
            name: "Activities",
            icon: "emoji_events",
            keys: ["🎃", "🎄", "🎆", "🎇", "🧨", "✨", "🎈", "🎉", "🎊", "🎋", "🎍", "🎎", "🎏", "🎐", "🎑", "🧧", "🎀", "🎁", "🎗️", "🎟️", "🎫", "🎖️", "🏆", "🏅", "🥇", "🥈", "🥉", "⚽", "⚾", "🥎", "🏀", "🏐", "🏈", "🏉", "🎾", "🥏", "🎳", "🏏", "🏑", "🏒", "🥍", "🏓", "🏸", "🥊", "🥋", "🥅", "⛳", "⛸️", "🎣", "🤿", "🎽", "🎿", "🛷", "🥌", "🎯", "🪀", "🪁", "🎱", "🔮", "🧿", "🎮", "🕹️", "🎰", "🎲", "🧩", "🧸", "♠️", "♥️", "♦️", "♣️", "♟️", "🃏", "🀄", "🎴", "🎭", "🖼️", "🎨", "🧵", "🪡", "🧶"]
        },
        {
            id: "objects",
            name: "Objects",
            icon: "emoji_objects",
            keys: ["👓", "🕶️", "🥽", "🥼", "🦺", "👔", "👕", "👖", "🧣", "🧤", "🧥", "🧦", "👗", "👘", "🥻", "🩱", "🩲", "🩳", "👙", "👚", "👛", "👜", "👝", "🛍️", "🎒", "👞", "👟", "🥾", "🥿", "👠", "👡", "🩰", "👢", "👑", "👒", "🎩", "🎓", "🧢", "⛑️", "📿", "💄", "💍", "💎", "🔇", "🔈", "🔉", "🔊", "📢", "📣", "📯", "🔔", "🔕", "🎼", "🎵", "🎶", "🎙️", "🎚️", "🎛️", "🎤", "🎧", "📻", "🎷", "🎸", "🎹", "🎺", "🎻", "🪕", "🥁", "📱", "📲", "☎️", "📞", "📟", "📠", "🔋", "🔌", "💻", "🖥️", "🖨️", "⌨️", "🖱️", "🖲️", "💽", "💾", "💿", "📀", "🧮", "🎥", "🎞️", "📽️", "🎬", "📺", "📷", "📸", "📹", "📼", "🔍", "🔎", "🕯️", "💡", "🔦", "🏮", "🪔", "📔", "📕", "📖", "📗", "📘", "📙", "📚", "📓", "📒", "📃", "📜", "📄", "📰", "🗞️", "📑", "🔖", "🏷️", "💰", "💴", "💵", "💶", "💷", "💸", "💳", "🧾", "💹", "✉️", "📧", "📨", "📩", "📤", "📥", "📦", "📫", "📪", "📬", "📭", "📮", "🗳️", "✏️", "✒️", "🖋️", "🖊️", "🖌️", "🖍️", "📝", "💼", "📁", "📂", "🗂️", "📅", "📆", "🗒️", "🗓️", "📇", "📈", "📉", "📊", "📋", "📌", "📍", "📎", "🖇️", "📏", "📐", "✂️", "🗃️", "🗄️", "🗑️", "🔒", "🔓", "🔏", "🔐", "🔑", "🗝️", "🔨", "🪓", "⛏️", "⚒️", "🛠️", "🗡️", "⚔️", "🔫", "🏹", "🛡️", "🔧", "🔩", "⚙️", "🗜️", "⚖️", "🦯", "🔗", "⛓️", "🧰", "🧲", "⚗️", "🧪", "🧫", "🧬", "🔬", "🔭", "📡", "💉", "🩸", "💊", "🩹", "🩺", "🚪", "🛏️", "🛋️", "🪑", "🚽", "🚿", "🛁", "🪒", "🧴", "🧷", "🧹", "🧺", "🧻", "🧼", "🧽", "🧯", "🛒", "🚬", "⚰️", "⚱️", "🗿"]
        },
        {
            id: "symbols",
            name: "Symbols",
            icon: "emoji_symbols",
            keys: ["🏧", "🚮", "🚰", "♿", "🚹", "🚺", "🚻", "🚼", "🚾", "🛂", "🛃", "🛄", "🛅", "⚠️", "🚸", "⛔", "🚫", "🚳", "🚭", "🚯", "🚱", "🚷", "📵", "🔞", "☢️", "☣️", "⬆️", "↗️", "➡️", "↘️", "⬇️", "↙️", "⬅️", "↖️", "↕️", "↔️", "↩️", "↪️", "⤴️", "⤵️", "🔃", "🔄", "🔙", "🔚", "🔛", "🔜", "🔝", "🛐", "⚛️", "🕉️", "✡️", "☸️", "☯️", "✝️", "☦️", "☪️", "☮️", "🕎", "🔯", "♈", "♉", "♊", "♋", "♌", "♍", "♎", "♏", "♐", "♑", "♒", "♓", "⛎", "🔀", "🔁", "🔂", "▶️", "⏩", "⏭️", "⏯️", "◀️", "⏪", "⏮️", "🔼", "⏫", "🔽", "⏬", "⏸️", "⏹️", "⏺️", "⏏️", "🎦", "🔅", "🔆", "📶", "📳", "📴", "✖️", "➕", "➖", "➗", "♾️", "❓", "❔", "❕", "❗", "〰️", "💱", "💲", "⚕️", "♻️", "⚜️", "🔱", "📛", "🔰", "⭕", "✅", "☑️", "✔️", "❌", "❎", "➰", "➿", "〽️", "✳️", "✴️", "❇️", "#️⃣", "*️⃣", "0️⃣", "1️⃣", "2️⃣", "3️⃣", "4️⃣", "5️⃣", "6️⃣", "7️⃣", "8️⃣", "9️⃣", "🔟", "🔠", "🔡", "🔢", "🔣", "🔤", "🅰️", "🆎", "🅱️", "🆑", "🆒", "🆓", "ℹ️", "🆔", "Ⓜ️", "🆕", "🆖", "🅾️", "🆗", "🅿️", "🆘", "🆙", "🆚", "🈁", "🈂️", "🈷️", "🈶", "🈯", "🉐", "🈹", "🈚", "🈲", "🉑", "🈸", "🈴", "🈳", "㊗️", "㊙️", "🈺", "🈵", "🔴", "🟠", "🟡", "🟢", "🔵", "🟣", "🟤", "⚫", "⚪", "🟥", "🟧", "🟨", "🟩", "🟦", "🟪", "🟫", "⬛", "⬜", "◼️", "◻️", "◾", "◽", "▪️", "▫️", "🔶", "🔷", "🔸", "🔹", "🔺", "🔻", "💠", "🔘", "🔳", "🔲"]
        },
        {
            id: "flags",
            name: "Flags",
            icon: "emoji_flags",
            keys: ["🏁", "🚩", "🎌", "🏴", "🏳️", "🏳️‍🌈", "🏴‍☠️", "🇦🇨", "🇦🇩", "🇦🇪", "🇦🇫", "🇦🇬", "🇦🇮", "🇦🇱", "🇦🇲", "🇦🇴", "🇦🇶", "🇦🇷", "🇦🇸", "🇦🇹", "🇦🇺", "🇦🇼", "🇦🇽", "🇦🇿", "🇧🇦", "🇧🇧", "🇧🇩", "🇧🇪", "🇧🇫", "🇧🇬", "🇧🇭", "🇧🇮", "🇧🇯", "🇧🇱", "🇧🇲", "🇧🇳", "🇧🇴", "🇧🇶", "🇧🇷", "🇧🇸", "🇧🇹", "🇧🇻", "🇧🇼", "🇧🇾", "🇧🇿", "🇨🇦", "🇨🇨", "🇨🇩", "🇨🇫", "🇨🇬", "🇨🇭", "🇨🇮", "🇨🇰", "🇨🇱", "🇨🇲", "🇨🇳", "🇨🇴", "🇨🇵", "🇨🇷", "🇨🇺", "🇨🇻", "🇨🇼", "🇨🇽", "🇨🇾", "🇨🇿", "🇩🇪", "🇩🇬", "🇩🇯", "🇩🇰", "🇩🇲", "🇩🇴", "🇩🇿", "🇪🇦", "🇪🇨", "🇪🇪", "🇪🇬", "🇪🇭", "🇪🇷", "🇪🇸", "🇪🇹", "🇪🇺", "🇫🇮", "🇫🇯", "🇫🇰", "🇫🇲", "🇫🇴", "🇫🇷", "🇬🇦", "🇬🇧", "🇬🇩", "🇬🇪", "🇬🇫", "🇬🇬", "🇬🇭", "🇬🇮", "🇬🇱", "🇬🇲", "🇬🇳", "🇬🇵", "🇬🇶", "🇬🇷", "🇬🇸", "🇬🇹", "🇬🇺", "🇬🇼", "🇬🇾", "🇭🇰", "🇭🇲", "🇭🇳", "🇭🇷", "🇭🇹", "🇭🇺", "🇮🇨", "🇮🇩", "🇮🇪", "🇮🇱", "🇮🇲", "🇮🇳", "🇮🇴", "🇮🇶", "🇮🇷", "🇮🇸", "🇮🇹", "🇯🇪", "🇯🇲", "🇯🇴", "🇯🇵", "🇰🇪", "🇰🇬", "🇰🇭", "🇰🇮", "🇰🇲", "🇰🇳", "🇰🇵", "🇰🇷", "🇰🇼", "🇰🇾", "🇰🇿", "🇱🇦", "🇱🇧", "🇱🇨", "🇱🇮", "🇱🇰", "🇱🇷", "🇱🇸", "🇱🇹", "🇱🇺", "🇱🇻", "🇱🇾", "🇲🇦", "🇲🇨", "🇲🇩", "🇲🇪", "🇲🇫", "🇲🇬", "🇲🇭", "🇲🇰", "🇲🇱", "🇲🇲", "🇲🇳", "🇲🇴", "🇲🇵", "🇲🇶", "🇲🇷", "🇲🇸", "🇲🇹", "🇲🇺", "🇲🇻", "🇲🇼", "🇲🇽", "🇲🇾", "🇲🇿", "🇳🇦", "🇳🇨", "🇳🇪", "🇳🇫", "🇳🇬", "🇳🇮", "🇳🇱", "🇳🇴", "🇳🇵", "🇳🇷", "🇳🇺", "🇳🇿", "🇴🇲", "🇵🇦", "🇵🇪", "🇵🇫", "🇵🇬", "🇵🇭", "🇵🇰", "🇵🇱", "🇵🇲", "🇵🇳", "🇵🇷", "🇵🇸", "🇵🇹", "🇵🇼", "🇵🇾", "🇶🇦", "🇷🇪", "🇷🇴", "🇷🇸", "🇷🇺", "🇷🇼", "🇸🇦", "🇸🇧", "🇸🇨", "🇸🇩", "🇸🇪", "🇸🇬", "🇸🇭", "🇸🇮", "🇸🇯", "🇸🇰", "🇸🇱", "🇸🇲", "🇸🇳", "🇸🇴", "🇸🇷", "🇸🇸", "🇸🇹", "🇸🇻", "🇸🇽", "🇸🇾", "🇸🇿", "🇹🇦", "🇹🇨", "🇹🇩", "🇹🇫", "🇹🇬", "🇹🇭", "🇹🇯", "🇹🇰", "🇹🇱", "🇹🇲", "🇹🇳", "🇹🇴", "🇹🇷", "🇹🇹", "🇹🇻", "🇹🇼", "🇹🇿", "🇺🇦", "🇺🇬", "🇺🇲", "🇺🇳", "🇺🇸", "🇺🇾", "🇺🇿", "🇻🇦", "🇻🇨", "🇻🇪", "🇻🇬", "🇻🇮", "🇻🇳", "🇻🇺", "🇼🇫", "🇼🇸", "🇽🇰", "🇾🇪", "🇾🇹", "🇿🇦", "🇿🇲", "🇿🇼", "🏴󠁧󠁢󠁥󠁮󠁧󠁿", "🏴󠁧󠁢󠁳󠁣󠁴󠁿", "🏴󠁧󠁢󠁷󠁬󠁳󠁿"]
        }
    ]
});


/***/ })

}]);
//# sourceMappingURL=default~dialogs-post-post-dlg-module~pages-chat-chat-module-es2015.js.map