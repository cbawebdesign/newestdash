(function () {
  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  (window["webpackJsonp"] = window["webpackJsonp"] || []).push([["pages-static-static-module"], {
    /***/
    "++Qg":
    /*!**************************************************************!*\
      !*** ./wizdm/src/app/navigator/sidenav/sidenav.directive.ts ***!
      \**************************************************************/

    /*! exports provided: SidenavDirective */

    /***/
    function Qg(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "SidenavDirective", function () {
        return SidenavDirective;
      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! rxjs/operators */
      "kU1M");
      /* harmony import */


      var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/cdk/coercion */
      "8LU1");
      /* harmony import */


      var _navigator_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! ../navigator.component */
      "H41t");
      /* harmony import */


      var _wizdm_teleport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! @wizdm/teleport */
      "EiPp");
      /* harmony import */


      var _angular_router__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! @angular/router */
      "iInd");
      /** Teleports the given content towards the 'sidenav' portal witihn the navigator */


      var SidenavDirective = /*#__PURE__*/function () {
        function SidenavDirective(nav, route, teleport, template) {
          _classCallCheck(this, SidenavDirective);

          this.nav = nav;
          this.route = route;
          this.teleport = teleport;
          this.template = template;
          this.persist = false;
          /** Emits the open/close sidenav panel status */

          this.openedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"](true);
        }
        /** When true persists the open/close status within the route configuration to restore it accordingly */


        _createClass(SidenavDirective, [{
          key: "persistValue",
          set: function set(persist) {
            this.persist = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(persist);
          }
          /** True when the sidenav panel is open */

        }, {
          key: "opened",
          get: function get() {
            return !!this._opened;
          }
          /** opens/closes the sidenav panel */
          ,
          set: function set(open) {
            // Delegates the navigator to open/close the panel
            this.nav.openSidenav(this._opened = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(open));
          } // The active route configuration data

        }, {
          key: "routeData",
          get: function get() {
            // Returns the router config data, if any, or assigns an empty one
            return this.route.routeConfig.data || (this.route.routeConfig.data = {});
          }
          /** Opens the sidenav panel */

        }, {
          key: "open",
          value: function open() {
            this.opened = true;
          }
          /** Closes the sidenav panel */

        }, {
          key: "close",
          value: function close() {
            this.opened = false;
          }
          /** Toggles the sidenav panel */

        }, {
          key: "toggle",
          value: function toggle() {
            this.opened = !this.opened;
          }
        }, {
          key: "ngOnInit",
          value: function ngOnInit() {
            var _this = this;

            // Intercepts the opened status subscribing to the relevant observable
            this.sub = this.nav.sideOpened$.pipe( // Skipping the first emission so for the local status to prevail without getting overriden
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["skip"])(1), // Saves the last status change within the route data whenever persist is set to true
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["tap"])(function (value) {
              return _this.persist && (_this.routeData['sidenav'] = value);
            }) // Emits the output status
            ).subscribe(function (opened) {
              return _this.openedChange.emit(_this._opened = opened);
            }); // Restores the previous status saved within the route configuration

            this.route.data.pipe( // Loads the data once
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["take"])(1), // Pluks the 'sidenav' property
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["pluck"])('sidenav'), // Forces to start closed on small screens
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(function (value) {
              return _this.nav.mobile ? false : value;
            }), // Filters unwanted values
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["filter"])(function (value) {
              return _this.persist && value !== undefined;
            }) // Applies the restored value
            ).subscribe(function (opened) {
              return _this.openedChange.emit(_this._opened = opened);
            }); // Activates the content towards the 'sidenav' portal

            this.teleport.activate('sidenav', this.template, {
              mode: this.mode,
              width: this.width,
              minWidth: this.minWidth,
              maxWidth: this.maxWidth
            });
          }
        }, {
          key: "ngOnChanges",
          value: function ngOnChanges(changes) {
            // Asserts some width related inut changed...
            if (changes.mode || changes.width || changes.minWidth || changes.maxWidth) {
              // ...applies the changes
              this.teleport.activate('sidenav', this.template, {
                mode: this.mode,
                width: this.width,
                minWidth: this.minWidth,
                maxWidth: this.maxWidth
              });
            }
          }
        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            // Unsubscribes from the observable
            this.sub.unsubscribe(); // Clears the content

            this.teleport.clear('sidenav', this.template);
          }
        }]);

        return SidenavDirective;
      }();

      SidenavDirective.ɵfac = function SidenavDirective_Factory(t) {
        return new (t || SidenavDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_navigator_component__WEBPACK_IMPORTED_MODULE_3__["NavigatorComponent"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_router__WEBPACK_IMPORTED_MODULE_5__["ActivatedRoute"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_wizdm_teleport__WEBPACK_IMPORTED_MODULE_4__["TeleportService"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"]));
      };

      SidenavDirective.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: SidenavDirective,
        selectors: [["ng-template", "wmSidenav", ""]],
        inputs: {
          mode: "mode",
          width: "width",
          minWidth: "minWidth",
          maxWidth: "maxWidth",
          persistValue: ["persist", "persistValue"],
          opened: "opened"
        },
        outputs: {
          openedChange: "openedChange"
        },
        exportAs: ["wmSidenav"],
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
      });
      /***/
    },

    /***/
    "+OJB":
    /*!***************************************************!*\
      !*** ./node_modules/vfile/lib/minproc.browser.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function OJB(module, exports, __webpack_require__) {
      "use strict"; // Somewhat based on:
      // <https://github.com/defunctzombie/node-process/blob/master/browser.js>.
      // But I don’t think one tiny line of code can be copyrighted. 😅

      exports.cwd = cwd;

      function cwd() {
        return '/';
      }
      /***/

    },

    /***/
    "/qNp":
    /*!*************************************************************!*\
      !*** ./node_modules/unist-util-stringify-position/index.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function qNp(module, exports, __webpack_require__) {
      "use strict";

      var own = {}.hasOwnProperty;
      module.exports = stringify;

      function stringify(value) {
        // Nothing.
        if (!value || typeof value !== 'object') {
          return '';
        } // Node.


        if (own.call(value, 'position') || own.call(value, 'type')) {
          return position(value.position);
        } // Position.


        if (own.call(value, 'start') || own.call(value, 'end')) {
          return position(value);
        } // Point.


        if (own.call(value, 'line') || own.call(value, 'column')) {
          return point(value);
        } // ?


        return '';
      }

      function point(point) {
        if (!point || typeof point !== 'object') {
          point = {};
        }

        return index(point.line) + ':' + index(point.column);
      }

      function position(pos) {
        if (!pos || typeof pos !== 'object') {
          pos = {};
        }

        return point(pos.start) + '-' + point(pos.end);
      }

      function index(value) {
        return value && typeof value === 'number' ? value : 1;
      }
      /***/

    },

    /***/
    "0lR2":
    /*!***************************************************!*\
      !*** ./node_modules/remark-parse/lib/defaults.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function lR2(module, exports, __webpack_require__) {
      "use strict";

      module.exports = {
        position: true,
        gfm: true,
        commonmark: false,
        pedantic: false,
        blocks: __webpack_require__(
        /*! ./block-elements */
        "Ivzr")
      };
      /***/
    },

    /***/
    "1QJd":
    /*!**************************************************************!*\
      !*** ./wizdm/src/app/utils/size-lock/size-lock.directive.ts ***!
      \**************************************************************/

    /*! exports provided: SizeLockDirective */

    /***/
    function QJd(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "SizeLockDirective", function () {
        return SizeLockDirective;
      });
      /* harmony import */


      var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/cdk/coercion */
      "8LU1");
      /* harmony import */


      var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/cdk/scrolling */
      "7KAL");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");

      var SizeLockDirective = /*#__PURE__*/function () {
        function SizeLockDirective(viewport) {
          _classCallCheck(this, SizeLockDirective);

          this.viewport = viewport;
          this.width = false;
          this.maxWidth = false; //this.viewport.change(0).subscribe( () => console.log('change') );
        }

        _createClass(SizeLockDirective, [{
          key: "widthStyle",
          get: function get() {
            return this.width ? this.viewport.getViewportSize().width : undefined;
          }
        }, {
          key: "lockWidth",
          set: function set(width) {
            this.width = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(width);
          }
        }, {
          key: "maxWidthStyle",
          get: function get() {
            return this.maxWidth ? this.viewport.getViewportSize().width : undefined;
          }
        }, {
          key: "lockMaxWidth",
          set: function set(width) {
            this.maxWidth = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(width);
          }
        }]);

        return SizeLockDirective;
      }();

      SizeLockDirective.ɵfac = function SizeLockDirective_Factory(t) {
        return new (t || SizeLockDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_1__["ViewportRuler"]));
      };

      SizeLockDirective.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineDirective"]({
        type: SizeLockDirective,
        selectors: [["", "lockWidth", ""], ["", "lockMaxWidth", ""]],
        hostVars: 4,
        hostBindings: function SizeLockDirective_HostBindings(rf, ctx) {
          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵstyleProp"]("width", ctx.widthStyle, "px")("max-width", ctx.maxWidthStyle, "px");
          }
        },
        inputs: {
          lockWidth: "lockWidth",
          lockMaxWidth: "lockMaxWidth"
        }
      });
      /***/
    },

    /***/
    "1VtT":
    /*!***************************************!*\
      !*** ./node_modules/unified/index.js ***!
      \***************************************/

    /*! no static exports found */

    /***/
    function VtT(module, exports, __webpack_require__) {
      "use strict";

      var bail = __webpack_require__(
      /*! bail */
      "Gdbo");

      var buffer = __webpack_require__(
      /*! is-buffer */
      "k1+7");

      var extend = __webpack_require__(
      /*! extend */
      "6dBs");

      var plain = __webpack_require__(
      /*! is-plain-obj */
      "NkL+");

      var trough = __webpack_require__(
      /*! trough */
      "xkQk");

      var vfile = __webpack_require__(
      /*! vfile */
      "Esvb"); // Expose a frozen processor.


      module.exports = unified().freeze();
      var slice = [].slice;
      var own = {}.hasOwnProperty; // Process pipeline.

      var pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);

      function pipelineParse(p, ctx) {
        ctx.tree = p.parse(ctx.file);
      }

      function pipelineRun(p, ctx, next) {
        p.run(ctx.tree, ctx.file, done);

        function done(error, tree, file) {
          if (error) {
            next(error);
          } else {
            ctx.tree = tree;
            ctx.file = file;
            next();
          }
        }
      }

      function pipelineStringify(p, ctx) {
        var result = p.stringify(ctx.tree, ctx.file);

        if (result === undefined || result === null) {// Empty.
        } else if (typeof result === 'string' || buffer(result)) {
          ctx.file.contents = result;
        } else {
          ctx.file.result = result;
        }
      } // Function to create the first processor.


      function unified() {
        var attachers = [];
        var transformers = trough();
        var namespace = {};
        var freezeIndex = -1;
        var frozen; // Data management.

        processor.data = data; // Lock.

        processor.freeze = freeze; // Plugins.

        processor.attachers = attachers;
        processor.use = use; // API.

        processor.parse = parse;
        processor.stringify = stringify;
        processor.run = run;
        processor.runSync = runSync;
        processor.process = process;
        processor.processSync = processSync; // Expose.

        return processor; // Create a new processor based on the processor in the current scope.

        function processor() {
          var destination = unified();
          var index = -1;

          while (++index < attachers.length) {
            destination.use.apply(null, attachers[index]);
          }

          destination.data(extend(true, {}, namespace));
          return destination;
        } // Freeze: used to signal a processor that has finished configuration.
        //
        // For example, take unified itself: it’s frozen.
        // Plugins should not be added to it.
        // Rather, it should be extended, by invoking it, before modifying it.
        //
        // In essence, always invoke this when exporting a processor.


        function freeze() {
          var values;
          var transformer;

          if (frozen) {
            return processor;
          }

          while (++freezeIndex < attachers.length) {
            values = attachers[freezeIndex];

            if (values[1] === false) {
              continue;
            }

            if (values[1] === true) {
              values[1] = undefined;
            }

            transformer = values[0].apply(processor, values.slice(1));

            if (typeof transformer === 'function') {
              transformers.use(transformer);
            }
          }

          frozen = true;
          freezeIndex = Infinity;
          return processor;
        } // Data management.
        // Getter / setter for processor-specific informtion.


        function data(key, value) {
          if (typeof key === 'string') {
            // Set `key`.
            if (arguments.length === 2) {
              assertUnfrozen('data', frozen);
              namespace[key] = value;
              return processor;
            } // Get `key`.


            return own.call(namespace, key) && namespace[key] || null;
          } // Set space.


          if (key) {
            assertUnfrozen('data', frozen);
            namespace = key;
            return processor;
          } // Get space.


          return namespace;
        } // Plugin management.
        //
        // Pass it:
        // *   an attacher and options,
        // *   a preset,
        // *   a list of presets, attachers, and arguments (list of attachers and
        //     options).


        function use(value) {
          var settings;
          assertUnfrozen('use', frozen);

          if (value === null || value === undefined) {// Empty.
          } else if (typeof value === 'function') {
            addPlugin.apply(null, arguments);
          } else if (typeof value === 'object') {
            if ('length' in value) {
              addList(value);
            } else {
              addPreset(value);
            }
          } else {
            throw new Error('Expected usable value, not `' + value + '`');
          }

          if (settings) {
            namespace.settings = extend(namespace.settings || {}, settings);
          }

          return processor;

          function addPreset(result) {
            addList(result.plugins);

            if (result.settings) {
              settings = extend(settings || {}, result.settings);
            }
          }

          function add(value) {
            if (typeof value === 'function') {
              addPlugin(value);
            } else if (typeof value === 'object') {
              if ('length' in value) {
                addPlugin.apply(null, value);
              } else {
                addPreset(value);
              }
            } else {
              throw new Error('Expected usable value, not `' + value + '`');
            }
          }

          function addList(plugins) {
            var index = -1;

            if (plugins === null || plugins === undefined) {// Empty.
            } else if (typeof plugins === 'object' && 'length' in plugins) {
              while (++index < plugins.length) {
                add(plugins[index]);
              }
            } else {
              throw new Error('Expected a list of plugins, not `' + plugins + '`');
            }
          }

          function addPlugin(plugin, value) {
            var entry = find(plugin);

            if (entry) {
              if (plain(entry[1]) && plain(value)) {
                value = extend(true, entry[1], value);
              }

              entry[1] = value;
            } else {
              attachers.push(slice.call(arguments));
            }
          }
        }

        function find(plugin) {
          var index = -1;

          while (++index < attachers.length) {
            if (attachers[index][0] === plugin) {
              return attachers[index];
            }
          }
        } // Parse a file (in string or vfile representation) into a unist node using
        // the `Parser` on the processor.


        function parse(doc) {
          var file = vfile(doc);
          var Parser;
          freeze();
          Parser = processor.Parser;
          assertParser('parse', Parser);

          if (newable(Parser, 'parse')) {
            return new Parser(String(file), file).parse();
          }

          return Parser(String(file), file); // eslint-disable-line new-cap
        } // Run transforms on a unist node representation of a file (in string or
        // vfile representation), async.


        function run(node, file, cb) {
          assertNode(node);
          freeze();

          if (!cb && typeof file === 'function') {
            cb = file;
            file = null;
          }

          if (!cb) {
            return new Promise(executor);
          }

          executor(null, cb);

          function executor(resolve, reject) {
            transformers.run(node, vfile(file), done);

            function done(error, tree, file) {
              tree = tree || node;

              if (error) {
                reject(error);
              } else if (resolve) {
                resolve(tree);
              } else {
                cb(null, tree, file);
              }
            }
          }
        } // Run transforms on a unist node representation of a file (in string or
        // vfile representation), sync.


        function runSync(node, file) {
          var result;
          var complete;
          run(node, file, done);
          assertDone('runSync', 'run', complete);
          return result;

          function done(error, tree) {
            complete = true;
            result = tree;
            bail(error);
          }
        } // Stringify a unist node representation of a file (in string or vfile
        // representation) into a string using the `Compiler` on the processor.


        function stringify(node, doc) {
          var file = vfile(doc);
          var Compiler;
          freeze();
          Compiler = processor.Compiler;
          assertCompiler('stringify', Compiler);
          assertNode(node);

          if (newable(Compiler, 'compile')) {
            return new Compiler(node, file).compile();
          }

          return Compiler(node, file); // eslint-disable-line new-cap
        } // Parse a file (in string or vfile representation) into a unist node using
        // the `Parser` on the processor, then run transforms on that node, and
        // compile the resulting node using the `Compiler` on the processor, and
        // store that result on the vfile.


        function process(doc, cb) {
          freeze();
          assertParser('process', processor.Parser);
          assertCompiler('process', processor.Compiler);

          if (!cb) {
            return new Promise(executor);
          }

          executor(null, cb);

          function executor(resolve, reject) {
            var file = vfile(doc);
            pipeline.run(processor, {
              file: file
            }, done);

            function done(error) {
              if (error) {
                reject(error);
              } else if (resolve) {
                resolve(file);
              } else {
                cb(null, file);
              }
            }
          }
        } // Process the given document (in string or vfile representation), sync.


        function processSync(doc) {
          var file;
          var complete;
          freeze();
          assertParser('processSync', processor.Parser);
          assertCompiler('processSync', processor.Compiler);
          file = vfile(doc);
          process(file, done);
          assertDone('processSync', 'process', complete);
          return file;

          function done(error) {
            complete = true;
            bail(error);
          }
        }
      } // Check if `value` is a constructor.


      function newable(value, name) {
        return typeof value === 'function' && value.prototype && ( // A function with keys in its prototype is probably a constructor.
        // Classes’ prototype methods are not enumerable, so we check if some value
        // exists in the prototype.
        keys(value.prototype) || name in value.prototype);
      } // Check if `value` is an object with keys.


      function keys(value) {
        var key;

        for (key in value) {
          return true;
        }

        return false;
      } // Assert a parser is available.


      function assertParser(name, Parser) {
        if (typeof Parser !== 'function') {
          throw new Error('Cannot `' + name + '` without `Parser`');
        }
      } // Assert a compiler is available.


      function assertCompiler(name, Compiler) {
        if (typeof Compiler !== 'function') {
          throw new Error('Cannot `' + name + '` without `Compiler`');
        }
      } // Assert the processor is not frozen.


      function assertUnfrozen(name, frozen) {
        if (frozen) {
          throw new Error('Cannot invoke `' + name + '` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.');
        }
      } // Assert `node` is a unist node.


      function assertNode(node) {
        if (!node || typeof node.type !== 'string') {
          throw new Error('Expected node, got `' + node + '`');
        }
      } // Assert that `complete` is `true`.


      function assertDone(name, asyncName, complete) {
        if (!complete) {
          throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');
        }
      }
      /***/

    },

    /***/
    "1iAE":
    /*!***********************************************!*\
      !*** ./node_modules/is-alphabetical/index.js ***!
      \***********************************************/

    /*! no static exports found */

    /***/
    function iAE(module, exports, __webpack_require__) {
      "use strict";

      module.exports = alphabetical; // Check if the given character code, or the character code at the first
      // character, is alphabetical.

      function alphabetical(character) {
        var code = typeof character === 'string' ? character.charCodeAt(0) : character;
        return code >= 97 && code <= 122 ||
        /* a-z */
        code >= 65 && code <= 90
        /* A-Z */
        ;
      }
      /***/

    },

    /***/
    "2yk8":
    /*!*************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/auto-link.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function yk8(module, exports, __webpack_require__) {
      "use strict";

      var whitespace = __webpack_require__(
      /*! is-whitespace-character */
      "IPAr");

      var decode = __webpack_require__(
      /*! parse-entities */
      "ZWk2");

      var locate = __webpack_require__(
      /*! ../locate/tag */
      "afWh");

      module.exports = autoLink;
      autoLink.locator = locate;
      autoLink.notInLink = true;
      var lessThan = '<';
      var greaterThan = '>';
      var atSign = '@';
      var slash = '/';
      var mailto = 'mailto:';
      var mailtoLength = mailto.length;

      function autoLink(eat, value, silent) {
        var self = this;
        var subvalue = '';
        var length = value.length;
        var index = 0;
        var queue = '';
        var hasAtCharacter = false;
        var link = '';
        var character;
        var now;
        var content;
        var tokenizers;
        var exit;

        if (value.charAt(0) !== lessThan) {
          return;
        }

        index++;
        subvalue = lessThan;

        while (index < length) {
          character = value.charAt(index);

          if (whitespace(character) || character === greaterThan || character === atSign || character === ':' && value.charAt(index + 1) === slash) {
            break;
          }

          queue += character;
          index++;
        }

        if (!queue) {
          return;
        }

        link += queue;
        queue = '';
        character = value.charAt(index);
        link += character;
        index++;

        if (character === atSign) {
          hasAtCharacter = true;
        } else {
          if (character !== ':' || value.charAt(index + 1) !== slash) {
            return;
          }

          link += slash;
          index++;
        }

        while (index < length) {
          character = value.charAt(index);

          if (whitespace(character) || character === greaterThan) {
            break;
          }

          queue += character;
          index++;
        }

        character = value.charAt(index);

        if (!queue || character !== greaterThan) {
          return;
        }
        /* istanbul ignore if - never used (yet) */


        if (silent) {
          return true;
        }

        link += queue;
        content = link;
        subvalue += link + character;
        now = eat.now();
        now.column++;
        now.offset++;

        if (hasAtCharacter) {
          if (link.slice(0, mailtoLength).toLowerCase() === mailto) {
            content = content.slice(mailtoLength);
            now.column += mailtoLength;
            now.offset += mailtoLength;
          } else {
            link = mailto + link;
          }
        } // Temporarily remove all tokenizers except text in autolinks.


        tokenizers = self.inlineTokenizers;
        self.inlineTokenizers = {
          text: tokenizers.text
        };
        exit = self.enterLink();
        content = self.tokenizeInline(content, now);
        self.inlineTokenizers = tokenizers;
        exit();
        return eat(subvalue)({
          type: 'link',
          title: null,
          url: decode(link, {
            nonTerminated: false
          }),
          children: content
        });
      }
      /***/

    },

    /***/
    "3GlI":
    /*!***************************************************!*\
      !*** ./node_modules/trim-trailing-lines/index.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function GlI(module, exports, __webpack_require__) {
      "use strict";

      module.exports = trimTrailingLines; // Remove final newline characters from `value`.

      function trimTrailingLines(value) {
        return String(value).replace(/\n+$/, '');
      }
      /***/

    },

    /***/
    "497W":
    /*!*********************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/break.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function W(module, exports, __webpack_require__) {
      "use strict";

      var locate = __webpack_require__(
      /*! ../locate/break */
      "aTp6");

      module.exports = hardBreak;
      hardBreak.locator = locate;
      var space = ' ';
      var lineFeed = '\n';
      var minBreakLength = 2;

      function hardBreak(eat, value, silent) {
        var length = value.length;
        var index = -1;
        var queue = '';
        var character;

        while (++index < length) {
          character = value.charAt(index);

          if (character === lineFeed) {
            if (index < minBreakLength) {
              return;
            }
            /* istanbul ignore if - never used (yet) */


            if (silent) {
              return true;
            }

            queue += character;
            return eat(queue)({
              type: 'break'
            });
          }

          if (character !== space) {
            return;
          }

          queue += character;
        }
      }
      /***/

    },

    /***/
    "4MqD":
    /*!********************************************!*\
      !*** ./node_modules/state-toggle/index.js ***!
      \********************************************/

    /*! no static exports found */

    /***/
    function MqD(module, exports, __webpack_require__) {
      "use strict";

      module.exports = factory; // Construct a state `toggler`: a function which inverses `property` in context
      // based on its current value.
      // The by `toggler` returned function restores that value.

      function factory(key, state, ctx) {
        return enter;

        function enter() {
          var context = ctx || this;
          var current = context[key];
          context[key] = !state;
          return exit;

          function exit() {
            context[key] = current;
          }
        }
      }
      /***/

    },

    /***/
    "5t69":
    /*!***************************************!*\
      !*** ./node_modules/unherit/index.js ***!
      \***************************************/

    /*! no static exports found */

    /***/
    function t69(module, exports, __webpack_require__) {
      "use strict";

      var xtend = __webpack_require__(
      /*! xtend */
      "U6jy");

      var inherits = __webpack_require__(
      /*! inherits */
      "P7XM");

      module.exports = unherit; // Create a custom constructor which can be modified without affecting the
      // original class.

      function unherit(Super) {
        var result;
        var key;
        var value;
        inherits(Of, Super);
        inherits(From, Of); // Clone values.

        result = Of.prototype;

        for (key in result) {
          value = result[key];

          if (value && typeof value === 'object') {
            result[key] = 'concat' in value ? value.concat() : xtend(value);
          }
        }

        return Of; // Constructor accepting a single argument, which itself is an `arguments`
        // object.

        function From(parameters) {
          return Super.apply(this, parameters);
        } // Constructor accepting variadic arguments.


        function Of() {
          if (!(this instanceof Of)) {
            return new From(arguments);
          }

          return Super.apply(this, arguments);
        }
      }
      /***/

    },

    /***/
    "6dBs":
    /*!**************************************!*\
      !*** ./node_modules/extend/index.js ***!
      \**************************************/

    /*! no static exports found */

    /***/
    function dBs(module, exports, __webpack_require__) {
      "use strict";

      var hasOwn = Object.prototype.hasOwnProperty;
      var toStr = Object.prototype.toString;
      var defineProperty = Object.defineProperty;
      var gOPD = Object.getOwnPropertyDescriptor;

      var isArray = function isArray(arr) {
        if (typeof Array.isArray === 'function') {
          return Array.isArray(arr);
        }

        return toStr.call(arr) === '[object Array]';
      };

      var isPlainObject = function isPlainObject(obj) {
        if (!obj || toStr.call(obj) !== '[object Object]') {
          return false;
        }

        var hasOwnConstructor = hasOwn.call(obj, 'constructor');
        var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf'); // Not own constructor property must be Object

        if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
          return false;
        } // Own properties are enumerated firstly, so to speed up,
        // if last one is own, then all properties are own.


        var key;

        for (key in obj) {
          /**/
        }

        return typeof key === 'undefined' || hasOwn.call(obj, key);
      }; // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target


      var setProperty = function setProperty(target, options) {
        if (defineProperty && options.name === '__proto__') {
          defineProperty(target, options.name, {
            enumerable: true,
            configurable: true,
            value: options.newValue,
            writable: true
          });
        } else {
          target[options.name] = options.newValue;
        }
      }; // Return undefined instead of __proto__ if '__proto__' is not an own property


      var getProperty = function getProperty(obj, name) {
        if (name === '__proto__') {
          if (!hasOwn.call(obj, name)) {
            return void 0;
          } else if (gOPD) {
            // In early versions of node, obj['__proto__'] is buggy when obj has
            // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
            return gOPD(obj, name).value;
          }
        }

        return obj[name];
      };

      module.exports = function extend() {
        var options, name, src, copy, copyIsArray, clone;
        var target = arguments[0];
        var i = 1;
        var length = arguments.length;
        var deep = false; // Handle a deep copy situation

        if (typeof target === 'boolean') {
          deep = target;
          target = arguments[1] || {}; // skip the boolean and the target

          i = 2;
        }

        if (target == null || typeof target !== 'object' && typeof target !== 'function') {
          target = {};
        }

        for (; i < length; ++i) {
          options = arguments[i]; // Only deal with non-null/undefined values

          if (options != null) {
            // Extend the base object
            for (name in options) {
              src = getProperty(target, name);
              copy = getProperty(options, name); // Prevent never-ending loop

              if (target !== copy) {
                // Recurse if we're merging plain objects or arrays
                if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                  if (copyIsArray) {
                    copyIsArray = false;
                    clone = src && isArray(src) ? src : [];
                  } else {
                    clone = src && isPlainObject(src) ? src : {};
                  } // Never move original objects, clone them


                  setProperty(target, {
                    name: name,
                    newValue: extend(deep, clone, copy)
                  }); // Don't bring in undefined values
                } else if (typeof copy !== 'undefined') {
                  setProperty(target, {
                    name: name,
                    newValue: copy
                  });
                }
              }
            }
          }
        } // Return the modified object


        return target;
      };
      /***/

    },

    /***/
    "6lw0":
    /*!****************************!*\
      !*** ./prism/src/index.ts ***!
      \****************************/

    /*! exports provided: PrismHighlighter, LANGUAGE_MODULES, PrismService, PrismModule */

    /***/
    function lw0(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony import */


      var _lib_highlighter_highlighter_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./lib/highlighter/highlighter.component */
      "Cj6Q");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "PrismHighlighter", function () {
        return _lib_highlighter_highlighter_component__WEBPACK_IMPORTED_MODULE_0__["PrismHighlighter"];
      });
      /* harmony import */


      var _lib_prism_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./lib/prism.service */
      "fhd8");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "LANGUAGE_MODULES", function () {
        return _lib_prism_service__WEBPACK_IMPORTED_MODULE_1__["LANGUAGE_MODULES"];
      });
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "PrismService", function () {
        return _lib_prism_service__WEBPACK_IMPORTED_MODULE_1__["PrismService"];
      });
      /* harmony import */


      var _lib_prism_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! ./lib/prism.module */
      "FkM1");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "PrismModule", function () {
        return _lib_prism_module__WEBPACK_IMPORTED_MODULE_2__["PrismModule"];
      });
      /***/

    },

    /***/
    "6opK":
    /*!***********************************************!*\
      !*** ./markdown/src/lib/tree/tree.service.ts ***!
      \***********************************************/

    /*! exports provided: MarkdownTree */

    /***/
    function opK(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "MarkdownTree", function () {
        return MarkdownTree;
      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /** Parses a markdown text into an 'mdContent' syntax tree using Remark @see {https://github.com/remarkjs/remark} */


      var MarkdownTree = /*#__PURE__*/function () {
        function MarkdownTree(reparse) {
          _classCallCheck(this, MarkdownTree);

          this.reparse = reparse; // Common mode flags piercing down the tree

          this.disableHighlighting = false;
        }
        /** Top level nodes (root's children) */


        _createClass(MarkdownTree, [{
          key: "tops",
          get: function get() {
            return !!this.root && this.root.children || [];
          }
          /** Parses the markdown source into an mdContent tree */

        }, {
          key: "parse",
          value: function parse(source) {
            // Parses the source into the mdContent tree
            this.root = !!source ? this.reparse.parse(source) : {
              type: 'root'
            }; // Extracts the definitions (links and images)

            this.defs = this.tops.filter(function (node) {
              return node.type === 'definition';
            }); // Extracts the footnote definitions

            this.notes = this.tops.filter(function (node) {
              return node.type === 'footnoteDefinition';
            }); // Returns the root node

            return this.root;
          }
          /** Seeks for the definition's node of the matching reference  */

        }, {
          key: "definition",
          value: function definition(ref) {
            // Seeks the referred definition node
            return this.defs.find(function (def) {
              return def.identifier === ref.identifier;
            });
          }
          /** Seeks for the footnode definition's node of the matching reference */

        }, {
          key: "footnote",
          value: function footnote(ref) {
            // Seeks the referred definition node
            return this.notes.find(function (def) {
              return def.identifier === ref.identifier;
            });
          }
          /** Seeks for the footnote definition index of the matching reference */

        }, {
          key: "footnoteIndex",
          value: function footnoteIndex(ref) {
            return 1 + this.notes.findIndex(function (def) {
              return def.identifier === ref.identifier;
            });
          }
          /** Parses the tree branch returning a plain concatenated text */

        }, {
          key: "text",
          value: function text(node) {
            var _this2 = this;

            return "children" in node ? node.children.reduce(function (txt, child) {
              return txt + (child.type === 'text' ? child.value : '') + _this2.text(child);
            }, '') : '';
          }
        }]);

        return MarkdownTree;
      }();

      MarkdownTree.ɵfac = function MarkdownTree_Factory(t) {
        return new (t || MarkdownTree)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"]('reparse'));
      };

      MarkdownTree.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
        token: MarkdownTree,
        factory: MarkdownTree.ɵfac
      });
      /***/
    },

    /***/
    "7nPM":
    /*!**********************************************!*\
      !*** ./node_modules/vfile-location/index.js ***!
      \**********************************************/

    /*! no static exports found */

    /***/
    function nPM(module, exports, __webpack_require__) {
      "use strict";

      module.exports = factory;

      function factory(file) {
        var value = String(file);
        var indices = [];
        var search = /\r?\n|\r/g;

        while (search.exec(value)) {
          indices.push(search.lastIndex);
        }

        indices.push(value.length + 1);
        return {
          toPoint: offsetToPoint,
          toPosition: offsetToPoint,
          toOffset: pointToOffset
        }; // Get the line and column-based `point` for `offset` in the bound indices.

        function offsetToPoint(offset) {
          var index = -1;

          if (offset > -1 && offset < indices[indices.length - 1]) {
            while (++index < indices.length) {
              if (indices[index] > offset) {
                return {
                  line: index + 1,
                  column: offset - (indices[index - 1] || 0) + 1,
                  offset: offset
                };
              }
            }
          }

          return {};
        } // Get the `offset` for a line and column-based `point` in the bound
        // indices.


        function pointToOffset(point) {
          var line = point && point.line;
          var column = point && point.column;
          var offset;

          if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {
            offset = (indices[line - 2] || 0) + column - 1 || 0;
          }

          return offset > -1 && offset < indices[indices.length - 1] ? offset : -1;
        }
      }
      /***/

    },

    /***/
    "88mA":
    /*!*********************************************!*\
      !*** ./markdown/src/lib/reparse-factory.js ***!
      \*********************************************/

    /*! no static exports found */

    /***/
    function mA(module, exports, __webpack_require__) {
      /**
       * @module reparse
       * @version 0.0.2
       * @author Lucio Francisco
       * @description Hacks the unified/remark node modules to work as a markdown parser in a browser, the parser turns the input text into a MDAST syntaxt tree @see {https://github.com/remarkjs/remark}
       */
      (function (global) {
        'use strict'; // Implements a basic process shim to support vfile/path modules to work in a browser

        if (!!global && !global.process) {
          global.process = {
            //env: { DEBUG: undefined },
            cwd: function cwd() {
              return '/';
            },
            platform: ''
          };
        } // Imports the UNIFIED and REMARK modules


        var unified = __webpack_require__(
        /*! unified */
        "1VtT");

        var parse = __webpack_require__(
        /*! remark-parse */
        "fUUT");

        var subsup = __webpack_require__(
        /*! remark-sub-super */
        "LcL2");

        var align = __webpack_require__(
        /*! remark-align */
        "YGTb"); // Setupd the markdown parser configured with the given options @see {https://github.com/remarkjs/remark/tree/master/packages/remark-parse}


        function reparseFactory(options) {
          return unified().use(parse, options).use(subsup).use(align).freeze();
        } // Exports the parser setup function


        module.exports = {
          reparseFactory: reparseFactory
        };
      })(window);
      /***/

    },

    /***/
    "A6mZ":
    /*!****************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenizer.js ***!
      \****************************************************/

    /*! no static exports found */

    /***/
    function A6mZ(module, exports, __webpack_require__) {
      "use strict";

      module.exports = factory; // Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.

      function factory(type) {
        return tokenize; // Tokenizer for a bound `type`.

        function tokenize(value, location) {
          var self = this;
          var offset = self.offset;
          var tokens = [];
          var methods = self[type + 'Methods'];
          var tokenizers = self[type + 'Tokenizers'];
          var line = location.line;
          var column = location.column;
          var index;
          var length;
          var method;
          var name;
          var matched;
          var valueLength; // Trim white space only lines.

          if (!value) {
            return tokens;
          } // Expose on `eat`.


          eat.now = now;
          eat.file = self.file; // Sync initial offset.

          updatePosition(''); // Iterate over `value`, and iterate over all tokenizers.  When one eats
          // something, re-iterate with the remaining value.  If no tokenizer eats,
          // something failed (should not happen) and an exception is thrown.

          while (value) {
            index = -1;
            length = methods.length;
            matched = false;

            while (++index < length) {
              name = methods[index];
              method = tokenizers[name]; // Previously, we had constructs such as footnotes and YAML that used
              // these properties.
              // Those are now external (plus there are userland extensions), that may
              // still use them.

              if (method && (
              /* istanbul ignore next */
              !method.onlyAtStart || self.atStart) && (
              /* istanbul ignore next */
              !method.notInList || !self.inList) && (
              /* istanbul ignore next */
              !method.notInBlock || !self.inBlock) && (!method.notInLink || !self.inLink)) {
                valueLength = value.length;
                method.apply(self, [eat, value]);
                matched = valueLength !== value.length;

                if (matched) {
                  break;
                }
              }
            }
            /* istanbul ignore if */


            if (!matched) {
              self.file.fail(new Error('Infinite loop'), eat.now());
            }
          }

          self.eof = now();
          return tokens; // Update line, column, and offset based on `value`.

          function updatePosition(subvalue) {
            var lastIndex = -1;
            var index = subvalue.indexOf('\n');

            while (index !== -1) {
              line++;
              lastIndex = index;
              index = subvalue.indexOf('\n', index + 1);
            }

            if (lastIndex === -1) {
              column += subvalue.length;
            } else {
              column = subvalue.length - lastIndex;
            }

            if (line in offset) {
              if (lastIndex !== -1) {
                column += offset[line];
              } else if (column <= offset[line]) {
                column = offset[line] + 1;
              }
            }
          } // Get offset.  Called before the first character is eaten to retrieve the
          // range’s offsets.


          function getOffset() {
            var indentation = [];
            var pos = line + 1; // Done.  Called when the last character is eaten to retrieve the range’s
            // offsets.

            return function () {
              var last = line + 1;

              while (pos < last) {
                indentation.push((offset[pos] || 0) + 1);
                pos++;
              }

              return indentation;
            };
          } // Get the current position.


          function now() {
            var pos = {
              line: line,
              column: column
            };
            pos.offset = self.toOffset(pos);
            return pos;
          } // Store position information for a node.


          function Position(start) {
            this.start = start;
            this.end = now();
          } // Throw when a value is incorrectly eaten.  This shouldn’t happen but will
          // throw on new, incorrect rules.


          function validateEat(subvalue) {
            /* istanbul ignore if */
            if (value.slice(0, subvalue.length) !== subvalue) {
              // Capture stack-trace.
              self.file.fail(new Error('Incorrectly eaten value: please report this warning on https://git.io/vg5Ft'), now());
            }
          } // Mark position and patch `node.position`.


          function position() {
            var before = now();
            return update; // Add the position to a node.

            function update(node, indent) {
              var previous = node.position;
              var start = previous ? previous.start : before;
              var combined = [];
              var n = previous && previous.end.line;
              var l = before.line;
              node.position = new Position(start); // If there was already a `position`, this node was merged.  Fixing
              // `start` wasn’t hard, but the indent is different.  Especially
              // because some information, the indent between `n` and `l` wasn’t
              // tracked.  Luckily, that space is (should be?) empty, so we can
              // safely check for it now.

              if (previous && indent && previous.indent) {
                combined = previous.indent;

                if (n < l) {
                  while (++n < l) {
                    combined.push((offset[n] || 0) + 1);
                  }

                  combined.push(before.column);
                }

                indent = combined.concat(indent);
              }

              node.position.indent = indent || [];
              return node;
            }
          } // Add `node` to `parent`s children or to `tokens`.  Performs merges where
          // possible.


          function add(node, parent) {
            var children = parent ? parent.children : tokens;
            var previous = children[children.length - 1];
            var fn;

            if (previous && node.type === previous.type && (node.type === 'text' || node.type === 'blockquote') && mergeable(previous) && mergeable(node)) {
              fn = node.type === 'text' ? mergeText : mergeBlockquote;
              node = fn.call(self, previous, node);
            }

            if (node !== previous) {
              children.push(node);
            }

            if (self.atStart && tokens.length !== 0) {
              self.exitStart();
            }

            return node;
          } // Remove `subvalue` from `value`.  `subvalue` must be at the start of
          // `value`.


          function eat(subvalue) {
            var indent = getOffset();
            var pos = position();
            var current = now();
            validateEat(subvalue);
            apply.reset = reset;
            reset.test = test;
            apply.test = test;
            value = value.slice(subvalue.length);
            updatePosition(subvalue);
            indent = indent();
            return apply; // Add the given arguments, add `position` to the returned node, and
            // return the node.

            function apply(node, parent) {
              return pos(add(pos(node), parent), indent);
            } // Functions just like apply, but resets the content: the line and
            // column are reversed, and the eaten value is re-added.   This is
            // useful for nodes with a single type of content, such as lists and
            // tables.  See `apply` above for what parameters are expected.


            function reset() {
              var node = apply.apply(null, arguments);
              line = current.line;
              column = current.column;
              value = subvalue + value;
              return node;
            } // Test the position, after eating, and reverse to a not-eaten state.


            function test() {
              var result = pos({});
              line = current.line;
              column = current.column;
              value = subvalue + value;
              return result.position;
            }
          }
        }
      } // Check whether a node is mergeable with adjacent nodes.


      function mergeable(node) {
        var start;
        var end;

        if (node.type !== 'text' || !node.position) {
          return true;
        }

        start = node.position.start;
        end = node.position.end; // Only merge nodes which occupy the same size as their `value`.

        return start.line !== end.line || end.column - start.column === node.value.length;
      } // Merge two text nodes: `node` into `prev`.


      function mergeText(previous, node) {
        previous.value += node.value;
        return previous;
      } // Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.


      function mergeBlockquote(previous, node) {
        if (this.options.commonmark || this.options.gfm) {
          return node;
        }

        previous.children = previous.children.concat(node.children);
        return previous;
      }
      /***/

    },

    /***/
    "AJTF":
    /*!****************************************************************!*\
      !*** ./node_modules/unist-util-visit-parents/color.browser.js ***!
      \****************************************************************/

    /*! no static exports found */

    /***/
    function AJTF(module, exports) {
      module.exports = identity;

      function identity(d) {
        return d;
      }
      /***/

    },

    /***/
    "BjVE":
    /*!********************************************************!*\
      !*** ./node_modules/remark-parse/lib/locate/strong.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function BjVE(module, exports, __webpack_require__) {
      "use strict";

      module.exports = locate;

      function locate(value, fromIndex) {
        var asterisk = value.indexOf('**', fromIndex);
        var underscore = value.indexOf('__', fromIndex);

        if (underscore === -1) {
          return asterisk;
        }

        if (asterisk === -1) {
          return underscore;
        }

        return underscore < asterisk ? underscore : asterisk;
      }
      /***/

    },

    /***/
    "Brp5":
    /*!*************************************************************!*\
      !*** ./node_modules/remark-parse/lib/locate/code-inline.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function Brp5(module, exports, __webpack_require__) {
      "use strict";

      module.exports = locate;

      function locate(value, fromIndex) {
        return value.indexOf('`', fromIndex);
      }
      /***/

    },

    /***/
    "CRs9":
    /*!**********************************************************!*\
      !*** ./node_modules/remark-parse/lib/locate/emphasis.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function CRs9(module, exports, __webpack_require__) {
      "use strict";

      module.exports = locate;

      function locate(value, fromIndex) {
        var asterisk = value.indexOf('*', fromIndex);
        var underscore = value.indexOf('_', fromIndex);

        if (underscore === -1) {
          return asterisk;
        }

        if (asterisk === -1) {
          return underscore;
        }

        return underscore < asterisk ? underscore : asterisk;
      }
      /***/

    },

    /***/
    "Cj6Q":
    /*!************************************************************!*\
      !*** ./prism/src/lib/highlighter/highlighter.component.ts ***!
      \************************************************************/

    /*! exports provided: PrismHighlighter */

    /***/
    function Cj6Q(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "PrismHighlighter", function () {
        return PrismHighlighter;
      });
      /* harmony import */


      var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/cdk/coercion */
      "8LU1");
      /* harmony import */


      var _prism_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ../prism.service */
      "fhd8");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @angular/common */
      "SVse");
      /* harmony import */


      var _tokenizer_tokenizer_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! ../tokenizer/tokenizer.component */
      "XJsG");

      var _c0 = ["wm-prism", ""];

      function PrismHighlighter_code_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "code", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipe"](1, "async");
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("tokenize", _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipeBind1"](1, 1, ctx_r0.tokens$));
        }
      }

      function PrismHighlighter_ng_template_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵprojection"](0);
        }
      }

      var _c1 = ["*"];
      /** Perform code hilighting by processing an input text to be rendered into an angular template
       * Using prism as tokenizer @see {https://github.com/PrismJS/prism} */

      var PrismHighlighter = /*#__PURE__*/function () {
        function PrismHighlighter(prism) {
          _classCallCheck(this, PrismHighlighter);

          this.prism = prism;
          this.disabled = false;
        }
        /** Applies the proper classes to the host <pre> element */


        _createClass(PrismHighlighter, [{
          key: "clazz",
          get: function get() {
            return "wm-prism".concat(this.disabled ? '' : ' language-none');
          }
          /** Disables the highlighting */

        }, {
          key: "disableHighlight",
          set: function set(value) {
            this.disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
          }
          /** Parses the source text */

        }, {
          key: "source",
          set: function set(source) {
            this.tokens$ = this.prism.tokenize(source, this.language);
          }
        }]);

        return PrismHighlighter;
      }();

      PrismHighlighter.ɵfac = function PrismHighlighter_Factory(t) {
        return new (t || PrismHighlighter)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_prism_service__WEBPACK_IMPORTED_MODULE_1__["PrismService"]));
      };

      PrismHighlighter.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineComponent"]({
        type: PrismHighlighter,
        selectors: [["pre", "wm-prism", ""]],
        hostVars: 2,
        hostBindings: function PrismHighlighter_HostBindings(rf, ctx) {
          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵclassMap"](ctx.clazz);
          }
        },
        inputs: {
          disableHighlight: ["disabled", "disableHighlight"],
          language: "language",
          source: ["wm-prism", "source"]
        },
        attrs: _c0,
        ngContentSelectors: _c1,
        decls: 3,
        vars: 2,
        consts: [[3, "tokenize", 4, "ngIf", "ngIfElse"], ["transclude", ""], [3, "tokenize"]],
        template: function PrismHighlighter_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵprojectionDef"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](0, PrismHighlighter_code_0_Template, 2, 3, "code", 0);

            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](1, PrismHighlighter_ng_template_1_Template, 1, 0, "ng-template", null, 1, _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplateRefExtractor"]);
          }

          if (rf & 2) {
            var _r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵreference"](2);

            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", !ctx.disabled)("ngIfElse", _r1);
          }
        },
        directives: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["NgIf"], _tokenizer_tokenizer_component__WEBPACK_IMPORTED_MODULE_4__["PrismTokenizer"]],
        pipes: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["AsyncPipe"]],
        encapsulation: 2
      });
      /***/
    },

    /***/
    "EBzq":
    /*!*************************************!*\
      !*** ./node_modules/trough/wrap.js ***!
      \*************************************/

    /*! no static exports found */

    /***/
    function EBzq(module, exports, __webpack_require__) {
      "use strict";

      var slice = [].slice;
      module.exports = wrap; // Wrap `fn`.
      // Can be sync or async; return a promise, receive a completion handler, return
      // new values and errors.

      function wrap(fn, callback) {
        var invoked;
        return wrapped;

        function wrapped() {
          var params = slice.call(arguments, 0);
          var callback = fn.length > params.length;
          var result;

          if (callback) {
            params.push(done);
          }

          try {
            result = fn.apply(null, params);
          } catch (error) {
            // Well, this is quite the pickle.
            // `fn` received a callback and invoked it (thus continuing the pipeline),
            // but later also threw an error.
            // We’re not about to restart the pipeline again, so the only thing left
            // to do is to throw the thing instead.
            if (callback && invoked) {
              throw error;
            }

            return done(error);
          }

          if (!callback) {
            if (result && typeof result.then === 'function') {
              result.then(then, done);
            } else if (result instanceof Error) {
              done(result);
            } else {
              then(result);
            }
          }
        } // Invoke `next`, only once.


        function done() {
          if (!invoked) {
            invoked = true;
            callback.apply(null, arguments);
          }
        } // Invoke `done` with one value.
        // Tracks if an error is passed, too.


        function then(value) {
          done(null, value);
        }
      }
      /***/

    },

    /***/
    "EJE9":
    /*!***********************************************************!*\
      !*** ./wizdm/src/app/utils/size-lock/size-lock.module.ts ***!
      \***********************************************************/

    /*! exports provided: SizeLockModule */

    /***/
    function EJE9(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "SizeLockModule", function () {
        return SizeLockModule;
      });
      /* harmony import */


      var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/cdk/scrolling */
      "7KAL");
      /* harmony import */


      var _size_lock_directive__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./size-lock.directive */
      "1QJd");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J"); //import { CommonModule } from '@angular/common';


      var SizeLockModule = function SizeLockModule() {
        _classCallCheck(this, SizeLockModule);
      };

      SizeLockModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]({
        type: SizeLockModule
      });
      SizeLockModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjector"]({
        factory: function SizeLockModule_Factory(t) {
          return new (t || SizeLockModule)();
        },
        imports: [[_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__["ScrollingModule"]]]
      });

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵsetNgModuleScope"](SizeLockModule, {
          declarations: [_size_lock_directive__WEBPACK_IMPORTED_MODULE_1__["SizeLockDirective"]],
          imports: [_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__["ScrollingModule"]],
          exports: [_size_lock_directive__WEBPACK_IMPORTED_MODULE_1__["SizeLockDirective"]]
        });
      })();
      /***/

    },

    /***/
    "EQPF":
    /*!***************************************************!*\
      !*** ./node_modules/remark-parse/lib/unescape.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function EQPF(module, exports, __webpack_require__) {
      "use strict";

      module.exports = factory;
      var backslash = '\\'; // Factory to de-escape a value, based on a list at `key` in `ctx`.

      function factory(ctx, key) {
        return unescape; // De-escape a string using the expression at `key` in `ctx`.

        function unescape(value) {
          var previous = 0;
          var index = value.indexOf(backslash);
          var escape = ctx[key];
          var queue = [];
          var character;

          while (index !== -1) {
            queue.push(value.slice(previous, index));
            previous = index + 1;
            character = value.charAt(previous); // If the following character is not a valid escape, add the slash.

            if (!character || escape.indexOf(character) === -1) {
              queue.push(backslash);
            }

            index = value.indexOf(backslash, previous + 1);
          }

          queue.push(value.slice(previous));
          return queue.join('');
        }
      }
      /***/

    },

    /***/
    "EmYC":
    /*!******************************************************!*\
      !*** ./node_modules/remark-parse/lib/locate/link.js ***!
      \******************************************************/

    /*! no static exports found */

    /***/
    function EmYC(module, exports, __webpack_require__) {
      "use strict";

      module.exports = locate;

      function locate(value, fromIndex) {
        var link = value.indexOf('[', fromIndex);
        var image = value.indexOf('![', fromIndex);

        if (image === -1) {
          return link;
        } // Link can never be `-1` if an image is found, so we don’t need to check
        // for that :)


        return link < image ? link : image;
      }
      /***/

    },

    /***/
    "Esvb":
    /*!*************************************!*\
      !*** ./node_modules/vfile/index.js ***!
      \*************************************/

    /*! no static exports found */

    /***/
    function Esvb(module, exports, __webpack_require__) {
      "use strict";

      module.exports = __webpack_require__(
      /*! ./lib */
      "PPHF");
      /***/
    },

    /***/
    "F2il":
    /*!**************************************!*\
      !*** ./node_modules/ccount/index.js ***!
      \**************************************/

    /*! no static exports found */

    /***/
    function F2il(module, exports, __webpack_require__) {
      "use strict";

      module.exports = ccount;

      function ccount(source, character) {
        var value = String(source);
        var count = 0;
        var index;

        if (typeof character !== 'string') {
          throw new Error('Expected character');
        }

        index = value.indexOf(character);

        while (index !== -1) {
          count++;
          index = value.indexOf(character, index + character.length);
        }

        return count;
      }
      /***/

    },

    /***/
    "FKt/":
    /*!********************************************!*\
      !*** ./emoji/src/lib/names/emoji-names.ts ***!
      \********************************************/

    /*! exports provided: emojiNames */

    /***/
    function FKt(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "emojiNames", function () {
        return emojiNames;
      });

      var emojiNames = {
        "100": "💯",
        "1234": "🔢",
        "grinning": "😀",
        "grimacing": "😬",
        "grin": "😁",
        "joy": "😂",
        "rofl": "🤣",
        "partying": "🥳",
        "smiley": "😃",
        "smile": "😄",
        "sweat_smile": "😅",
        "laughing": "😆",
        "innocent": "😇",
        "wink": "😉",
        "blush": "😊",
        "slightly_smiling_face": "🙂",
        "upside_down_face": "🙃",
        "relaxed": "☺️",
        "yum": "😋",
        "relieved": "😌",
        "heart_eyes": "😍",
        "smiling_face_with_three_hearts": "🥰",
        "kissing_heart": "😘",
        "kissing": "😗",
        "kissing_smiling_eyes": "😙",
        "kissing_closed_eyes": "😚",
        "stuck_out_tongue_winking_eye": "😜",
        "zany": "🤪",
        "raised_eyebrow": "🤨",
        "monocle": "🧐",
        "stuck_out_tongue_closed_eyes": "😝",
        "stuck_out_tongue": "😛",
        "money_mouth_face": "🤑",
        "nerd_face": "🤓",
        "sunglasses": "😎",
        "star_struck": "🤩",
        "clown_face": "🤡",
        "cowboy_hat_face": "🤠",
        "hugs": "🤗",
        "smirk": "😏",
        "no_mouth": "😶",
        "neutral_face": "😐",
        "expressionless": "😑",
        "unamused": "😒",
        "roll_eyes": "🙄",
        "thinking": "🤔",
        "lying_face": "🤥",
        "hand_over_mouth": "🤭",
        "shushing": "🤫",
        "symbols_over_mouth": "🤬",
        "exploding_head": "🤯",
        "flushed": "😳",
        "disappointed": "😞",
        "worried": "😟",
        "angry": "😠",
        "rage": "😡",
        "pensive": "😔",
        "confused": "😕",
        "slightly_frowning_face": "🙁",
        "frowning_face": "☹",
        "persevere": "😣",
        "confounded": "😖",
        "tired_face": "😫",
        "weary": "😩",
        "pleading": "🥺",
        "triumph": "😤",
        "open_mouth": "😮",
        "scream": "😱",
        "fearful": "😨",
        "cold_sweat": "😰",
        "hushed": "😯",
        "frowning": "😦",
        "anguished": "😧",
        "cry": "😢",
        "disappointed_relieved": "😥",
        "drooling_face": "🤤",
        "sleepy": "😪",
        "sweat": "😓",
        "hot": "🥵",
        "cold": "🥶",
        "sob": "😭",
        "dizzy_face": "😵",
        "astonished": "😲",
        "zipper_mouth_face": "🤐",
        "nauseated_face": "🤢",
        "sneezing_face": "🤧",
        "vomiting": "🤮",
        "mask": "😷",
        "face_with_thermometer": "🤒",
        "face_with_head_bandage": "🤕",
        "woozy": "🥴",
        "sleeping": "😴",
        "zzz": "💤",
        "poop": "💩",
        "smiling_imp": "😈",
        "imp": "👿",
        "japanese_ogre": "👹",
        "japanese_goblin": "👺",
        "skull": "💀",
        "ghost": "👻",
        "alien": "👽",
        "robot": "🤖",
        "smiley_cat": "😺",
        "smile_cat": "😸",
        "joy_cat": "😹",
        "heart_eyes_cat": "😻",
        "smirk_cat": "😼",
        "kissing_cat": "😽",
        "scream_cat": "🙀",
        "crying_cat_face": "😿",
        "pouting_cat": "😾",
        "palms_up": "🤲",
        "raised_hands": "🙌",
        "clap": "👏",
        "wave": "👋",
        "call_me_hand": "🤙",
        "+1": "👍",
        "-1": "👎",
        "facepunch": "👊",
        "fist": "✊",
        "fist_left": "🤛",
        "fist_right": "🤜",
        "v": "✌",
        "ok_hand": "👌",
        "raised_hand": "✋",
        "raised_back_of_hand": "🤚",
        "open_hands": "👐",
        "muscle": "💪",
        "pray": "🙏",
        "foot": "🦶",
        "leg": "🦵",
        "handshake": "🤝",
        "point_up": "☝",
        "point_up_2": "👆",
        "point_down": "👇",
        "point_left": "👈",
        "point_right": "👉",
        "fu": "🖕",
        "raised_hand_with_fingers_splayed": "🖐",
        "love_you": "🤟",
        "metal": "🤘",
        "crossed_fingers": "🤞",
        "vulcan_salute": "🖖",
        "writing_hand": "✍",
        "selfie": "🤳",
        "nail_care": "💅",
        "lips": "👄",
        "tooth": "🦷",
        "tongue": "👅",
        "ear": "👂",
        "nose": "👃",
        "eye": "👁",
        "eyes": "👀",
        "brain": "🧠",
        "bust_in_silhouette": "👤",
        "busts_in_silhouette": "👥",
        "speaking_head": "🗣",
        "baby": "👶",
        "child": "🧒",
        "boy": "👦",
        "girl": "👧",
        "adult": "🧑",
        "man": "👨",
        "woman": "👩",
        "blonde_woman": "👱‍♀️",
        "blonde_man": "👱",
        "bearded_person": "🧔",
        "older_adult": "🧓",
        "older_man": "👴",
        "older_woman": "👵",
        "man_with_gua_pi_mao": "👲",
        "woman_with_headscarf": "🧕",
        "woman_with_turban": "👳‍♀️",
        "man_with_turban": "👳",
        "policewoman": "👮‍♀️",
        "policeman": "👮",
        "construction_worker_woman": "👷‍♀️",
        "construction_worker_man": "👷",
        "guardswoman": "💂‍♀️",
        "guardsman": "💂",
        "female_detective": "🕵️‍♀️",
        "male_detective": "🕵",
        "woman_health_worker": "👩‍⚕️",
        "man_health_worker": "👨‍⚕️",
        "woman_farmer": "👩‍🌾",
        "man_farmer": "👨‍🌾",
        "woman_cook": "👩‍🍳",
        "man_cook": "👨‍🍳",
        "woman_student": "👩‍🎓",
        "man_student": "👨‍🎓",
        "woman_singer": "👩‍🎤",
        "man_singer": "👨‍🎤",
        "woman_teacher": "👩‍🏫",
        "man_teacher": "👨‍🏫",
        "woman_factory_worker": "👩‍🏭",
        "man_factory_worker": "👨‍🏭",
        "woman_technologist": "👩‍💻",
        "man_technologist": "👨‍💻",
        "woman_office_worker": "👩‍💼",
        "man_office_worker": "👨‍💼",
        "woman_mechanic": "👩‍🔧",
        "man_mechanic": "👨‍🔧",
        "woman_scientist": "👩‍🔬",
        "man_scientist": "👨‍🔬",
        "woman_artist": "👩‍🎨",
        "man_artist": "👨‍🎨",
        "woman_firefighter": "👩‍🚒",
        "man_firefighter": "👨‍🚒",
        "woman_pilot": "👩‍✈️",
        "man_pilot": "👨‍✈️",
        "woman_astronaut": "👩‍🚀",
        "man_astronaut": "👨‍🚀",
        "woman_judge": "👩‍⚖️",
        "man_judge": "👨‍⚖️",
        "woman_superhero": "🦸‍♀️",
        "man_superhero": "🦸‍♂️",
        "woman_supervillain": "🦹‍♀️",
        "man_supervillain": "🦹‍♂️",
        "mrs_claus": "🤶",
        "santa": "🎅",
        "sorceress": "🧙‍♀️",
        "wizard": "🧙‍♂️",
        "woman_elf": "🧝‍♀️",
        "man_elf": "🧝‍♂️",
        "woman_vampire": "🧛‍♀️",
        "man_vampire": "🧛‍♂️",
        "woman_zombie": "🧟‍♀️",
        "man_zombie": "🧟‍♂️",
        "woman_genie": "🧞‍♀️",
        "man_genie": "🧞‍♂️",
        "mermaid": "🧜‍♀️",
        "merman": "🧜‍♂️",
        "woman_fairy": "🧚‍♀️",
        "man_fairy": "🧚‍♂️",
        "angel": "👼",
        "pregnant_woman": "🤰",
        "breastfeeding": "🤱",
        "princess": "👸",
        "prince": "🤴",
        "bride_with_veil": "👰",
        "man_in_tuxedo": "🤵",
        "running_woman": "🏃‍♀️",
        "running_man": "🏃",
        "walking_woman": "🚶‍♀️",
        "walking_man": "🚶",
        "dancer": "💃",
        "man_dancing": "🕺",
        "dancing_women": "👯",
        "dancing_men": "👯‍♂️",
        "couple": "👫",
        "two_men_holding_hands": "👬",
        "two_women_holding_hands": "👭",
        "bowing_woman": "🙇‍♀️",
        "bowing_man": "🙇",
        "man_facepalming": "🤦‍♂️",
        "woman_facepalming": "🤦‍♀️",
        "woman_shrugging": "🤷",
        "man_shrugging": "🤷‍♂️",
        "tipping_hand_woman": "💁",
        "tipping_hand_man": "💁‍♂️",
        "no_good_woman": "🙅",
        "no_good_man": "🙅‍♂️",
        "ok_woman": "🙆",
        "ok_man": "🙆‍♂️",
        "raising_hand_woman": "🙋",
        "raising_hand_man": "🙋‍♂️",
        "pouting_woman": "🙎",
        "pouting_man": "🙎‍♂️",
        "frowning_woman": "🙍",
        "frowning_man": "🙍‍♂️",
        "haircut_woman": "💇",
        "haircut_man": "💇‍♂️",
        "massage_woman": "💆",
        "massage_man": "💆‍♂️",
        "woman_in_steamy_room": "🧖‍♀️",
        "man_in_steamy_room": "🧖‍♂️",
        "couple_with_heart_woman_man": "💑",
        "couple_with_heart_woman_woman": "👩‍❤️‍👩",
        "couple_with_heart_man_man": "👨‍❤️‍👨",
        "couplekiss_man_woman": "💏",
        "couplekiss_woman_woman": "👩‍❤️‍💋‍👩",
        "couplekiss_man_man": "👨‍❤️‍💋‍👨",
        "family_man_woman_boy": "👪",
        "family_man_woman_girl": "👨‍👩‍👧",
        "family_man_woman_girl_boy": "👨‍👩‍👧‍👦",
        "family_man_woman_boy_boy": "👨‍👩‍👦‍👦",
        "family_man_woman_girl_girl": "👨‍👩‍👧‍👧",
        "family_woman_woman_boy": "👩‍👩‍👦",
        "family_woman_woman_girl": "👩‍👩‍👧",
        "family_woman_woman_girl_boy": "👩‍👩‍👧‍👦",
        "family_woman_woman_boy_boy": "👩‍👩‍👦‍👦",
        "family_woman_woman_girl_girl": "👩‍👩‍👧‍👧",
        "family_man_man_boy": "👨‍👨‍👦",
        "family_man_man_girl": "👨‍👨‍👧",
        "family_man_man_girl_boy": "👨‍👨‍👧‍👦",
        "family_man_man_boy_boy": "👨‍👨‍👦‍👦",
        "family_man_man_girl_girl": "👨‍👨‍👧‍👧",
        "family_woman_boy": "👩‍👦",
        "family_woman_girl": "👩‍👧",
        "family_woman_girl_boy": "👩‍👧‍👦",
        "family_woman_boy_boy": "👩‍👦‍👦",
        "family_woman_girl_girl": "👩‍👧‍👧",
        "family_man_boy": "👨‍👦",
        "family_man_girl": "👨‍👧",
        "family_man_girl_boy": "👨‍👧‍👦",
        "family_man_boy_boy": "👨‍👦‍👦",
        "family_man_girl_girl": "👨‍👧‍👧",
        "yarn": "🧶",
        "thread": "🧵",
        "coat": "🧥",
        "labcoat": "🥼",
        "womans_clothes": "👚",
        "tshirt": "👕",
        "jeans": "👖",
        "necktie": "👔",
        "dress": "👗",
        "bikini": "👙",
        "kimono": "👘",
        "lipstick": "💄",
        "kiss": "💋",
        "footprints": "👣",
        "flat_shoe": "🥿",
        "high_heel": "👠",
        "sandal": "👡",
        "boot": "👢",
        "mans_shoe": "👞",
        "athletic_shoe": "👟",
        "hiking_boot": "🥾",
        "socks": "🧦",
        "gloves": "🧤",
        "scarf": "🧣",
        "womans_hat": "👒",
        "tophat": "🎩",
        "billed_hat": "🧢",
        "rescue_worker_helmet": "⛑",
        "mortar_board": "🎓",
        "crown": "👑",
        "school_satchel": "🎒",
        "luggage": "🧳",
        "pouch": "👝",
        "purse": "👛",
        "handbag": "👜",
        "briefcase": "💼",
        "eyeglasses": "👓",
        "dark_sunglasses": "🕶",
        "goggles": "🥽",
        "ring": "💍",
        "closed_umbrella": "🌂",
        "dog": "🐶",
        "cat": "🐱",
        "mouse": "🐭",
        "hamster": "🐹",
        "rabbit": "🐰",
        "fox_face": "🦊",
        "bear": "🐻",
        "panda_face": "🐼",
        "koala": "🐨",
        "tiger": "🐯",
        "lion": "🦁",
        "cow": "🐮",
        "pig": "🐷",
        "pig_nose": "🐽",
        "frog": "🐸",
        "squid": "🦑",
        "octopus": "🐙",
        "shrimp": "🦐",
        "monkey_face": "🐵",
        "gorilla": "🦍",
        "see_no_evil": "🙈",
        "hear_no_evil": "🙉",
        "speak_no_evil": "🙊",
        "monkey": "🐒",
        "chicken": "🐔",
        "penguin": "🐧",
        "bird": "🐦",
        "baby_chick": "🐤",
        "hatching_chick": "🐣",
        "hatched_chick": "🐥",
        "duck": "🦆",
        "eagle": "🦅",
        "owl": "🦉",
        "bat": "🦇",
        "wolf": "🐺",
        "boar": "🐗",
        "horse": "🐴",
        "unicorn": "🦄",
        "honeybee": "🐝",
        "bug": "🐛",
        "butterfly": "🦋",
        "snail": "🐌",
        "beetle": "🐞",
        "ant": "🐜",
        "grasshopper": "🦗",
        "spider": "🕷",
        "scorpion": "🦂",
        "crab": "🦀",
        "snake": "🐍",
        "lizard": "🦎",
        "t-rex": "🦖",
        "sauropod": "🦕",
        "turtle": "🐢",
        "tropical_fish": "🐠",
        "fish": "🐟",
        "blowfish": "🐡",
        "dolphin": "🐬",
        "shark": "🦈",
        "whale": "🐳",
        "whale2": "🐋",
        "crocodile": "🐊",
        "leopard": "🐆",
        "zebra": "🦓",
        "tiger2": "🐅",
        "water_buffalo": "🐃",
        "ox": "🐂",
        "cow2": "🐄",
        "deer": "🦌",
        "dromedary_camel": "🐪",
        "camel": "🐫",
        "giraffe": "🦒",
        "elephant": "🐘",
        "rhinoceros": "🦏",
        "goat": "🐐",
        "ram": "🐏",
        "sheep": "🐑",
        "racehorse": "🐎",
        "pig2": "🐖",
        "rat": "🐀",
        "mouse2": "🐁",
        "rooster": "🐓",
        "turkey": "🦃",
        "dove": "🕊",
        "dog2": "🐕",
        "poodle": "🐩",
        "cat2": "🐈",
        "rabbit2": "🐇",
        "chipmunk": "🐿",
        "hedgehog": "🦔",
        "raccoon": "🦝",
        "llama": "🦙",
        "hippopotamus": "🦛",
        "kangaroo": "🦘",
        "badger": "🦡",
        "swan": "🦢",
        "peacock": "🦚",
        "parrot": "🦜",
        "lobster": "🦞",
        "mosquito": "🦟",
        "paw_prints": "🐾",
        "dragon": "🐉",
        "dragon_face": "🐲",
        "cactus": "🌵",
        "christmas_tree": "🎄",
        "evergreen_tree": "🌲",
        "deciduous_tree": "🌳",
        "palm_tree": "🌴",
        "seedling": "🌱",
        "herb": "🌿",
        "shamrock": "☘",
        "four_leaf_clover": "🍀",
        "bamboo": "🎍",
        "tanabata_tree": "🎋",
        "leaves": "🍃",
        "fallen_leaf": "🍂",
        "maple_leaf": "🍁",
        "ear_of_rice": "🌾",
        "hibiscus": "🌺",
        "sunflower": "🌻",
        "rose": "🌹",
        "wilted_flower": "🥀",
        "tulip": "🌷",
        "blossom": "🌼",
        "cherry_blossom": "🌸",
        "bouquet": "💐",
        "mushroom": "🍄",
        "chestnut": "🌰",
        "jack_o_lantern": "🎃",
        "shell": "🐚",
        "spider_web": "🕸",
        "earth_americas": "🌎",
        "earth_africa": "🌍",
        "earth_asia": "🌏",
        "full_moon": "🌕",
        "waning_gibbous_moon": "🌖",
        "last_quarter_moon": "🌗",
        "waning_crescent_moon": "🌘",
        "new_moon": "🌑",
        "waxing_crescent_moon": "🌒",
        "first_quarter_moon": "🌓",
        "waxing_gibbous_moon": "🌔",
        "new_moon_with_face": "🌚",
        "full_moon_with_face": "🌝",
        "first_quarter_moon_with_face": "🌛",
        "last_quarter_moon_with_face": "🌜",
        "sun_with_face": "🌞",
        "crescent_moon": "🌙",
        "star": "⭐",
        "star2": "🌟",
        "dizzy": "💫",
        "sparkles": "✨",
        "comet": "☄",
        "sunny": "☀️",
        "sun_behind_small_cloud": "🌤",
        "partly_sunny": "⛅",
        "sun_behind_large_cloud": "🌥",
        "sun_behind_rain_cloud": "🌦",
        "cloud": "☁️",
        "cloud_with_rain": "🌧",
        "cloud_with_lightning_and_rain": "⛈",
        "cloud_with_lightning": "🌩",
        "zap": "⚡",
        "fire": "🔥",
        "boom": "💥",
        "snowflake": "❄️",
        "cloud_with_snow": "🌨",
        "snowman": "⛄",
        "snowman_with_snow": "☃",
        "wind_face": "🌬",
        "dash": "💨",
        "tornado": "🌪",
        "fog": "🌫",
        "open_umbrella": "☂",
        "umbrella": "☔",
        "droplet": "💧",
        "sweat_drops": "💦",
        "ocean": "🌊",
        "green_apple": "🍏",
        "apple": "🍎",
        "pear": "🍐",
        "tangerine": "🍊",
        "lemon": "🍋",
        "banana": "🍌",
        "watermelon": "🍉",
        "grapes": "🍇",
        "strawberry": "🍓",
        "melon": "🍈",
        "cherries": "🍒",
        "peach": "🍑",
        "pineapple": "🍍",
        "coconut": "🥥",
        "kiwi_fruit": "🥝",
        "mango": "🥭",
        "avocado": "🥑",
        "broccoli": "🥦",
        "tomato": "🍅",
        "eggplant": "🍆",
        "cucumber": "🥒",
        "carrot": "🥕",
        "hot_pepper": "🌶",
        "potato": "🥔",
        "corn": "🌽",
        "leafy_greens": "🥬",
        "sweet_potato": "🍠",
        "peanuts": "🥜",
        "honey_pot": "🍯",
        "croissant": "🥐",
        "bread": "🍞",
        "baguette_bread": "🥖",
        "bagel": "🥯",
        "pretzel": "🥨",
        "cheese": "🧀",
        "egg": "🥚",
        "bacon": "🥓",
        "steak": "🥩",
        "pancakes": "🥞",
        "poultry_leg": "🍗",
        "meat_on_bone": "🍖",
        "bone": "🦴",
        "fried_shrimp": "🍤",
        "fried_egg": "🍳",
        "hamburger": "🍔",
        "fries": "🍟",
        "stuffed_flatbread": "🥙",
        "hotdog": "🌭",
        "pizza": "🍕",
        "sandwich": "🥪",
        "canned_food": "🥫",
        "spaghetti": "🍝",
        "taco": "🌮",
        "burrito": "🌯",
        "green_salad": "🥗",
        "shallow_pan_of_food": "🥘",
        "ramen": "🍜",
        "stew": "🍲",
        "fish_cake": "🍥",
        "fortune_cookie": "🥠",
        "sushi": "🍣",
        "bento": "🍱",
        "curry": "🍛",
        "rice_ball": "🍙",
        "rice": "🍚",
        "rice_cracker": "🍘",
        "oden": "🍢",
        "dango": "🍡",
        "shaved_ice": "🍧",
        "ice_cream": "🍨",
        "icecream": "🍦",
        "pie": "🥧",
        "cake": "🍰",
        "cupcake": "🧁",
        "moon_cake": "🥮",
        "birthday": "🎂",
        "custard": "🍮",
        "candy": "🍬",
        "lollipop": "🍭",
        "chocolate_bar": "🍫",
        "popcorn": "🍿",
        "dumpling": "🥟",
        "doughnut": "🍩",
        "cookie": "🍪",
        "milk_glass": "🥛",
        "beer": "🍺",
        "beers": "🍻",
        "clinking_glasses": "🥂",
        "wine_glass": "🍷",
        "tumbler_glass": "🥃",
        "cocktail": "🍸",
        "tropical_drink": "🍹",
        "champagne": "🍾",
        "sake": "🍶",
        "tea": "🍵",
        "cup_with_straw": "🥤",
        "coffee": "☕",
        "baby_bottle": "🍼",
        "salt": "🧂",
        "spoon": "🥄",
        "fork_and_knife": "🍴",
        "plate_with_cutlery": "🍽",
        "bowl_with_spoon": "🥣",
        "takeout_box": "🥡",
        "chopsticks": "🥢",
        "soccer": "⚽",
        "basketball": "🏀",
        "football": "🏈",
        "baseball": "⚾",
        "softball": "🥎",
        "tennis": "🎾",
        "volleyball": "🏐",
        "rugby_football": "🏉",
        "flying_disc": "🥏",
        "8ball": "🎱",
        "golf": "⛳",
        "golfing_woman": "🏌️‍♀️",
        "golfing_man": "🏌",
        "ping_pong": "🏓",
        "badminton": "🏸",
        "goal_net": "🥅",
        "ice_hockey": "🏒",
        "field_hockey": "🏑",
        "lacrosse": "🥍",
        "cricket": "🏏",
        "ski": "🎿",
        "skier": "⛷",
        "snowboarder": "🏂",
        "person_fencing": "🤺",
        "women_wrestling": "🤼‍♀️",
        "men_wrestling": "🤼‍♂️",
        "woman_cartwheeling": "🤸‍♀️",
        "man_cartwheeling": "🤸‍♂️",
        "woman_playing_handball": "🤾‍♀️",
        "man_playing_handball": "🤾‍♂️",
        "ice_skate": "⛸",
        "curling_stone": "🥌",
        "skateboard": "🛹",
        "sled": "🛷",
        "bow_and_arrow": "🏹",
        "fishing_pole_and_fish": "🎣",
        "boxing_glove": "🥊",
        "martial_arts_uniform": "🥋",
        "rowing_woman": "🚣‍♀️",
        "rowing_man": "🚣",
        "climbing_woman": "🧗‍♀️",
        "climbing_man": "🧗‍♂️",
        "swimming_woman": "🏊‍♀️",
        "swimming_man": "🏊",
        "woman_playing_water_polo": "🤽‍♀️",
        "man_playing_water_polo": "🤽‍♂️",
        "woman_in_lotus_position": "🧘‍♀️",
        "man_in_lotus_position": "🧘‍♂️",
        "surfing_woman": "🏄‍♀️",
        "surfing_man": "🏄",
        "bath": "🛀",
        "basketball_woman": "⛹️‍♀️",
        "basketball_man": "⛹",
        "weight_lifting_woman": "🏋️‍♀️",
        "weight_lifting_man": "🏋",
        "biking_woman": "🚴‍♀️",
        "biking_man": "🚴",
        "mountain_biking_woman": "🚵‍♀️",
        "mountain_biking_man": "🚵",
        "horse_racing": "🏇",
        "business_suit_levitating": "🕴",
        "trophy": "🏆",
        "running_shirt_with_sash": "🎽",
        "medal_sports": "🏅",
        "medal_military": "🎖",
        "1st_place_medal": "🥇",
        "2nd_place_medal": "🥈",
        "3rd_place_medal": "🥉",
        "reminder_ribbon": "🎗",
        "rosette": "🏵",
        "ticket": "🎫",
        "tickets": "🎟",
        "performing_arts": "🎭",
        "art": "🎨",
        "circus_tent": "🎪",
        "woman_juggling": "🤹‍♀️",
        "man_juggling": "🤹‍♂️",
        "microphone": "🎤",
        "headphones": "🎧",
        "musical_score": "🎼",
        "musical_keyboard": "🎹",
        "drum": "🥁",
        "saxophone": "🎷",
        "trumpet": "🎺",
        "guitar": "🎸",
        "violin": "🎻",
        "clapper": "🎬",
        "video_game": "🎮",
        "space_invader": "👾",
        "dart": "🎯",
        "game_die": "🎲",
        "chess_pawn": "♟",
        "slot_machine": "🎰",
        "jigsaw": "🧩",
        "bowling": "🎳",
        "red_car": "🚗",
        "taxi": "🚕",
        "blue_car": "🚙",
        "bus": "🚌",
        "trolleybus": "🚎",
        "racing_car": "🏎",
        "police_car": "🚓",
        "ambulance": "🚑",
        "fire_engine": "🚒",
        "minibus": "🚐",
        "truck": "🚚",
        "articulated_lorry": "🚛",
        "tractor": "🚜",
        "kick_scooter": "🛴",
        "motorcycle": "🏍",
        "bike": "🚲",
        "motor_scooter": "🛵",
        "rotating_light": "🚨",
        "oncoming_police_car": "🚔",
        "oncoming_bus": "🚍",
        "oncoming_automobile": "🚘",
        "oncoming_taxi": "🚖",
        "aerial_tramway": "🚡",
        "mountain_cableway": "🚠",
        "suspension_railway": "🚟",
        "railway_car": "🚃",
        "train": "🚋",
        "monorail": "🚝",
        "bullettrain_side": "🚄",
        "bullettrain_front": "🚅",
        "light_rail": "🚈",
        "mountain_railway": "🚞",
        "steam_locomotive": "🚂",
        "train2": "🚆",
        "metro": "🚇",
        "tram": "🚊",
        "station": "🚉",
        "flying_saucer": "🛸",
        "helicopter": "🚁",
        "small_airplane": "🛩",
        "airplane": "✈️",
        "flight_departure": "🛫",
        "flight_arrival": "🛬",
        "sailboat": "⛵",
        "motor_boat": "🛥",
        "speedboat": "🚤",
        "ferry": "⛴",
        "passenger_ship": "🛳",
        "rocket": "🚀",
        "artificial_satellite": "🛰",
        "seat": "💺",
        "canoe": "🛶",
        "anchor": "⚓",
        "construction": "🚧",
        "fuelpump": "⛽",
        "busstop": "🚏",
        "vertical_traffic_light": "🚦",
        "traffic_light": "🚥",
        "checkered_flag": "🏁",
        "ship": "🚢",
        "ferris_wheel": "🎡",
        "roller_coaster": "🎢",
        "carousel_horse": "🎠",
        "building_construction": "🏗",
        "foggy": "🌁",
        "tokyo_tower": "🗼",
        "factory": "🏭",
        "fountain": "⛲",
        "rice_scene": "🎑",
        "mountain": "⛰",
        "mountain_snow": "🏔",
        "mount_fuji": "🗻",
        "volcano": "🌋",
        "japan": "🗾",
        "camping": "🏕",
        "tent": "⛺",
        "national_park": "🏞",
        "motorway": "🛣",
        "railway_track": "🛤",
        "sunrise": "🌅",
        "sunrise_over_mountains": "🌄",
        "desert": "🏜",
        "beach_umbrella": "🏖",
        "desert_island": "🏝",
        "city_sunrise": "🌇",
        "city_sunset": "🌆",
        "cityscape": "🏙",
        "night_with_stars": "🌃",
        "bridge_at_night": "🌉",
        "milky_way": "🌌",
        "stars": "🌠",
        "sparkler": "🎇",
        "fireworks": "🎆",
        "rainbow": "🌈",
        "houses": "🏘",
        "european_castle": "🏰",
        "japanese_castle": "🏯",
        "stadium": "🏟",
        "statue_of_liberty": "🗽",
        "house": "🏠",
        "house_with_garden": "🏡",
        "derelict_house": "🏚",
        "office": "🏢",
        "department_store": "🏬",
        "post_office": "🏣",
        "european_post_office": "🏤",
        "hospital": "🏥",
        "bank": "🏦",
        "hotel": "🏨",
        "convenience_store": "🏪",
        "school": "🏫",
        "love_hotel": "🏩",
        "wedding": "💒",
        "classical_building": "🏛",
        "church": "⛪",
        "mosque": "🕌",
        "synagogue": "🕍",
        "kaaba": "🕋",
        "shinto_shrine": "⛩",
        "watch": "⌚",
        "iphone": "📱",
        "calling": "📲",
        "computer": "💻",
        "keyboard": "⌨",
        "desktop_computer": "🖥",
        "printer": "🖨",
        "computer_mouse": "🖱",
        "trackball": "🖲",
        "joystick": "🕹",
        "clamp": "🗜",
        "minidisc": "💽",
        "floppy_disk": "💾",
        "cd": "💿",
        "dvd": "📀",
        "vhs": "📼",
        "camera": "📷",
        "camera_flash": "📸",
        "video_camera": "📹",
        "movie_camera": "🎥",
        "film_projector": "📽",
        "film_strip": "🎞",
        "telephone_receiver": "📞",
        "phone": "☎️",
        "pager": "📟",
        "fax": "📠",
        "tv": "📺",
        "radio": "📻",
        "studio_microphone": "🎙",
        "level_slider": "🎚",
        "control_knobs": "🎛",
        "compass": "🧭",
        "stopwatch": "⏱",
        "timer_clock": "⏲",
        "alarm_clock": "⏰",
        "mantelpiece_clock": "🕰",
        "hourglass_flowing_sand": "⏳",
        "hourglass": "⌛",
        "satellite": "📡",
        "battery": "🔋",
        "electric_plug": "🔌",
        "bulb": "💡",
        "flashlight": "🔦",
        "candle": "🕯",
        "fire_extinguisher": "🧯",
        "wastebasket": "🗑",
        "oil_drum": "🛢",
        "money_with_wings": "💸",
        "dollar": "💵",
        "yen": "💴",
        "euro": "💶",
        "pound": "💷",
        "moneybag": "💰",
        "credit_card": "💳",
        "gem": "💎",
        "balance_scale": "⚖",
        "toolbox": "🧰",
        "wrench": "🔧",
        "hammer": "🔨",
        "hammer_and_pick": "⚒",
        "hammer_and_wrench": "🛠",
        "pick": "⛏",
        "nut_and_bolt": "🔩",
        "gear": "⚙",
        "brick": "🧱",
        "chains": "⛓",
        "magnet": "🧲",
        "gun": "🔫",
        "bomb": "💣",
        "firecracker": "🧨",
        "hocho": "🔪",
        "dagger": "🗡",
        "crossed_swords": "⚔",
        "shield": "🛡",
        "smoking": "🚬",
        "skull_and_crossbones": "☠",
        "coffin": "⚰",
        "funeral_urn": "⚱",
        "amphora": "🏺",
        "crystal_ball": "🔮",
        "prayer_beads": "📿",
        "nazar_amulet": "🧿",
        "barber": "💈",
        "alembic": "⚗",
        "telescope": "🔭",
        "microscope": "🔬",
        "hole": "🕳",
        "pill": "💊",
        "syringe": "💉",
        "dna": "🧬",
        "microbe": "🦠",
        "petri_dish": "🧫",
        "test_tube": "🧪",
        "thermometer": "🌡",
        "broom": "🧹",
        "basket": "🧺",
        "toilet_paper": "🧻",
        "label": "🏷",
        "bookmark": "🔖",
        "toilet": "🚽",
        "shower": "🚿",
        "bathtub": "🛁",
        "soap": "🧼",
        "sponge": "🧽",
        "lotion_bottle": "🧴",
        "key": "🔑",
        "old_key": "🗝",
        "couch_and_lamp": "🛋",
        "sleeping_bed": "🛌",
        "bed": "🛏",
        "door": "🚪",
        "bellhop_bell": "🛎",
        "teddy_bear": "🧸",
        "framed_picture": "🖼",
        "world_map": "🗺",
        "parasol_on_ground": "⛱",
        "moyai": "🗿",
        "shopping": "🛍",
        "shopping_cart": "🛒",
        "balloon": "🎈",
        "flags": "🎏",
        "ribbon": "🎀",
        "gift": "🎁",
        "confetti_ball": "🎊",
        "tada": "🎉",
        "dolls": "🎎",
        "wind_chime": "🎐",
        "crossed_flags": "🎌",
        "izakaya_lantern": "🏮",
        "red_envelope": "🧧",
        "email": "✉️",
        "envelope_with_arrow": "📩",
        "incoming_envelope": "📨",
        "e-mail": "📧",
        "love_letter": "💌",
        "postbox": "📮",
        "mailbox_closed": "📪",
        "mailbox": "📫",
        "mailbox_with_mail": "📬",
        "mailbox_with_no_mail": "📭",
        "package": "📦",
        "postal_horn": "📯",
        "inbox_tray": "📥",
        "outbox_tray": "📤",
        "scroll": "📜",
        "page_with_curl": "📃",
        "bookmark_tabs": "📑",
        "receipt": "🧾",
        "bar_chart": "📊",
        "chart_with_upwards_trend": "📈",
        "chart_with_downwards_trend": "📉",
        "page_facing_up": "📄",
        "date": "📅",
        "calendar": "📆",
        "spiral_calendar": "🗓",
        "card_index": "📇",
        "card_file_box": "🗃",
        "ballot_box": "🗳",
        "file_cabinet": "🗄",
        "clipboard": "📋",
        "spiral_notepad": "🗒",
        "file_folder": "📁",
        "open_file_folder": "📂",
        "card_index_dividers": "🗂",
        "newspaper_roll": "🗞",
        "newspaper": "📰",
        "notebook": "📓",
        "closed_book": "📕",
        "green_book": "📗",
        "blue_book": "📘",
        "orange_book": "📙",
        "notebook_with_decorative_cover": "📔",
        "ledger": "📒",
        "books": "📚",
        "open_book": "📖",
        "safety_pin": "🧷",
        "link": "🔗",
        "paperclip": "📎",
        "paperclips": "🖇",
        "scissors": "✂️",
        "triangular_ruler": "📐",
        "straight_ruler": "📏",
        "abacus": "🧮",
        "pushpin": "📌",
        "round_pushpin": "📍",
        "triangular_flag_on_post": "🚩",
        "white_flag": "🏳",
        "black_flag": "🏴",
        "rainbow_flag": "🏳️‍🌈",
        "closed_lock_with_key": "🔐",
        "lock": "🔒",
        "unlock": "🔓",
        "lock_with_ink_pen": "🔏",
        "pen": "🖊",
        "fountain_pen": "🖋",
        "black_nib": "✒️",
        "memo": "📝",
        "pencil2": "✏️",
        "crayon": "🖍",
        "paintbrush": "🖌",
        "mag": "🔍",
        "mag_right": "🔎",
        "heart": "❤️",
        "orange_heart": "🧡",
        "yellow_heart": "💛",
        "green_heart": "💚",
        "blue_heart": "💙",
        "purple_heart": "💜",
        "black_heart": "🖤",
        "broken_heart": "💔",
        "heavy_heart_exclamation": "❣",
        "two_hearts": "💕",
        "revolving_hearts": "💞",
        "heartbeat": "💓",
        "heartpulse": "💗",
        "sparkling_heart": "💖",
        "cupid": "💘",
        "gift_heart": "💝",
        "heart_decoration": "💟",
        "peace_symbol": "☮",
        "latin_cross": "✝",
        "star_and_crescent": "☪",
        "om": "🕉",
        "wheel_of_dharma": "☸",
        "star_of_david": "✡",
        "six_pointed_star": "🔯",
        "menorah": "🕎",
        "yin_yang": "☯",
        "orthodox_cross": "☦",
        "place_of_worship": "🛐",
        "ophiuchus": "⛎",
        "aries": "♈",
        "taurus": "♉",
        "gemini": "♊",
        "cancer": "♋",
        "leo": "♌",
        "virgo": "♍",
        "libra": "♎",
        "scorpius": "♏",
        "sagittarius": "♐",
        "capricorn": "♑",
        "aquarius": "♒",
        "pisces": "♓",
        "id": "🆔",
        "atom_symbol": "⚛",
        "u7a7a": "🈳",
        "u5272": "🈹",
        "radioactive": "☢",
        "biohazard": "☣",
        "mobile_phone_off": "📴",
        "vibration_mode": "📳",
        "u6709": "🈶",
        "u7121": "🈚",
        "u7533": "🈸",
        "u55b6": "🈺",
        "u6708": "🈷️",
        "eight_pointed_black_star": "✴️",
        "vs": "🆚",
        "accept": "🉑",
        "white_flower": "💮",
        "ideograph_advantage": "🉐",
        "secret": "㊙️",
        "congratulations": "㊗️",
        "u5408": "🈴",
        "u6e80": "🈵",
        "u7981": "🈲",
        "a": "🅰️",
        "b": "🅱️",
        "ab": "🆎",
        "cl": "🆑",
        "o2": "🅾️",
        "sos": "🆘",
        "no_entry": "⛔",
        "name_badge": "📛",
        "no_entry_sign": "🚫",
        "x": "❌",
        "o": "⭕",
        "stop_sign": "🛑",
        "anger": "💢",
        "hotsprings": "♨️",
        "no_pedestrians": "🚷",
        "do_not_litter": "🚯",
        "no_bicycles": "🚳",
        "non-potable_water": "🚱",
        "underage": "🔞",
        "no_mobile_phones": "📵",
        "exclamation": "❗",
        "grey_exclamation": "❕",
        "question": "❓",
        "grey_question": "❔",
        "bangbang": "‼️",
        "interrobang": "⁉️",
        "low_brightness": "🔅",
        "high_brightness": "🔆",
        "trident": "🔱",
        "fleur_de_lis": "⚜",
        "part_alternation_mark": "〽️",
        "warning": "⚠️",
        "children_crossing": "🚸",
        "beginner": "🔰",
        "recycle": "♻️",
        "u6307": "🈯",
        "chart": "💹",
        "sparkle": "❇️",
        "eight_spoked_asterisk": "✳️",
        "negative_squared_cross_mark": "❎",
        "white_check_mark": "✅",
        "diamond_shape_with_a_dot_inside": "💠",
        "cyclone": "🌀",
        "loop": "➿",
        "globe_with_meridians": "🌐",
        "m": "Ⓜ️",
        "atm": "🏧",
        "sa": "🈂️",
        "passport_control": "🛂",
        "customs": "🛃",
        "baggage_claim": "🛄",
        "left_luggage": "🛅",
        "wheelchair": "♿",
        "no_smoking": "🚭",
        "wc": "🚾",
        "parking": "🅿️",
        "potable_water": "🚰",
        "mens": "🚹",
        "womens": "🚺",
        "baby_symbol": "🚼",
        "restroom": "🚻",
        "put_litter_in_its_place": "🚮",
        "cinema": "🎦",
        "signal_strength": "📶",
        "koko": "🈁",
        "ng": "🆖",
        "ok": "🆗",
        "up": "🆙",
        "cool": "🆒",
        "new": "🆕",
        "free": "🆓",
        "zero": "0️⃣",
        "one": "1️⃣",
        "two": "2️⃣",
        "three": "3️⃣",
        "four": "4️⃣",
        "five": "5️⃣",
        "six": "6️⃣",
        "seven": "7️⃣",
        "eight": "8️⃣",
        "nine": "9️⃣",
        "keycap_ten": "🔟",
        "asterisk": "*⃣",
        "eject_button": "⏏️",
        "arrow_forward": "▶️",
        "pause_button": "⏸",
        "next_track_button": "⏭",
        "stop_button": "⏹",
        "record_button": "⏺",
        "play_or_pause_button": "⏯",
        "previous_track_button": "⏮",
        "fast_forward": "⏩",
        "rewind": "⏪",
        "twisted_rightwards_arrows": "🔀",
        "repeat": "🔁",
        "repeat_one": "🔂",
        "arrow_backward": "◀️",
        "arrow_up_small": "🔼",
        "arrow_down_small": "🔽",
        "arrow_double_up": "⏫",
        "arrow_double_down": "⏬",
        "arrow_right": "➡️",
        "arrow_left": "⬅️",
        "arrow_up": "⬆️",
        "arrow_down": "⬇️",
        "arrow_upper_right": "↗️",
        "arrow_lower_right": "↘️",
        "arrow_lower_left": "↙️",
        "arrow_upper_left": "↖️",
        "arrow_up_down": "↕️",
        "left_right_arrow": "↔️",
        "arrows_counterclockwise": "🔄",
        "arrow_right_hook": "↪️",
        "leftwards_arrow_with_hook": "↩️",
        "arrow_heading_up": "⤴️",
        "arrow_heading_down": "⤵️",
        "hash": "#️⃣",
        "information_source": "ℹ️",
        "abc": "🔤",
        "abcd": "🔡",
        "capital_abcd": "🔠",
        "symbols": "🔣",
        "musical_note": "🎵",
        "notes": "🎶",
        "wavy_dash": "〰️",
        "curly_loop": "➰",
        "heavy_check_mark": "✔️",
        "arrows_clockwise": "🔃",
        "heavy_plus_sign": "➕",
        "heavy_minus_sign": "➖",
        "heavy_division_sign": "➗",
        "heavy_multiplication_x": "✖️",
        "infinity": "♾",
        "heavy_dollar_sign": "💲",
        "currency_exchange": "💱",
        "copyright": "©️",
        "registered": "®️",
        "tm": "™️",
        "end": "🔚",
        "back": "🔙",
        "on": "🔛",
        "top": "🔝",
        "soon": "🔜",
        "ballot_box_with_check": "☑️",
        "radio_button": "🔘",
        "white_circle": "⚪",
        "black_circle": "⚫",
        "red_circle": "🔴",
        "large_blue_circle": "🔵",
        "small_orange_diamond": "🔸",
        "small_blue_diamond": "🔹",
        "large_orange_diamond": "🔶",
        "large_blue_diamond": "🔷",
        "small_red_triangle": "🔺",
        "black_small_square": "▪️",
        "white_small_square": "▫️",
        "black_large_square": "⬛",
        "white_large_square": "⬜",
        "small_red_triangle_down": "🔻",
        "black_medium_square": "◼️",
        "white_medium_square": "◻️",
        "black_medium_small_square": "◾",
        "white_medium_small_square": "◽",
        "black_square_button": "🔲",
        "white_square_button": "🔳",
        "speaker": "🔈",
        "sound": "🔉",
        "loud_sound": "🔊",
        "mute": "🔇",
        "mega": "📣",
        "loudspeaker": "📢",
        "bell": "🔔",
        "no_bell": "🔕",
        "black_joker": "🃏",
        "mahjong": "🀄",
        "spades": "♠️",
        "clubs": "♣️",
        "hearts": "♥️",
        "diamonds": "♦️",
        "flower_playing_cards": "🎴",
        "thought_balloon": "💭",
        "right_anger_bubble": "🗯",
        "speech_balloon": "💬",
        "left_speech_bubble": "🗨",
        "clock1": "🕐",
        "clock2": "🕑",
        "clock3": "🕒",
        "clock4": "🕓",
        "clock5": "🕔",
        "clock6": "🕕",
        "clock7": "🕖",
        "clock8": "🕗",
        "clock9": "🕘",
        "clock10": "🕙",
        "clock11": "🕚",
        "clock12": "🕛",
        "clock130": "🕜",
        "clock230": "🕝",
        "clock330": "🕞",
        "clock430": "🕟",
        "clock530": "🕠",
        "clock630": "🕡",
        "clock730": "🕢",
        "clock830": "🕣",
        "clock930": "🕤",
        "clock1030": "🕥",
        "clock1130": "🕦",
        "clock1230": "🕧",
        "afghanistan": "🇦🇫",
        "aland_islands": "🇦🇽",
        "albania": "🇦🇱",
        "algeria": "🇩🇿",
        "american_samoa": "🇦🇸",
        "andorra": "🇦🇩",
        "angola": "🇦🇴",
        "anguilla": "🇦🇮",
        "antarctica": "🇦🇶",
        "antigua_barbuda": "🇦🇬",
        "argentina": "🇦🇷",
        "armenia": "🇦🇲",
        "aruba": "🇦🇼",
        "australia": "🇦🇺",
        "austria": "🇦🇹",
        "azerbaijan": "🇦🇿",
        "bahamas": "🇧🇸",
        "bahrain": "🇧🇭",
        "bangladesh": "🇧🇩",
        "barbados": "🇧🇧",
        "belarus": "🇧🇾",
        "belgium": "🇧🇪",
        "belize": "🇧🇿",
        "benin": "🇧🇯",
        "bermuda": "🇧🇲",
        "bhutan": "🇧🇹",
        "bolivia": "🇧🇴",
        "caribbean_netherlands": "🇧🇶",
        "bosnia_herzegovina": "🇧🇦",
        "botswana": "🇧🇼",
        "brazil": "🇧🇷",
        "british_indian_ocean_territory": "🇮🇴",
        "british_virgin_islands": "🇻🇬",
        "brunei": "🇧🇳",
        "bulgaria": "🇧🇬",
        "burkina_faso": "🇧🇫",
        "burundi": "🇧🇮",
        "cape_verde": "🇨🇻",
        "cambodia": "🇰🇭",
        "cameroon": "🇨🇲",
        "canada": "🇨🇦",
        "canary_islands": "🇮🇨",
        "cayman_islands": "🇰🇾",
        "central_african_republic": "🇨🇫",
        "chad": "🇹🇩",
        "chile": "🇨🇱",
        "cn": "🇨🇳",
        "christmas_island": "🇨🇽",
        "cocos_islands": "🇨🇨",
        "colombia": "🇨🇴",
        "comoros": "🇰🇲",
        "congo_brazzaville": "🇨🇬",
        "congo_kinshasa": "🇨🇩",
        "cook_islands": "🇨🇰",
        "costa_rica": "🇨🇷",
        "croatia": "🇭🇷",
        "cuba": "🇨🇺",
        "curacao": "🇨🇼",
        "cyprus": "🇨🇾",
        "czech_republic": "🇨🇿",
        "denmark": "🇩🇰",
        "djibouti": "🇩🇯",
        "dominica": "🇩🇲",
        "dominican_republic": "🇩🇴",
        "ecuador": "🇪🇨",
        "egypt": "🇪🇬",
        "el_salvador": "🇸🇻",
        "equatorial_guinea": "🇬🇶",
        "eritrea": "🇪🇷",
        "estonia": "🇪🇪",
        "ethiopia": "🇪🇹",
        "eu": "🇪🇺",
        "falkland_islands": "🇫🇰",
        "faroe_islands": "🇫🇴",
        "fiji": "🇫🇯",
        "finland": "🇫🇮",
        "fr": "🇫🇷",
        "french_guiana": "🇬🇫",
        "french_polynesia": "🇵🇫",
        "french_southern_territories": "🇹🇫",
        "gabon": "🇬🇦",
        "gambia": "🇬🇲",
        "georgia": "🇬🇪",
        "de": "🇩🇪",
        "ghana": "🇬🇭",
        "gibraltar": "🇬🇮",
        "greece": "🇬🇷",
        "greenland": "🇬🇱",
        "grenada": "🇬🇩",
        "guadeloupe": "🇬🇵",
        "guam": "🇬🇺",
        "guatemala": "🇬🇹",
        "guernsey": "🇬🇬",
        "guinea": "🇬🇳",
        "guinea_bissau": "🇬🇼",
        "guyana": "🇬🇾",
        "haiti": "🇭🇹",
        "honduras": "🇭🇳",
        "hong_kong": "🇭🇰",
        "hungary": "🇭🇺",
        "iceland": "🇮🇸",
        "india": "🇮🇳",
        "indonesia": "🇮🇩",
        "iran": "🇮🇷",
        "iraq": "🇮🇶",
        "ireland": "🇮🇪",
        "isle_of_man": "🇮🇲",
        "israel": "🇮🇱",
        "it": "🇮🇹",
        "cote_divoire": "🇨🇮",
        "jamaica": "🇯🇲",
        "jp": "🇯🇵",
        "jersey": "🇯🇪",
        "jordan": "🇯🇴",
        "kazakhstan": "🇰🇿",
        "kenya": "🇰🇪",
        "kiribati": "🇰🇮",
        "kosovo": "🇽🇰",
        "kuwait": "🇰🇼",
        "kyrgyzstan": "🇰🇬",
        "laos": "🇱🇦",
        "latvia": "🇱🇻",
        "lebanon": "🇱🇧",
        "lesotho": "🇱🇸",
        "liberia": "🇱🇷",
        "libya": "🇱🇾",
        "liechtenstein": "🇱🇮",
        "lithuania": "🇱🇹",
        "luxembourg": "🇱🇺",
        "macau": "🇲🇴",
        "macedonia": "🇲🇰",
        "madagascar": "🇲🇬",
        "malawi": "🇲🇼",
        "malaysia": "🇲🇾",
        "maldives": "🇲🇻",
        "mali": "🇲🇱",
        "malta": "🇲🇹",
        "marshall_islands": "🇲🇭",
        "martinique": "🇲🇶",
        "mauritania": "🇲🇷",
        "mauritius": "🇲🇺",
        "mayotte": "🇾🇹",
        "mexico": "🇲🇽",
        "micronesia": "🇫🇲",
        "moldova": "🇲🇩",
        "monaco": "🇲🇨",
        "mongolia": "🇲🇳",
        "montenegro": "🇲🇪",
        "montserrat": "🇲🇸",
        "morocco": "🇲🇦",
        "mozambique": "🇲🇿",
        "myanmar": "🇲🇲",
        "namibia": "🇳🇦",
        "nauru": "🇳🇷",
        "nepal": "🇳🇵",
        "netherlands": "🇳🇱",
        "new_caledonia": "🇳🇨",
        "new_zealand": "🇳🇿",
        "nicaragua": "🇳🇮",
        "niger": "🇳🇪",
        "nigeria": "🇳🇬",
        "niue": "🇳🇺",
        "norfolk_island": "🇳🇫",
        "northern_mariana_islands": "🇲🇵",
        "north_korea": "🇰🇵",
        "norway": "🇳🇴",
        "oman": "🇴🇲",
        "pakistan": "🇵🇰",
        "palau": "🇵🇼",
        "palestinian_territories": "🇵🇸",
        "panama": "🇵🇦",
        "papua_new_guinea": "🇵🇬",
        "paraguay": "🇵🇾",
        "peru": "🇵🇪",
        "philippines": "🇵🇭",
        "pitcairn_islands": "🇵🇳",
        "poland": "🇵🇱",
        "portugal": "🇵🇹",
        "puerto_rico": "🇵🇷",
        "qatar": "🇶🇦",
        "reunion": "🇷🇪",
        "romania": "🇷🇴",
        "ru": "🇷🇺",
        "rwanda": "🇷🇼",
        "st_barthelemy": "🇧🇱",
        "st_helena": "🇸🇭",
        "st_kitts_nevis": "🇰🇳",
        "st_lucia": "🇱🇨",
        "st_pierre_miquelon": "🇵🇲",
        "st_vincent_grenadines": "🇻🇨",
        "samoa": "🇼🇸",
        "san_marino": "🇸🇲",
        "sao_tome_principe": "🇸🇹",
        "saudi_arabia": "🇸🇦",
        "senegal": "🇸🇳",
        "serbia": "🇷🇸",
        "seychelles": "🇸🇨",
        "sierra_leone": "🇸🇱",
        "singapore": "🇸🇬",
        "sint_maarten": "🇸🇽",
        "slovakia": "🇸🇰",
        "slovenia": "🇸🇮",
        "solomon_islands": "🇸🇧",
        "somalia": "🇸🇴",
        "south_africa": "🇿🇦",
        "south_georgia_south_sandwich_islands": "🇬🇸",
        "kr": "🇰🇷",
        "south_sudan": "🇸🇸",
        "es": "🇪🇸",
        "sri_lanka": "🇱🇰",
        "sudan": "🇸🇩",
        "suriname": "🇸🇷",
        "swaziland": "🇸🇿",
        "sweden": "🇸🇪",
        "switzerland": "🇨🇭",
        "syria": "🇸🇾",
        "taiwan": "🇹🇼",
        "tajikistan": "🇹🇯",
        "tanzania": "🇹🇿",
        "thailand": "🇹🇭",
        "timor_leste": "🇹🇱",
        "togo": "🇹🇬",
        "tokelau": "🇹🇰",
        "tonga": "🇹🇴",
        "trinidad_tobago": "🇹🇹",
        "tunisia": "🇹🇳",
        "tr": "🇹🇷",
        "turkmenistan": "🇹🇲",
        "turks_caicos_islands": "🇹🇨",
        "tuvalu": "🇹🇻",
        "uganda": "🇺🇬",
        "ukraine": "🇺🇦",
        "united_arab_emirates": "🇦🇪",
        "uk": "🇬🇧",
        "england": "🏴󠁧󠁢󠁥󠁮󠁧󠁿",
        "scotland": "🏴󠁧󠁢󠁳󠁣󠁴󠁿",
        "wales": "🏴󠁧󠁢󠁷󠁬󠁳󠁿",
        "us": "🇺🇸",
        "us_virgin_islands": "🇻🇮",
        "uruguay": "🇺🇾",
        "uzbekistan": "🇺🇿",
        "vanuatu": "🇻🇺",
        "vatican_city": "🇻🇦",
        "venezuela": "🇻🇪",
        "vietnam": "🇻🇳",
        "wallis_futuna": "🇼🇫",
        "western_sahara": "🇪🇭",
        "yemen": "🇾🇪",
        "zambia": "🇿🇲",
        "zimbabwe": "🇿🇼",
        "united_nations": "🇺🇳",
        "pirate_flag": "🏴‍☠️"
      };
      /***/
    },

    /***/
    "FkM1":
    /*!***************************************!*\
      !*** ./prism/src/lib/prism.module.ts ***!
      \***************************************/

    /*! exports provided: PrismModule */

    /***/
    function FkM1(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "PrismModule", function () {
        return PrismModule;
      });
      /* harmony import */


      var _prism_manual_mode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./prism-manual-mode */
      "Smp3");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /* harmony import */


      var _prism_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! ./prism.service */
      "fhd8");
      /* harmony import */


      var _highlighter_highlighter_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! ./highlighter/highlighter.component */
      "Cj6Q");
      /* harmony import */


      var _tokenizer_tokenizer_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! ./tokenizer/tokenizer.component */
      "XJsG");
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! @angular/common */
      "SVse");

      var PrismModule = /*#__PURE__*/function () {
        function PrismModule() {
          _classCallCheck(this, PrismModule);
        }

        _createClass(PrismModule, null, [{
          key: "init",
          value:
          /** Initializes the PrismModule with extra language loaders */
          function init(languages) {
            return {
              ngModule: PrismModule,
              providers: [{
                provide: _prism_service__WEBPACK_IMPORTED_MODULE_2__["LANGUAGE_MODULES"],
                useValue: languages
              }]
            };
          }
        }]);

        return PrismModule;
      }();

      PrismModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
        type: PrismModule
      });
      PrismModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
        factory: function PrismModule_Factory(t) {
          return new (t || PrismModule)();
        },
        providers: [_prism_service__WEBPACK_IMPORTED_MODULE_2__["PrismService"]],
        imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"]]]
      });

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](PrismModule, {
          declarations: [_highlighter_highlighter_component__WEBPACK_IMPORTED_MODULE_3__["PrismHighlighter"], _tokenizer_tokenizer_component__WEBPACK_IMPORTED_MODULE_4__["PrismTokenizer"]],
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"]],
          exports: [_highlighter_highlighter_component__WEBPACK_IMPORTED_MODULE_3__["PrismHighlighter"]]
        });
      })();
      /***/

    },

    /***/
    "Gdbo":
    /*!************************************!*\
      !*** ./node_modules/bail/index.js ***!
      \************************************/

    /*! no static exports found */

    /***/
    function Gdbo(module, exports, __webpack_require__) {
      "use strict";

      module.exports = bail;

      function bail(err) {
        if (err) {
          throw err;
        }
      }
      /***/

    },

    /***/
    "Gqj6":
    /*!***************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/code-fenced.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function Gqj6(module, exports, __webpack_require__) {
      "use strict";

      module.exports = fencedCode;
      var lineFeed = '\n';
      var tab = '\t';
      var space = ' ';
      var tilde = '~';
      var graveAccent = '`';
      var minFenceCount = 3;
      var tabSize = 4;

      function fencedCode(eat, value, silent) {
        var self = this;
        var gfm = self.options.gfm;
        var length = value.length + 1;
        var index = 0;
        var subvalue = '';
        var fenceCount;
        var marker;
        var character;
        var flag;
        var lang;
        var meta;
        var queue;
        var content;
        var exdentedContent;
        var closing;
        var exdentedClosing;
        var indent;
        var now;

        if (!gfm) {
          return;
        } // Eat initial spacing.


        while (index < length) {
          character = value.charAt(index);

          if (character !== space && character !== tab) {
            break;
          }

          subvalue += character;
          index++;
        }

        indent = index; // Eat the fence.

        character = value.charAt(index);

        if (character !== tilde && character !== graveAccent) {
          return;
        }

        index++;
        marker = character;
        fenceCount = 1;
        subvalue += character;

        while (index < length) {
          character = value.charAt(index);

          if (character !== marker) {
            break;
          }

          subvalue += character;
          fenceCount++;
          index++;
        }

        if (fenceCount < minFenceCount) {
          return;
        } // Eat spacing before flag.


        while (index < length) {
          character = value.charAt(index);

          if (character !== space && character !== tab) {
            break;
          }

          subvalue += character;
          index++;
        } // Eat flag.


        flag = '';
        queue = '';

        while (index < length) {
          character = value.charAt(index);

          if (character === lineFeed || marker === graveAccent && character === marker) {
            break;
          }

          if (character === space || character === tab) {
            queue += character;
          } else {
            flag += queue + character;
            queue = '';
          }

          index++;
        }

        character = value.charAt(index);

        if (character && character !== lineFeed) {
          return;
        }

        if (silent) {
          return true;
        }

        now = eat.now();
        now.column += subvalue.length;
        now.offset += subvalue.length;
        subvalue += flag;
        flag = self.decode.raw(self.unescape(flag), now);

        if (queue) {
          subvalue += queue;
        }

        queue = '';
        closing = '';
        exdentedClosing = '';
        content = '';
        exdentedContent = '';
        var skip = true; // Eat content.

        while (index < length) {
          character = value.charAt(index);
          content += closing;
          exdentedContent += exdentedClosing;
          closing = '';
          exdentedClosing = '';

          if (character !== lineFeed) {
            content += character;
            exdentedClosing += character;
            index++;
            continue;
          } // The first line feed is ignored. Others aren’t.


          if (skip) {
            subvalue += character;
            skip = false;
          } else {
            closing += character;
            exdentedClosing += character;
          }

          queue = '';
          index++;

          while (index < length) {
            character = value.charAt(index);

            if (character !== space) {
              break;
            }

            queue += character;
            index++;
          }

          closing += queue;
          exdentedClosing += queue.slice(indent);

          if (queue.length >= tabSize) {
            continue;
          }

          queue = '';

          while (index < length) {
            character = value.charAt(index);

            if (character !== marker) {
              break;
            }

            queue += character;
            index++;
          }

          closing += queue;
          exdentedClosing += queue;

          if (queue.length < fenceCount) {
            continue;
          }

          queue = '';

          while (index < length) {
            character = value.charAt(index);

            if (character !== space && character !== tab) {
              break;
            }

            closing += character;
            exdentedClosing += character;
            index++;
          }

          if (!character || character === lineFeed) {
            break;
          }
        }

        subvalue += content + closing; // Get lang and meta from the flag.

        index = -1;
        length = flag.length;

        while (++index < length) {
          character = flag.charAt(index);

          if (character === space || character === tab) {
            if (!lang) {
              lang = flag.slice(0, index);
            }
          } else if (lang) {
            meta = flag.slice(index);
            break;
          }
        }

        return eat(subvalue)({
          type: 'code',
          lang: lang || flag || null,
          meta: meta || null,
          value: exdentedContent
        });
      }
      /***/

    },

    /***/
    "HRR4":
    /*!**************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/definition.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function HRR4(module, exports, __webpack_require__) {
      "use strict";

      var whitespace = __webpack_require__(
      /*! is-whitespace-character */
      "IPAr");

      var normalize = __webpack_require__(
      /*! ../util/normalize */
      "kaWx");

      module.exports = definition;
      var quotationMark = '"';
      var apostrophe = "'";
      var backslash = '\\';
      var lineFeed = '\n';
      var tab = '\t';
      var space = ' ';
      var leftSquareBracket = '[';
      var rightSquareBracket = ']';
      var leftParenthesis = '(';
      var rightParenthesis = ')';
      var colon = ':';
      var lessThan = '<';
      var greaterThan = '>';

      function definition(eat, value, silent) {
        var self = this;
        var commonmark = self.options.commonmark;
        var index = 0;
        var length = value.length;
        var subvalue = '';
        var beforeURL;
        var beforeTitle;
        var queue;
        var character;
        var test;
        var identifier;
        var url;
        var title;

        while (index < length) {
          character = value.charAt(index);

          if (character !== space && character !== tab) {
            break;
          }

          subvalue += character;
          index++;
        }

        character = value.charAt(index);

        if (character !== leftSquareBracket) {
          return;
        }

        index++;
        subvalue += character;
        queue = '';

        while (index < length) {
          character = value.charAt(index);

          if (character === rightSquareBracket) {
            break;
          } else if (character === backslash) {
            queue += character;
            index++;
            character = value.charAt(index);
          }

          queue += character;
          index++;
        }

        if (!queue || value.charAt(index) !== rightSquareBracket || value.charAt(index + 1) !== colon) {
          return;
        }

        identifier = queue;
        subvalue += queue + rightSquareBracket + colon;
        index = subvalue.length;
        queue = '';

        while (index < length) {
          character = value.charAt(index);

          if (character !== tab && character !== space && character !== lineFeed) {
            break;
          }

          subvalue += character;
          index++;
        }

        character = value.charAt(index);
        queue = '';
        beforeURL = subvalue;

        if (character === lessThan) {
          index++;

          while (index < length) {
            character = value.charAt(index);

            if (!isEnclosedURLCharacter(character)) {
              break;
            }

            queue += character;
            index++;
          }

          character = value.charAt(index);

          if (character === isEnclosedURLCharacter.delimiter) {
            subvalue += lessThan + queue + character;
            index++;
          } else {
            if (commonmark) {
              return;
            }

            index -= queue.length + 1;
            queue = '';
          }
        }

        if (!queue) {
          while (index < length) {
            character = value.charAt(index);

            if (!isUnclosedURLCharacter(character)) {
              break;
            }

            queue += character;
            index++;
          }

          subvalue += queue;
        }

        if (!queue) {
          return;
        }

        url = queue;
        queue = '';

        while (index < length) {
          character = value.charAt(index);

          if (character !== tab && character !== space && character !== lineFeed) {
            break;
          }

          queue += character;
          index++;
        }

        character = value.charAt(index);
        test = null;

        if (character === quotationMark) {
          test = quotationMark;
        } else if (character === apostrophe) {
          test = apostrophe;
        } else if (character === leftParenthesis) {
          test = rightParenthesis;
        }

        if (!test) {
          queue = '';
          index = subvalue.length;
        } else if (queue) {
          subvalue += queue + character;
          index = subvalue.length;
          queue = '';

          while (index < length) {
            character = value.charAt(index);

            if (character === test) {
              break;
            }

            if (character === lineFeed) {
              index++;
              character = value.charAt(index);

              if (character === lineFeed || character === test) {
                return;
              }

              queue += lineFeed;
            }

            queue += character;
            index++;
          }

          character = value.charAt(index);

          if (character !== test) {
            return;
          }

          beforeTitle = subvalue;
          subvalue += queue + character;
          index++;
          title = queue;
          queue = '';
        } else {
          return;
        }

        while (index < length) {
          character = value.charAt(index);

          if (character !== tab && character !== space) {
            break;
          }

          subvalue += character;
          index++;
        }

        character = value.charAt(index);

        if (!character || character === lineFeed) {
          if (silent) {
            return true;
          }

          beforeURL = eat(beforeURL).test().end;
          url = self.decode.raw(self.unescape(url), beforeURL, {
            nonTerminated: false
          });

          if (title) {
            beforeTitle = eat(beforeTitle).test().end;
            title = self.decode.raw(self.unescape(title), beforeTitle);
          }

          return eat(subvalue)({
            type: 'definition',
            identifier: normalize(identifier),
            label: identifier,
            title: title || null,
            url: url
          });
        }
      } // Check if `character` can be inside an enclosed URI.


      function isEnclosedURLCharacter(character) {
        return character !== greaterThan && character !== leftSquareBracket && character !== rightSquareBracket;
      }

      isEnclosedURLCharacter.delimiter = greaterThan; // Check if `character` can be inside an unclosed URI.

      function isUnclosedURLCharacter(character) {
        return character !== leftSquareBracket && character !== rightSquareBracket && !whitespace(character);
      }
      /***/

    },

    /***/
    "IOn0":
    /*!*********************************************************!*\
      !*** ./wizdm/src/app/pages/static/toc/toc.component.ts ***!
      \*********************************************************/

    /*! exports provided: TocComponent */

    /***/
    function IOn0(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "TocComponent", function () {
        return TocComponent;
      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /* harmony import */


      var _toc_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./toc.animations */
      "OhU7");
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/common */
      "SVse");
      /* harmony import */


      var _angular_material_button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @angular/material/button */
      "Dxy4");
      /* harmony import */


      var _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! @angular/flex-layout/flex */
      "VDRc");
      /* harmony import */


      var _angular_material_icon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! @angular/material/icon */
      "Tj54");

      var _c0 = ["wm-toc", ""];

      function TocComponent_ng_container_0_mat_icon_5_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "mat-icon", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1, "chevron_right");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var item_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("opened", ctx_r2.isOpened(item_r1));
        }
      }

      function TocComponent_ng_container_0_div_6_Template(rf, ctx) {
        if (rf & 1) {
          var _r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("selectedChange", function TocComponent_ng_container_0_div_6_Template_div_selectedChange_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r6);

            var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r5.selected = $event;
          })("navigate", function TocComponent_ng_container_0_div_6_Template_div_navigate_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r6);

            var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r7.navigate.emit($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var item_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("wm-toc", item_r1.items)("color", ctx_r3.color)("selected", ctx_r3.selected)("@topic", undefined);
        }
      }

      function TocComponent_ng_container_0_Template(rf, ctx) {
        if (rf & 1) {
          var _r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "button", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function TocComponent_ng_container_0_Template_button_click_1_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

            var item_r1 = ctx.$implicit;

            var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r9.onItemClick(item_r1);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "span", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "span", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, TocComponent_ng_container_0_mat_icon_5_Template, 2, 2, "mat-icon", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](6, TocComponent_ng_container_0_div_6_Template, 1, 4, "div", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var item_r1 = ctx.$implicit;

          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("color", ctx_r0.hasSelection(item_r1) ? ctx_r0.color : "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("padding-left", ctx_r0.indent, "px");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](item_r1.label);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r0.hasItems(item_r1));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r0.isOpened(item_r1));
        }
      }

      var TocComponent = /*#__PURE__*/function () {
        // Injects the parent TocComponent, if any, to compute the indentation level accordingly
        function TocComponent(parent) {
          _classCallCheck(this, TocComponent);

          this.parent = parent;
          /** Active link highlighting color */

          this.color = 'accent';
          /** Emits the currently selected item */

          this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
          /** Emits the target link when clicking on a navigation item */

          this.navigate = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        }
        /** Returns the indentation level in pixels */


        _createClass(TocComponent, [{
          key: "indent",
          get: function get() {
            return !!this.parent ? this.parent.indent + 24 : 0;
          }
          /** The currently selected item */

        }, {
          key: "selected",
          get: function get() {
            return this._selected;
          }
          /** The toc items at this level */
          ,
          set:
          /** Selects the given item */
          function set(item) {
            var _this3 = this;

            var _a; // Skips useless updates


            if (this._selected === item) {
              return;
            } // Updates the selection


            this.selectedChange.emit(this._selected = item); // Ensures the panels open whenever a children is currently selected

            (_a = this.items) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {
              return _this3.hasSelection(item) && _this3.open(item);
            });
          }
          /** Builds a linear index from the toc tree */

        }, {
          key: "items",
          get: function get() {
            return this._items;
          }
          /** The linear toc index  */
          ,
          set:
          /** The toc items to render */
          function set(items) {
            // Computes the linear index while storing the input
            this._index = this.buildIndex(this._items = items);
          }
          /** Selects the toc item by the page */

        }, {
          key: "index",
          get: function get() {
            return this._index || [];
          }
          /** Moves the selection to the previous or the next page according to dir*/

        }, {
          key: "go",
          value: function go(dir) {
            this.selected = dir === 'prev' ? this.previousPage() : this.nextPage();
            /** Emits the navigation link, if any */

            this.navigate.emit(this.selected.link);
          }
        }, {
          key: "path",
          set: function set(path) {
            // Seeks for the page from the index
            this.selected = this.findPage(path);
          }
        }, {
          key: "buildIndex",
          value: function buildIndex(items) {
            var _this4 = this;

            // Skips to the parent index
            if (!!this.parent) {
              return this.parent.index;
            } // Computes the index otherwise


            return items && items.reduce(function (index, item) {
              // Concatenates the index from the next level
              if ('items' in item) {
                return index.concat(_this4.buildIndex(item.items));
              } // Pusches the item


              return index.push(item), index;
            }, []);
          }
          /** Returns the requested page */

        }, {
          key: "findPage",
          value: function findPage(path) {
            // Seeks for the page within the linear index
            return this.index.find(function (item) {
              return item.link && item.link.endsWith(path);
            });
          }
          /** Returns the next page from the given position */

        }, {
          key: "nextPage",
          value: function nextPage() {
            var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selected;
            // Seeks for the next page from the linear index
            return this.index[this.index.findIndex(function (item) {
              return item === from;
            }) + 1] || this.index[0];
          }
          /** Returns the preceeding page from the given position */

        }, {
          key: "previousPage",
          value: function previousPage() {
            var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selected;
            // Seeks for the previous page from the linear index
            return this.index[this.index.findIndex(function (item) {
              return item === from;
            }) - 1] || this.index[this.index.length - 1];
          }
          /** Updates the selection upon click */

        }, {
          key: "onItemClick",
          value: function onItemClick(item) {
            // Toggles the panel opened/closed
            this.open(item, !this.isOpened(item));
            /** Emits the navigation link, if any */

            if ('link' in item) {
              this.navigate.emit(item.link);
            }
          }
          /** Returns true when the given item has sub items, false otherwise */

        }, {
          key: "hasItems",
          value: function hasItems(item) {
            return 'items' in item;
          }
          /** Returns the array of sub items */

        }, {
          key: "subItems",
          value: function subItems(item) {
            return 'items' in item && item.items || [];
          }
          /** Opens/Closes the sub items panel, if any */

        }, {
          key: "open",
          value: function open(item) {
            var _open = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            if (this.hasItems(item)) {
              item.opened = _open;
            }
          }
          /** Returns true whenever the sub items panel is opened */

        }, {
          key: "isOpened",
          value: function isOpened(item) {
            return this.hasItems(item) && !!item.opened;
          }
          /** Returns true whenever the item or one of the sub itms is actually selected */

        }, {
          key: "hasSelection",
          value: function hasSelection(item) {
            var _this5 = this;

            return item === this._selected || this.subItems(item).some(function (sub) {
              return _this5.hasSelection(sub);
            });
          }
        }]);

        return TocComponent;
      }();

      TocComponent.ɵfac = function TocComponent_Factory(t) {
        return new (t || TocComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](TocComponent, 12));
      };

      TocComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: TocComponent,
        selectors: [["", "wm-toc", ""]],
        inputs: {
          items: ["wm-toc", "items"],
          color: "color",
          path: "path",
          selected: "selected"
        },
        outputs: {
          selectedChange: "selectedChange",
          navigate: "navigate"
        },
        attrs: _c0,
        decls: 1,
        vars: 1,
        consts: [[4, "ngFor", "ngForOf"], ["mat-button", "", 1, "w100", "selected", 3, "color", "click"], ["fxLayout", "row", "fxLayoutAlign", "space-between center"], ["fxFlex", "1 1 auto"], ["fxFlex", "0 0 auto", 3, "opened", 4, "ngIf"], ["class", "w100", 3, "wm-toc", "color", "selected", "selectedChange", "navigate", 4, "ngIf"], ["fxFlex", "0 0 auto"], [1, "w100", 3, "wm-toc", "color", "selected", "selectedChange", "navigate"]],
        template: function TocComponent_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, TocComponent_ng_container_0_Template, 7, 6, "ng-container", 0);
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.items);
          }
        },
        directives: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["NgForOf"], _angular_material_button__WEBPACK_IMPORTED_MODULE_3__["MatButton"], _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["DefaultLayoutDirective"], _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["DefaultLayoutAlignDirective"], _angular_flex_layout_flex__WEBPACK_IMPORTED_MODULE_4__["DefaultFlexDirective"], _angular_common__WEBPACK_IMPORTED_MODULE_2__["NgIf"], _angular_material_icon__WEBPACK_IMPORTED_MODULE_5__["MatIcon"], TocComponent],
        styles: ["[_nghost-%COMP%] {\n  display: flex;\n  flex-direction: column;\n  min-width: 250px;\n}\n[_nghost-%COMP%]   .w100[_ngcontent-%COMP%] {\n  width: 100%;\n}\n[_nghost-%COMP%]   .selected[_ngcontent-%COMP%] {\n  border: none;\n}\n[_nghost-%COMP%]   .mat-button[_ngcontent-%COMP%] {\n  height: 48px;\n  text-align: start;\n}\n[_nghost-%COMP%]   .mat-icon[_ngcontent-%COMP%] {\n  transition: transform 150ms ease;\n}\n[_nghost-%COMP%]   .mat-icon.opened[_ngcontent-%COMP%] {\n  transform: rotateZ(90deg);\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RvYy5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUVFLGFBQUE7RUFDQSxzQkFBQTtFQUVBLGdCQUFBO0FBREY7QUFHRTtFQUFRLFdBQUE7QUFBVjtBQUdFO0VBQVksWUFBQTtBQUFkO0FBR0U7RUFDRSxZQUFBO0VBQ0EsaUJBQUE7QUFESjtBQUtFO0VBQ0UsZ0NBQUE7QUFISjtBQUlJO0VBQVcseUJBQUE7QUFEZiIsImZpbGUiOiJ0b2MuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyI6aG9zdCB7XG5cbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblxuICBtaW4td2lkdGg6IDI1MHB4O1xuXG4gIC53MTAwIHsgd2lkdGg6IDEwMCU7IH1cblxuICAvLyBPdmVycmlkZXMgdGhlIGdlbmVyYWwgc2VsZWN0aW9uIHRoZW1lIHRvIHJlbW92ZSB0aGUgYm9yZGVyXG4gIC5zZWxlY3RlZCB7IGJvcmRlcjogbm9uZTsgfVxuXG4gIC8vIEN1c3RvbWl6ZXMgdGhlIGJ1dHRvblxuICAubWF0LWJ1dHRvbiB7IFxuICAgIGhlaWdodDogNDhweDsgXG4gICAgdGV4dC1hbGlnbjogc3RhcnQ7XG4gIH1cblxuICAvLyBBbmltYXRlcyB0aGUgY2hldnJvbiBpY29uXG4gIC5tYXQtaWNvbiB7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDE1MG1zIGVhc2U7XG4gICAgJi5vcGVuZWQgeyB0cmFuc2Zvcm06IHJvdGF0ZVooOTBkZWcpOyB9XG4gIH1cbn0iXX0= */"],
        data: {
          animation: _toc_animations__WEBPACK_IMPORTED_MODULE_1__["$animations"]
        }
      });
      /***/
    },

    /***/
    "IPAr":
    /*!*******************************************************!*\
      !*** ./node_modules/is-whitespace-character/index.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function IPAr(module, exports, __webpack_require__) {
      "use strict";

      module.exports = whitespace;
      var fromCode = String.fromCharCode;
      var re = /\s/; // Check if the given character code, or the character code at the first
      // character, is a whitespace character.

      function whitespace(character) {
        return re.test(typeof character === 'number' ? fromCode(character) : character.charAt(0));
      }
      /***/

    },

    /***/
    "Ivzr":
    /*!*********************************************************!*\
      !*** ./node_modules/remark-parse/lib/block-elements.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function Ivzr(module, exports, __webpack_require__) {
      "use strict";

      module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'pre', 'section', 'source', 'title', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];
      /***/
    },

    /***/
    "J5yW":
    /*!*************************************************!*\
      !*** ./node_modules/is-alphanumerical/index.js ***!
      \*************************************************/

    /*! no static exports found */

    /***/
    function J5yW(module, exports, __webpack_require__) {
      "use strict";

      var alphabetical = __webpack_require__(
      /*! is-alphabetical */
      "1iAE");

      var decimal = __webpack_require__(
      /*! is-decimal */
      "ZONP");

      module.exports = alphanumerical; // Check if the given character code, or the character code at the first
      // character, is alphanumerical.

      function alphanumerical(character) {
        return alphabetical(character) || decimal(character);
      }
      /***/

    },

    /***/
    "JZ3d":
    /*!*********************************************!*\
      !*** ./markdown/src/lib/markdown.module.ts ***!
      \*********************************************/

    /*! exports provided: MarkdownModule */

    /***/
    function JZ3d(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "MarkdownModule", function () {
        return MarkdownModule;
      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/common */
      "SVse");
      /* harmony import */


      var _wizdm_prism__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @wizdm/prism */
      "6lw0");
      /* harmony import */


      var _wizdm_emoji_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @wizdm/emoji/text */
      "WIkw");
      /* harmony import */


      var _wizdm_emoji_names__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! @wizdm/emoji/names */
      "RnBS");
      /* harmony import */


      var _markdown_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! ./markdown.component */
      "xbVm");
      /* harmony import */


      var _block_block_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
      /*! ./block/block.component */
      "bspj");
      /* harmony import */


      var _inline_inline_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
      /*! ./inline/inline.component */
      "qCv1");
      /* harmony import */


      var _markdown_config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
      /*! ./markdown-config */
      "wagW");
      /* harmony import */


      var _reparse_factory__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
      /*! ./reparse-factory */
      "88mA");
      /* harmony import */


      var _reparse_factory__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_reparse_factory__WEBPACK_IMPORTED_MODULE_9__);
      /* harmony import */


      var _prism_src_lib_highlighter_highlighter_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
      /*! ../../../prism/src/lib/highlighter/highlighter.component */
      "Cj6Q");

      var MarkdownModule = /*#__PURE__*/function () {
        function MarkdownModule() {
          _classCallCheck(this, MarkdownModule);
        }

        _createClass(MarkdownModule, null, [{
          key: "init",
          value: function init(config) {
            return {
              ngModule: MarkdownModule,
              providers: [{
                provide: _markdown_config__WEBPACK_IMPORTED_MODULE_8__["mdConfigToken"],
                useValue: config
              }, {
                provide: 'reparse',
                useFactory: _reparse_factory__WEBPACK_IMPORTED_MODULE_9__["reparseFactory"],
                deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"](_markdown_config__WEBPACK_IMPORTED_MODULE_8__["mdConfigToken"])]]
              }]
            };
          }
        }]);

        return MarkdownModule;
      }();

      MarkdownModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
        type: MarkdownModule
      });
      MarkdownModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
        factory: function MarkdownModule_Factory(t) {
          return new (t || MarkdownModule)();
        },
        imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _wizdm_prism__WEBPACK_IMPORTED_MODULE_2__["PrismModule"], _wizdm_emoji_text__WEBPACK_IMPORTED_MODULE_3__["EmojiTextModule"], _wizdm_emoji_names__WEBPACK_IMPORTED_MODULE_4__["EmojiNamesModule"]]]
      });

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](MarkdownModule, {
          declarations: [_markdown_component__WEBPACK_IMPORTED_MODULE_5__["MarkdownRoot"], _inline_inline_component__WEBPACK_IMPORTED_MODULE_7__["MarkdownInline"], _block_block_component__WEBPACK_IMPORTED_MODULE_6__["MarkdownBlock"]],
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _wizdm_prism__WEBPACK_IMPORTED_MODULE_2__["PrismModule"], _wizdm_emoji_text__WEBPACK_IMPORTED_MODULE_3__["EmojiTextModule"], _wizdm_emoji_names__WEBPACK_IMPORTED_MODULE_4__["EmojiNamesModule"]],
          exports: [_markdown_component__WEBPACK_IMPORTED_MODULE_5__["MarkdownRoot"]]
        });
      })();

      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetComponentScope"](_markdown_component__WEBPACK_IMPORTED_MODULE_5__["MarkdownRoot"], [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgForOf"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitch"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchCase"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], _inline_inline_component__WEBPACK_IMPORTED_MODULE_7__["MarkdownInline"], _block_block_component__WEBPACK_IMPORTED_MODULE_6__["MarkdownBlock"], _prism_src_lib_highlighter_highlighter_component__WEBPACK_IMPORTED_MODULE_10__["PrismHighlighter"]], []);

      _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetComponentScope"](_block_block_component__WEBPACK_IMPORTED_MODULE_6__["MarkdownBlock"], [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgForOf"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitch"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchCase"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], _inline_inline_component__WEBPACK_IMPORTED_MODULE_7__["MarkdownInline"], _block_block_component__WEBPACK_IMPORTED_MODULE_6__["MarkdownBlock"], _prism_src_lib_highlighter_highlighter_component__WEBPACK_IMPORTED_MODULE_10__["PrismHighlighter"]], []);
      /***/

    },

    /***/
    "JlFY":
    /*!***************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/code-inline.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function JlFY(module, exports, __webpack_require__) {
      "use strict";

      var locate = __webpack_require__(
      /*! ../locate/code-inline */
      "Brp5");

      module.exports = inlineCode;
      inlineCode.locator = locate;
      var lineFeed = 10; //  '\n'

      var space = 32; // ' '

      var graveAccent = 96; //  '`'

      function inlineCode(eat, value, silent) {
        var length = value.length;
        var index = 0;
        var openingFenceEnd;
        var closingFenceStart;
        var closingFenceEnd;
        var code;
        var next;
        var found;

        while (index < length) {
          if (value.charCodeAt(index) !== graveAccent) {
            break;
          }

          index++;
        }

        if (index === 0 || index === length) {
          return;
        }

        openingFenceEnd = index;
        next = value.charCodeAt(index);

        while (index < length) {
          code = next;
          next = value.charCodeAt(index + 1);

          if (code === graveAccent) {
            if (closingFenceStart === undefined) {
              closingFenceStart = index;
            }

            closingFenceEnd = index + 1;

            if (next !== graveAccent && closingFenceEnd - closingFenceStart === openingFenceEnd) {
              found = true;
              break;
            }
          } else if (closingFenceStart !== undefined) {
            closingFenceStart = undefined;
            closingFenceEnd = undefined;
          }

          index++;
        }

        if (!found) {
          return;
        }
        /* istanbul ignore if - never used (yet) */


        if (silent) {
          return true;
        } // Remove the initial and final space (or line feed), iff they exist and there
        // are non-space characters in the content.


        index = openingFenceEnd;
        length = closingFenceStart;
        code = value.charCodeAt(index);
        next = value.charCodeAt(length - 1);
        found = false;

        if (length - index > 2 && (code === space || code === lineFeed) && (next === space || next === lineFeed)) {
          index++;
          length--;

          while (index < length) {
            code = value.charCodeAt(index);

            if (code !== space && code !== lineFeed) {
              found = true;
              break;
            }

            index++;
          }

          if (found === true) {
            openingFenceEnd++;
            closingFenceStart--;
          }
        }

        return eat(value.slice(0, closingFenceEnd))({
          type: 'inlineCode',
          value: value.slice(openingFenceEnd, closingFenceStart)
        });
      }
      /***/

    },

    /***/
    "JqBK":
    /*!****************************************************!*\
      !*** ./node_modules/collapse-white-space/index.js ***!
      \****************************************************/

    /*! no static exports found */

    /***/
    function JqBK(module, exports, __webpack_require__) {
      "use strict";

      module.exports = collapse; // `collapse(' \t\nbar \nbaz\t') // ' bar baz '`

      function collapse(value) {
        return String(value).replace(/\s+/g, ' ');
      }
      /***/

    },

    /***/
    "JtLf":
    /*!***********************************************************!*\
      !*** ./wizdm/src/app/navigator/sidenav/sidenav.module.ts ***!
      \***********************************************************/

    /*! exports provided: SidenavModule */

    /***/
    function JtLf(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "SidenavModule", function () {
        return SidenavModule;
      });
      /* harmony import */


      var _sidenav_directive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./sidenav.directive */
      "++Qg");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");

      var SidenavModule = function SidenavModule() {
        _classCallCheck(this, SidenavModule);
      };

      SidenavModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
        type: SidenavModule
      });
      SidenavModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
        factory: function SidenavModule_Factory(t) {
          return new (t || SidenavModule)();
        },
        imports: [[//TeleportModule
        ]]
      });

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](SidenavModule, {
          declarations: [_sidenav_directive__WEBPACK_IMPORTED_MODULE_0__["SidenavDirective"]],
          exports: [_sidenav_directive__WEBPACK_IMPORTED_MODULE_0__["SidenavDirective"]]
        });
      })();
      /***/

    },

    /***/
    "K2KW":
    /*!*****************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/code-indented.js ***!
      \*****************************************************************/

    /*! no static exports found */

    /***/
    function K2KW(module, exports, __webpack_require__) {
      "use strict";

      var repeat = __webpack_require__(
      /*! repeat-string */
      "RjOF");

      var trim = __webpack_require__(
      /*! trim-trailing-lines */
      "3GlI");

      module.exports = indentedCode;
      var lineFeed = '\n';
      var tab = '\t';
      var space = ' ';
      var tabSize = 4;
      var codeIndent = repeat(space, tabSize);

      function indentedCode(eat, value, silent) {
        var index = -1;
        var length = value.length;
        var subvalue = '';
        var content = '';
        var subvalueQueue = '';
        var contentQueue = '';
        var character;
        var blankQueue;
        var indent;

        while (++index < length) {
          character = value.charAt(index);

          if (indent) {
            indent = false;
            subvalue += subvalueQueue;
            content += contentQueue;
            subvalueQueue = '';
            contentQueue = '';

            if (character === lineFeed) {
              subvalueQueue = character;
              contentQueue = character;
            } else {
              subvalue += character;
              content += character;

              while (++index < length) {
                character = value.charAt(index);

                if (!character || character === lineFeed) {
                  contentQueue = character;
                  subvalueQueue = character;
                  break;
                }

                subvalue += character;
                content += character;
              }
            }
          } else if (character === space && value.charAt(index + 1) === character && value.charAt(index + 2) === character && value.charAt(index + 3) === character) {
            subvalueQueue += codeIndent;
            index += 3;
            indent = true;
          } else if (character === tab) {
            subvalueQueue += character;
            indent = true;
          } else {
            blankQueue = '';

            while (character === tab || character === space) {
              blankQueue += character;
              character = value.charAt(++index);
            }

            if (character !== lineFeed) {
              break;
            }

            subvalueQueue += blankQueue + character;
            contentQueue += character;
          }
        }

        if (content) {
          if (silent) {
            return true;
          }

          return eat(subvalue)({
            type: 'code',
            lang: null,
            meta: null,
            value: trim(content)
          });
        }
      }
      /***/

    },

    /***/
    "KJAg":
    /*!*********************************************************!*\
      !*** ./node_modules/remark-parse/lib/util/interrupt.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function KJAg(module, exports, __webpack_require__) {
      "use strict";

      module.exports = interrupt;

      function interrupt(interruptors, tokenizers, ctx, parameters) {
        var length = interruptors.length;
        var index = -1;
        var interruptor;
        var config;

        while (++index < length) {
          interruptor = interruptors[index];
          config = interruptor[1] || {};

          if (config.pedantic !== undefined && config.pedantic !== ctx.options.pedantic) {
            continue;
          }

          if (config.commonmark !== undefined && config.commonmark !== ctx.options.commonmark) {
            continue;
          }

          if (tokenizers[interruptor[0]].apply(ctx, parameters)) {
            return true;
          }
        }

        return false;
      }
      /***/

    },

    /***/
    "KX5q":
    /*!**********************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/strong.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function KX5q(module, exports, __webpack_require__) {
      "use strict";

      var trim = __webpack_require__(
      /*! trim */
      "RsFJ");

      var whitespace = __webpack_require__(
      /*! is-whitespace-character */
      "IPAr");

      var locate = __webpack_require__(
      /*! ../locate/strong */
      "BjVE");

      module.exports = strong;
      strong.locator = locate;
      var backslash = '\\';
      var asterisk = '*';
      var underscore = '_';

      function strong(eat, value, silent) {
        var self = this;
        var index = 0;
        var character = value.charAt(index);
        var now;
        var pedantic;
        var marker;
        var queue;
        var subvalue;
        var length;
        var previous;

        if (character !== asterisk && character !== underscore || value.charAt(++index) !== character) {
          return;
        }

        pedantic = self.options.pedantic;
        marker = character;
        subvalue = marker + marker;
        length = value.length;
        index++;
        queue = '';
        character = '';

        if (pedantic && whitespace(value.charAt(index))) {
          return;
        }

        while (index < length) {
          previous = character;
          character = value.charAt(index);

          if (character === marker && value.charAt(index + 1) === marker && (!pedantic || !whitespace(previous))) {
            character = value.charAt(index + 2);

            if (character !== marker) {
              if (!trim(queue)) {
                return;
              }
              /* istanbul ignore if - never used (yet) */


              if (silent) {
                return true;
              }

              now = eat.now();
              now.column += 2;
              now.offset += 2;
              return eat(subvalue + queue + subvalue)({
                type: 'strong',
                children: self.tokenizeInline(queue, now)
              });
            }
          }

          if (!pedantic && character === backslash) {
            queue += character;
            character = value.charAt(++index);
          }

          queue += character;
          index++;
        }
      }
      /***/

    },

    /***/
    "LcL2":
    /*!*****************************************************!*\
      !*** ./node_modules/remark-sub-super/dist/index.js ***!
      \*****************************************************/

    /*! no static exports found */

    /***/
    function LcL2(module, exports, __webpack_require__) {
      "use strict";

      var SPACE = ' ';
      var markers = {
        '~': 'sub',
        '^': 'sup'
      };

      function locator(value, fromIndex) {
        var index = -1;
        var found = [];

        for (var _i = 0, _Object$keys = Object.keys(markers); _i < _Object$keys.length; _i++) {
          var marker = _Object$keys[_i];
          index = value.indexOf(marker, fromIndex);

          if (index !== -1) {
            found.push(index);
            continue;
          }
        }

        if (found.length) {
          found.sort(function (a, b) {
            return a - b;
          });
          return found[0];
        }

        return -1;
      }

      function inlinePlugin() {
        function inlineTokenizer(eat, value, silent) {
          // allow escaping of all markers
          for (var _i2 = 0, _Object$keys2 = Object.keys(markers); _i2 < _Object$keys2.length; _i2++) {
            var _marker = _Object$keys2[_i2];
            if (!this.escape.includes(_marker)) this.escape.push(_marker);
          }

          var marker = value[0];
          var now = eat.now();
          now.column += 1;
          now.offset += 1;

          if (markers.hasOwnProperty(marker) && !value.startsWith(marker + SPACE) && !value.startsWith(marker + marker)) {
            var endMarkerIndex = 1;

            for (; value[endMarkerIndex] !== marker && endMarkerIndex < value.length; endMarkerIndex++) {
              ;
            } // if it's actually empty, don't tokenize (disallows e.g. <sup></sup>)


            if (endMarkerIndex === value.length) return;
            /* istanbul ignore if - never used (yet) */

            if (silent) return true;
            eat(value.substring(0, endMarkerIndex + 1))({
              type: markers[marker],
              children: this.tokenizeInline(value.substring(1, endMarkerIndex), now),
              data: {
                hName: markers[marker]
              }
            });
          }
        }

        inlineTokenizer.locator = locator;
        var Parser = this.Parser; // Inject inlineTokenizer

        var inlineTokenizers = Parser.prototype.inlineTokenizers;
        var inlineMethods = Parser.prototype.inlineMethods;
        inlineTokenizers.sub_super = inlineTokenizer;
        inlineMethods.splice(inlineMethods.indexOf('text'), 0, 'sub_super');
      }

      module.exports = inlinePlugin;
      /***/
    },

    /***/
    "MHMH":
    /*!***************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/heading-atx.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function MHMH(module, exports, __webpack_require__) {
      "use strict";

      module.exports = atxHeading;
      var lineFeed = '\n';
      var tab = '\t';
      var space = ' ';
      var numberSign = '#';
      var maxFenceCount = 6;

      function atxHeading(eat, value, silent) {
        var self = this;
        var pedantic = self.options.pedantic;
        var length = value.length + 1;
        var index = -1;
        var now = eat.now();
        var subvalue = '';
        var content = '';
        var character;
        var queue;
        var depth; // Eat initial spacing.

        while (++index < length) {
          character = value.charAt(index);

          if (character !== space && character !== tab) {
            index--;
            break;
          }

          subvalue += character;
        } // Eat hashes.


        depth = 0;

        while (++index <= length) {
          character = value.charAt(index);

          if (character !== numberSign) {
            index--;
            break;
          }

          subvalue += character;
          depth++;
        }

        if (depth > maxFenceCount) {
          return;
        }

        if (!depth || !pedantic && value.charAt(index + 1) === numberSign) {
          return;
        }

        length = value.length + 1; // Eat intermediate white-space.

        queue = '';

        while (++index < length) {
          character = value.charAt(index);

          if (character !== space && character !== tab) {
            index--;
            break;
          }

          queue += character;
        } // Exit when not in pedantic mode without spacing.


        if (!pedantic && queue.length === 0 && character && character !== lineFeed) {
          return;
        }

        if (silent) {
          return true;
        } // Eat content.


        subvalue += queue;
        queue = '';
        content = '';

        while (++index < length) {
          character = value.charAt(index);

          if (!character || character === lineFeed) {
            break;
          }

          if (character !== space && character !== tab && character !== numberSign) {
            content += queue + character;
            queue = '';
            continue;
          }

          while (character === space || character === tab) {
            queue += character;
            character = value.charAt(++index);
          } // `#` without a queue is part of the content.


          if (!pedantic && content && !queue && character === numberSign) {
            content += character;
            continue;
          }

          while (character === numberSign) {
            queue += character;
            character = value.charAt(++index);
          }

          while (character === space || character === tab) {
            queue += character;
            character = value.charAt(++index);
          }

          index--;
        }

        now.column += subvalue.length;
        now.offset += subvalue.length;
        subvalue += content + queue;
        return eat(subvalue)({
          type: 'heading',
          depth: depth,
          children: self.tokenizeInline(content, now)
        });
      }
      /***/

    },

    /***/
    "MQ5/":
    /*!************************************************!*\
      !*** ./node_modules/markdown-escapes/index.js ***!
      \************************************************/

    /*! no static exports found */

    /***/
    function MQ5(module, exports, __webpack_require__) {
      "use strict";

      module.exports = escapes;
      var defaults = ['\\', '`', '*', '{', '}', '[', ']', '(', ')', '#', '+', '-', '.', '!', '_', '>'];
      var gfm = defaults.concat(['~', '|']);
      var commonmark = gfm.concat(['\n', '"', '$', '%', '&', "'", ',', '/', ':', ';', '<', '=', '?', '@', '^']);
      escapes["default"] = defaults;
      escapes.gfm = gfm;
      escapes.commonmark = commonmark; // Get markdown escapes.

      function escapes(options) {
        var settings = options || {};

        if (settings.commonmark) {
          return commonmark;
        }

        return settings.gfm ? gfm : defaults;
      }
      /***/

    },

    /***/
    "MaiH":
    /*!********************************************************!*\
      !*** ./node_modules/remark-parse/lib/locate/delete.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function MaiH(module, exports, __webpack_require__) {
      "use strict";

      module.exports = locate;

      function locate(value, fromIndex) {
        return value.indexOf('~~', fromIndex);
      }
      /***/

    },

    /***/
    "NFD0":
    /*!********************************************************!*\
      !*** ./node_modules/remark-parse/lib/locate/escape.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function NFD0(module, exports, __webpack_require__) {
      "use strict";

      module.exports = locate;

      function locate(value, fromIndex) {
        return value.indexOf('\\', fromIndex);
      }
      /***/

    },

    /***/
    "NJho":
    /*!***************************************************!*\
      !*** ./emoji/src/lib/names/emoji-names.module.ts ***!
      \***************************************************/

    /*! exports provided: EmojiNamesModule */

    /***/
    function NJho(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "EmojiNamesModule", function () {
        return EmojiNamesModule;
      });
      /* harmony import */


      var _emoji_names_pipe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./emoji-names.pipe */
      "qyca");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");

      var EmojiNamesModule = function EmojiNamesModule() {
        _classCallCheck(this, EmojiNamesModule);
      };

      EmojiNamesModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
        type: EmojiNamesModule
      });
      EmojiNamesModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
        factory: function EmojiNamesModule_Factory(t) {
          return new (t || EmojiNamesModule)();
        }
      });

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](EmojiNamesModule, {
          declarations: [_emoji_names_pipe__WEBPACK_IMPORTED_MODULE_0__["EmojiNamesPipe"]],
          exports: [_emoji_names_pipe__WEBPACK_IMPORTED_MODULE_0__["EmojiNamesPipe"]]
        });
      })();
      /***/

    },

    /***/
    "NS2H":
    /*!******************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/heading-setext.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function NS2H(module, exports, __webpack_require__) {
      "use strict";

      module.exports = setextHeading;
      var lineFeed = '\n';
      var tab = '\t';
      var space = ' ';
      var equalsTo = '=';
      var dash = '-';
      var maxIndent = 3;
      var equalsToDepth = 1;
      var dashDepth = 2;

      function setextHeading(eat, value, silent) {
        var self = this;
        var now = eat.now();
        var length = value.length;
        var index = -1;
        var subvalue = '';
        var content;
        var queue;
        var character;
        var marker;
        var depth; // Eat initial indentation.

        while (++index < length) {
          character = value.charAt(index);

          if (character !== space || index >= maxIndent) {
            index--;
            break;
          }

          subvalue += character;
        } // Eat content.


        content = '';
        queue = '';

        while (++index < length) {
          character = value.charAt(index);

          if (character === lineFeed) {
            index--;
            break;
          }

          if (character === space || character === tab) {
            queue += character;
          } else {
            content += queue + character;
            queue = '';
          }
        }

        now.column += subvalue.length;
        now.offset += subvalue.length;
        subvalue += content + queue; // Ensure the content is followed by a newline and a valid marker.

        character = value.charAt(++index);
        marker = value.charAt(++index);

        if (character !== lineFeed || marker !== equalsTo && marker !== dash) {
          return;
        }

        subvalue += character; // Eat Setext-line.

        queue = marker;
        depth = marker === equalsTo ? equalsToDepth : dashDepth;

        while (++index < length) {
          character = value.charAt(index);

          if (character !== marker) {
            if (character !== lineFeed) {
              return;
            }

            index--;
            break;
          }

          queue += character;
        }

        if (silent) {
          return true;
        }

        return eat(subvalue + queue)({
          type: 'heading',
          depth: depth,
          children: self.tokenizeInline(content, now)
        });
      }
      /***/

    },

    /***/
    "NkL+":
    /*!********************************************!*\
      !*** ./node_modules/is-plain-obj/index.js ***!
      \********************************************/

    /*! no static exports found */

    /***/
    function NkL(module, exports, __webpack_require__) {
      "use strict";

      module.exports = function (value) {
        if (Object.prototype.toString.call(value) !== '[object Object]') {
          return false;
        }

        var prototype = Object.getPrototypeOf(value);
        return prototype === null || prototype === Object.prototype;
      };
      /***/

    },

    /***/
    "OhU7":
    /*!**********************************************************!*\
      !*** ./wizdm/src/app/pages/static/toc/toc.animations.ts ***!
      \**********************************************************/

    /*! exports provided: $animations */

    /***/
    function OhU7(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "$animations", function () {
        return $animations;
      });
      /* harmony import */


      var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/animations */
      "GS7A");

      var $timing = '500ms cubic-bezier(0.2, 1, 0.2, 1)';
      var $animations = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('topic', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])(':enter', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        height: 0,
        overflow: 'hidden'
      }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["query"])('button', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        opacity: '0',
        transform: 'translateX(-150px)'
      }), {
        optional: true
      }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["group"])([Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])($timing, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        height: '*'
      })), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["query"])('button', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["stagger"])(50, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])($timing, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])('*'))), {
        optional: true
      })])]), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])(':leave', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        overflow: 'hidden'
      }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["group"])([Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])($timing, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        height: 0
      })), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["query"])('button', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])($timing, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
        opacity: '0',
        transform: 'translateY(-150px)'
      })), {
        optional: true
      })])])])];
      /***/
    },

    /***/
    "Olrm":
    /*!*************************************************!*\
      !*** ./node_modules/remark-parse/lib/decode.js ***!
      \*************************************************/

    /*! no static exports found */

    /***/
    function Olrm(module, exports, __webpack_require__) {
      "use strict";

      var xtend = __webpack_require__(
      /*! xtend */
      "U6jy");

      var entities = __webpack_require__(
      /*! parse-entities */
      "ZWk2");

      module.exports = factory; // Factory to create an entity decoder.

      function factory(ctx) {
        decoder.raw = decodeRaw;
        return decoder; // Normalize `position` to add an `indent`.

        function normalize(position) {
          var offsets = ctx.offset;
          var line = position.line;
          var result = [];

          while (++line) {
            if (!(line in offsets)) {
              break;
            }

            result.push((offsets[line] || 0) + 1);
          }

          return {
            start: position,
            indent: result
          };
        } // Decode `value` (at `position`) into text-nodes.


        function decoder(value, position, handler) {
          entities(value, {
            position: normalize(position),
            warning: handleWarning,
            text: handler,
            reference: handler,
            textContext: ctx,
            referenceContext: ctx
          });
        } // Decode `value` (at `position`) into a string.


        function decodeRaw(value, position, options) {
          return entities(value, xtend(options, {
            position: normalize(position),
            warning: handleWarning
          }));
        } // Handle a warning.
        // See <https://github.com/wooorm/parse-entities> for the warnings.


        function handleWarning(reason, position, code) {
          if (code !== 3) {
            ctx.file.message(reason, position);
          }
        }
      }
      /***/

    },

    /***/
    "P7XM":
    /*!***************************************************!*\
      !*** ./node_modules/inherits/inherits_browser.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function P7XM(module, exports) {
      if (typeof Object.create === 'function') {
        // implementation from standard node.js 'util' module
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;

            var TempCtor = function TempCtor() {};

            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
      /***/

    },

    /***/
    "PIlL":
    /*!**************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/blockquote.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function PIlL(module, exports, __webpack_require__) {
      "use strict";

      var trim = __webpack_require__(
      /*! trim */
      "RsFJ");

      var interrupt = __webpack_require__(
      /*! ../util/interrupt */
      "KJAg");

      module.exports = blockquote;
      var lineFeed = '\n';
      var tab = '\t';
      var space = ' ';
      var greaterThan = '>';

      function blockquote(eat, value, silent) {
        var self = this;
        var offsets = self.offset;
        var tokenizers = self.blockTokenizers;
        var interruptors = self.interruptBlockquote;
        var now = eat.now();
        var currentLine = now.line;
        var length = value.length;
        var values = [];
        var contents = [];
        var indents = [];
        var add;
        var index = 0;
        var character;
        var rest;
        var nextIndex;
        var content;
        var line;
        var startIndex;
        var prefixed;
        var exit;

        while (index < length) {
          character = value.charAt(index);

          if (character !== space && character !== tab) {
            break;
          }

          index++;
        }

        if (value.charAt(index) !== greaterThan) {
          return;
        }

        if (silent) {
          return true;
        }

        index = 0;

        while (index < length) {
          nextIndex = value.indexOf(lineFeed, index);
          startIndex = index;
          prefixed = false;

          if (nextIndex === -1) {
            nextIndex = length;
          }

          while (index < length) {
            character = value.charAt(index);

            if (character !== space && character !== tab) {
              break;
            }

            index++;
          }

          if (value.charAt(index) === greaterThan) {
            index++;
            prefixed = true;

            if (value.charAt(index) === space) {
              index++;
            }
          } else {
            index = startIndex;
          }

          content = value.slice(index, nextIndex);

          if (!prefixed && !trim(content)) {
            index = startIndex;
            break;
          }

          if (!prefixed) {
            rest = value.slice(index); // Check if the following code contains a possible block.

            if (interrupt(interruptors, tokenizers, self, [eat, rest, true])) {
              break;
            }
          }

          line = startIndex === index ? content : value.slice(startIndex, nextIndex);
          indents.push(index - startIndex);
          values.push(line);
          contents.push(content);
          index = nextIndex + 1;
        }

        index = -1;
        length = indents.length;
        add = eat(values.join(lineFeed));

        while (++index < length) {
          offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];
          currentLine++;
        }

        exit = self.enterBlock();
        contents = self.tokenizeBlock(contents.join(lineFeed), now);
        exit();
        return add({
          type: 'blockquote',
          children: contents
        });
      }
      /***/

    },

    /***/
    "PPHF":
    /*!*****************************************!*\
      !*** ./node_modules/vfile/lib/index.js ***!
      \*****************************************/

    /*! no static exports found */

    /***/
    function PPHF(module, exports, __webpack_require__) {
      "use strict";

      var VMessage = __webpack_require__(
      /*! vfile-message */
      "aCXt");

      var VFile = __webpack_require__(
      /*! ./core.js */
      "tgGP");

      module.exports = VFile;
      VFile.prototype.message = message;
      VFile.prototype.info = info;
      VFile.prototype.fail = fail; // Create a message with `reason` at `position`.
      // When an error is passed in as `reason`, copies the stack.

      function message(reason, position, origin) {
        var message = new VMessage(reason, position, origin);

        if (this.path) {
          message.name = this.path + ':' + message.name;
          message.file = this.path;
        }

        message.fatal = false;
        this.messages.push(message);
        return message;
      } // Fail: creates a vmessage, associates it with the file, and throws it.


      function fail() {
        var message = this.message.apply(this, arguments);
        message.fatal = true;
        throw message;
      } // Info: creates a vmessage, associates it with the file, and marks the fatality
      // as null.


      function info() {
        var message = this.message.apply(this, arguments);
        message.fatal = null;
        return message;
      }
      /***/

    },

    /***/
    "Q1h6":
    /*!*******************************!*\
      !*** ./markdown/src/index.ts ***!
      \*******************************/

    /*! exports provided: MarkdownTree, MarkdownBlock, MarkdownInline, MarkdownRoot, mdConfigToken, MarkdownModule */

    /***/
    function Q1h6(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony import */


      var _lib_tree_tree_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./lib/tree/tree-types */
      "r0km");
      /* empty/unused harmony star reexport */

      /* harmony import */


      var _lib_tree_tree_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./lib/tree/tree.service */
      "6opK");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "MarkdownTree", function () {
        return _lib_tree_tree_service__WEBPACK_IMPORTED_MODULE_1__["MarkdownTree"];
      });
      /* harmony import */


      var _lib_block_block_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! ./lib/block/block.component */
      "bspj");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "MarkdownBlock", function () {
        return _lib_block_block_component__WEBPACK_IMPORTED_MODULE_2__["MarkdownBlock"];
      });
      /* harmony import */


      var _lib_inline_inline_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! ./lib/inline/inline.component */
      "qCv1");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "MarkdownInline", function () {
        return _lib_inline_inline_component__WEBPACK_IMPORTED_MODULE_3__["MarkdownInline"];
      });
      /* harmony import */


      var _lib_markdown_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! ./lib/markdown.component */
      "xbVm");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "MarkdownRoot", function () {
        return _lib_markdown_component__WEBPACK_IMPORTED_MODULE_4__["MarkdownRoot"];
      });
      /* harmony import */


      var _lib_markdown_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! ./lib/markdown-config */
      "wagW");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "mdConfigToken", function () {
        return _lib_markdown_config__WEBPACK_IMPORTED_MODULE_5__["mdConfigToken"];
      });
      /* harmony import */


      var _lib_markdown_module__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
      /*! ./lib/markdown.module */
      "JZ3d");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "MarkdownModule", function () {
        return _lib_markdown_module__WEBPACK_IMPORTED_MODULE_6__["MarkdownModule"];
      });
      /***/

    },

    /***/
    "RSXs":
    /*!*************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/paragraph.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function RSXs(module, exports, __webpack_require__) {
      "use strict";

      var trim = __webpack_require__(
      /*! trim */
      "RsFJ");

      var trimTrailingLines = __webpack_require__(
      /*! trim-trailing-lines */
      "3GlI");

      var interrupt = __webpack_require__(
      /*! ../util/interrupt */
      "KJAg");

      module.exports = paragraph;
      var tab = '\t';
      var lineFeed = '\n';
      var space = ' ';
      var tabSize = 4; // Tokenise paragraph.

      function paragraph(eat, value, silent) {
        var self = this;
        var settings = self.options;
        var commonmark = settings.commonmark;
        var tokenizers = self.blockTokenizers;
        var interruptors = self.interruptParagraph;
        var index = value.indexOf(lineFeed);
        var length = value.length;
        var position;
        var subvalue;
        var character;
        var size;
        var now;

        while (index < length) {
          // Eat everything if there’s no following newline.
          if (index === -1) {
            index = length;
            break;
          } // Stop if the next character is NEWLINE.


          if (value.charAt(index + 1) === lineFeed) {
            break;
          } // In commonmark-mode, following indented lines are part of the paragraph.


          if (commonmark) {
            size = 0;
            position = index + 1;

            while (position < length) {
              character = value.charAt(position);

              if (character === tab) {
                size = tabSize;
                break;
              } else if (character === space) {
                size++;
              } else {
                break;
              }

              position++;
            }

            if (size >= tabSize && character !== lineFeed) {
              index = value.indexOf(lineFeed, index + 1);
              continue;
            }
          }

          subvalue = value.slice(index + 1); // Check if the following code contains a possible block.

          if (interrupt(interruptors, tokenizers, self, [eat, subvalue, true])) {
            break;
          }

          position = index;
          index = value.indexOf(lineFeed, index + 1);

          if (index !== -1 && trim(value.slice(position, index)) === '') {
            index = position;
            break;
          }
        }

        subvalue = value.slice(0, index);
        /* istanbul ignore if - never used (yet) */

        if (silent) {
          return true;
        }

        now = eat.now();
        subvalue = trimTrailingLines(subvalue);
        return eat(subvalue)({
          type: 'paragraph',
          children: self.tokenizeInline(subvalue, now)
        });
      }
      /***/

    },

    /***/
    "RjOF":
    /*!*********************************************!*\
      !*** ./node_modules/repeat-string/index.js ***!
      \*********************************************/

    /*! no static exports found */

    /***/
    function RjOF(module, exports, __webpack_require__) {
      "use strict";
      /*!
       * repeat-string <https://github.com/jonschlinkert/repeat-string>
       *
       * Copyright (c) 2014-2015, Jon Schlinkert.
       * Licensed under the MIT License.
       */

      /**
       * Results cache
       */

      var res = '';
      var cache;
      /**
       * Expose `repeat`
       */

      module.exports = repeat;
      /**
       * Repeat the given `string` the specified `number`
       * of times.
       *
       * **Example:**
       *
       * ```js
       * var repeat = require('repeat-string');
       * repeat('A', 5);
       * //=> AAAAA
       * ```
       *
       * @param {String} `string` The string to repeat
       * @param {Number} `number` The number of times to repeat the string
       * @return {String} Repeated string
       * @api public
       */

      function repeat(str, num) {
        if (typeof str !== 'string') {
          throw new TypeError('expected a string');
        } // cover common, quick use cases


        if (num === 1) return str;
        if (num === 2) return str + str;
        var max = str.length * num;

        if (cache !== str || typeof cache === 'undefined') {
          cache = str;
          res = '';
        } else if (res.length >= max) {
          return res.substr(0, max);
        }

        while (max > res.length && num > 1) {
          if (num & 1) {
            res += str;
          }

          num >>= 1;
          str += str;
        }

        res += str;
        res = res.substr(0, max);
        return res;
      }
      /***/

    },

    /***/
    "RnBS":
    /*!**************************************!*\
      !*** ./emoji/src/lib/names/index.ts ***!
      \**************************************/

    /*! exports provided: EmojiNamesPipe, EmojiNamesModule */

    /***/
    function RnBS(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony import */


      var _emoji_names_pipe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./emoji-names.pipe */
      "qyca");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "EmojiNamesPipe", function () {
        return _emoji_names_pipe__WEBPACK_IMPORTED_MODULE_0__["EmojiNamesPipe"];
      });
      /* harmony import */


      var _emoji_names_module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./emoji-names.module */
      "NJho");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "EmojiNamesModule", function () {
        return _emoji_names_module__WEBPACK_IMPORTED_MODULE_1__["EmojiNamesModule"];
      });
      /***/

    },

    /***/
    "RsFJ":
    /*!************************************!*\
      !*** ./node_modules/trim/index.js ***!
      \************************************/

    /*! no static exports found */

    /***/
    function RsFJ(module, exports) {
      exports = module.exports = trim;

      function trim(str) {
        return str.replace(/^\s*|\s*$/g, '');
      }

      exports.left = function (str) {
        return str.replace(/^\s*/, '');
      };

      exports.right = function (str) {
        return str.replace(/\s*$/, '');
      };
      /***/

    },

    /***/
    "SbiQ":
    /*!********************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/text.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function SbiQ(module, exports, __webpack_require__) {
      "use strict";

      module.exports = text;

      function text(eat, value, silent) {
        var self = this;
        var methods;
        var tokenizers;
        var index;
        var length;
        var subvalue;
        var position;
        var tokenizer;
        var name;
        var min;
        var now;
        /* istanbul ignore if - never used (yet) */

        if (silent) {
          return true;
        }

        methods = self.inlineMethods;
        length = methods.length;
        tokenizers = self.inlineTokenizers;
        index = -1;
        min = value.length;

        while (++index < length) {
          name = methods[index];

          if (name === 'text' || !tokenizers[name]) {
            continue;
          }

          tokenizer = tokenizers[name].locator;

          if (!tokenizer) {
            eat.file.fail('Missing locator: `' + name + '`');
          }

          position = tokenizer.call(self, value, 1);

          if (position !== -1 && position < min) {
            min = position;
          }
        }

        subvalue = value.slice(0, min);
        now = eat.now();
        self.decode(subvalue, now, handler);

        function handler(content, position, source) {
          eat(source || content)({
            type: 'text',
            value: content
          });
        }
      }
      /***/

    },

    /***/
    "Smp3":
    /*!********************************************!*\
      !*** ./prism/src/lib/prism-manual-mode.ts ***!
      \********************************************/

    /*! no exports provided */

    /***/
    function Smp3(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__); // Forces prism to run in manual mode


      (function (window) {
        window.Prism = window.Prism || {};
        window.Prism.manual = true;
      })(window || {});
      /***/

    },

    /***/
    "TTG4":
    /*!******************************************************!*\
      !*** ./node_modules/space-separated-tokens/index.js ***!
      \******************************************************/

    /*! no static exports found */

    /***/
    function TTG4(module, exports, __webpack_require__) {
      "use strict";

      exports.parse = parse;
      exports.stringify = stringify;
      var empty = '';
      var space = ' ';
      var whiteSpace = /[ \t\n\r\f]+/g;

      function parse(value) {
        var input = String(value || empty).trim();
        return input === empty ? [] : input.split(whiteSpace);
      }

      function stringify(values) {
        return values.join(space).trim();
      }
      /***/

    },

    /***/
    "TjP8":
    /*!****************************************************!*\
      !*** ./node_modules/remark-parse/lib/util/html.js ***!
      \****************************************************/

    /*! no static exports found */

    /***/
    function TjP8(module, exports, __webpack_require__) {
      "use strict";

      var attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
      var unquoted = "[^\"'=<>`\\u0000-\\u0020]+";
      var singleQuoted = "'[^']*'";
      var doubleQuoted = '"[^"]*"';
      var attributeValue = '(?:' + unquoted + '|' + singleQuoted + '|' + doubleQuoted + ')';
      var attribute = '(?:\\s+' + attributeName + '(?:\\s*=\\s*' + attributeValue + ')?)';
      var openTag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';
      var closeTag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
      var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
      var processing = '<[?].*?[?]>';
      var declaration = '<![A-Za-z]+\\s+[^>]*>';
      var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';
      exports.openCloseTag = new RegExp('^(?:' + openTag + '|' + closeTag + ')');
      exports.tag = new RegExp('^(?:' + openTag + '|' + closeTag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
      /***/
    },

    /***/
    "U6jy":
    /*!*****************************************!*\
      !*** ./node_modules/xtend/immutable.js ***!
      \*****************************************/

    /*! no static exports found */

    /***/
    function U6jy(module, exports) {
      module.exports = extend;
      var hasOwnProperty = Object.prototype.hasOwnProperty;

      function extend() {
        var target = {};

        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      }
      /***/

    },

    /***/
    "UBI6":
    /*!*******************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/url.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function UBI6(module, exports, __webpack_require__) {
      "use strict";

      var ccount = __webpack_require__(
      /*! ccount */
      "F2il");

      var decode = __webpack_require__(
      /*! parse-entities */
      "ZWk2");

      var decimal = __webpack_require__(
      /*! is-decimal */
      "ZONP");

      var alphabetical = __webpack_require__(
      /*! is-alphabetical */
      "1iAE");

      var whitespace = __webpack_require__(
      /*! is-whitespace-character */
      "IPAr");

      var locate = __webpack_require__(
      /*! ../locate/url */
      "VSQ+");

      module.exports = url;
      url.locator = locate;
      url.notInLink = true;
      var exclamationMark = 33; // '!'

      var ampersand = 38; // '&'

      var rightParenthesis = 41; // ')'

      var asterisk = 42; // '*'

      var comma = 44; // ','

      var dash = 45; // '-'

      var dot = 46; // '.'

      var colon = 58; // ':'

      var semicolon = 59; // ';'

      var questionMark = 63; // '?'

      var lessThan = 60; // '<'

      var underscore = 95; // '_'

      var tilde = 126; // '~'

      var leftParenthesisCharacter = '(';
      var rightParenthesisCharacter = ')';

      function url(eat, value, silent) {
        var self = this;
        var gfm = self.options.gfm;
        var tokenizers = self.inlineTokenizers;
        var length = value.length;
        var previousDot = -1;
        var protocolless = false;
        var dots;
        var lastTwoPartsStart;
        var start;
        var index;
        var pathStart;
        var path;
        var code;
        var end;
        var leftCount;
        var rightCount;
        var content;
        var children;
        var url;
        var exit;

        if (!gfm) {
          return;
        } // `WWW.` doesn’t work.


        if (value.slice(0, 4) === 'www.') {
          protocolless = true;
          index = 4;
        } else if (value.slice(0, 7).toLowerCase() === 'http://') {
          index = 7;
        } else if (value.slice(0, 8).toLowerCase() === 'https://') {
          index = 8;
        } else {
          return;
        } // Act as if the starting boundary is a dot.


        previousDot = index - 1; // Parse a valid domain.

        start = index;
        dots = [];

        while (index < length) {
          code = value.charCodeAt(index);

          if (code === dot) {
            // Dots may not appear after each other.
            if (previousDot === index - 1) {
              break;
            }

            dots.push(index);
            previousDot = index;
            index++;
            continue;
          }

          if (decimal(code) || alphabetical(code) || code === dash || code === underscore) {
            index++;
            continue;
          }

          break;
        } // Ignore a final dot:


        if (code === dot) {
          dots.pop();
          index--;
        } // If there are not dots, exit.


        if (dots[0] === undefined) {
          return;
        } // If there is an underscore in the last two domain parts, exit:
        // `www.example.c_m` and `www.ex_ample.com` are not OK, but
        // `www.sub_domain.example.com` is.


        lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1;

        if (value.slice(lastTwoPartsStart, index).indexOf('_') !== -1) {
          return;
        }
        /* istanbul ignore if - never used (yet) */


        if (silent) {
          return true;
        }

        end = index;
        pathStart = index; // Parse a path.

        while (index < length) {
          code = value.charCodeAt(index);

          if (whitespace(code) || code === lessThan) {
            break;
          }

          index++;

          if (code === exclamationMark || code === asterisk || code === comma || code === dot || code === colon || code === questionMark || code === underscore || code === tilde) {// Empty
          } else {
            end = index;
          }
        }

        index = end; // If the path ends in a closing paren, and the count of closing parens is
        // higher than the opening count, then remove the supefluous closing parens.

        if (value.charCodeAt(index - 1) === rightParenthesis) {
          path = value.slice(pathStart, index);
          leftCount = ccount(path, leftParenthesisCharacter);
          rightCount = ccount(path, rightParenthesisCharacter);

          while (rightCount > leftCount) {
            index = pathStart + path.lastIndexOf(rightParenthesisCharacter);
            path = value.slice(pathStart, index);
            rightCount--;
          }
        }

        if (value.charCodeAt(index - 1) === semicolon) {
          // GitHub doesn’t document this, but final semicolons aren’t paret of the
          // URL either.
          index--; // // If the path ends in what looks like an entity, it’s not part of the path.

          if (alphabetical(value.charCodeAt(index - 1))) {
            end = index - 2;

            while (alphabetical(value.charCodeAt(end))) {
              end--;
            }

            if (value.charCodeAt(end) === ampersand) {
              index = end;
            }
          }
        }

        content = value.slice(0, index);
        url = decode(content, {
          nonTerminated: false
        });

        if (protocolless) {
          url = 'http://' + url;
        }

        exit = self.enterLink(); // Temporarily remove all tokenizers except text in url.

        self.inlineTokenizers = {
          text: tokenizers.text
        };
        children = self.tokenizeInline(content, eat.now());
        self.inlineTokenizers = tokenizers;
        exit();
        return eat(content)({
          type: 'link',
          title: null,
          url: url,
          children: children
        });
      }
      /***/

    },

    /***/
    "UIh7":
    /*!**********************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/delete.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function UIh7(module, exports, __webpack_require__) {
      "use strict";

      var whitespace = __webpack_require__(
      /*! is-whitespace-character */
      "IPAr");

      var locate = __webpack_require__(
      /*! ../locate/delete */
      "MaiH");

      module.exports = strikethrough;
      strikethrough.locator = locate;
      var tilde = '~';
      var fence = '~~';

      function strikethrough(eat, value, silent) {
        var self = this;
        var character = '';
        var previous = '';
        var preceding = '';
        var subvalue = '';
        var index;
        var length;
        var now;

        if (!self.options.gfm || value.charAt(0) !== tilde || value.charAt(1) !== tilde || whitespace(value.charAt(2))) {
          return;
        }

        index = 1;
        length = value.length;
        now = eat.now();
        now.column += 2;
        now.offset += 2;

        while (++index < length) {
          character = value.charAt(index);

          if (character === tilde && previous === tilde && (!preceding || !whitespace(preceding))) {
            /* istanbul ignore if - never used (yet) */
            if (silent) {
              return true;
            }

            return eat(fence + subvalue + fence)({
              type: 'delete',
              children: self.tokenizeInline(subvalue, now)
            });
          }

          subvalue += previous;
          preceding = previous;
          previous = character;
        }
      }
      /***/

    },

    /***/
    "VRSw":
    /*!***************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/html-inline.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function VRSw(module, exports, __webpack_require__) {
      "use strict";

      var alphabetical = __webpack_require__(
      /*! is-alphabetical */
      "1iAE");

      var locate = __webpack_require__(
      /*! ../locate/tag */
      "afWh");

      var tag = __webpack_require__(
      /*! ../util/html */
      "TjP8").tag;

      module.exports = inlineHTML;
      inlineHTML.locator = locate;
      var lessThan = '<';
      var questionMark = '?';
      var exclamationMark = '!';
      var slash = '/';
      var htmlLinkOpenExpression = /^<a /i;
      var htmlLinkCloseExpression = /^<\/a>/i;

      function inlineHTML(eat, value, silent) {
        var self = this;
        var length = value.length;
        var character;
        var subvalue;

        if (value.charAt(0) !== lessThan || length < 3) {
          return;
        }

        character = value.charAt(1);

        if (!alphabetical(character) && character !== questionMark && character !== exclamationMark && character !== slash) {
          return;
        }

        subvalue = value.match(tag);

        if (!subvalue) {
          return;
        }
        /* istanbul ignore if - not used yet. */


        if (silent) {
          return true;
        }

        subvalue = subvalue[0];

        if (!self.inLink && htmlLinkOpenExpression.test(subvalue)) {
          self.inLink = true;
        } else if (self.inLink && htmlLinkCloseExpression.test(subvalue)) {
          self.inLink = false;
        }

        return eat(subvalue)({
          type: 'html',
          value: subvalue
        });
      }
      /***/

    },

    /***/
    "VSQ+":
    /*!*****************************************************!*\
      !*** ./node_modules/remark-parse/lib/locate/url.js ***!
      \*****************************************************/

    /*! no static exports found */

    /***/
    function VSQ(module, exports, __webpack_require__) {
      "use strict";

      module.exports = locate;
      var values = ['www.', 'http://', 'https://'];

      function locate(value, fromIndex) {
        var min = -1;
        var index;
        var length;
        var position;

        if (!this.options.gfm) {
          return min;
        }

        length = values.length;
        index = -1;

        while (++index < length) {
          position = value.indexOf(values[index], fromIndex);

          if (position !== -1 && (min === -1 || position < min)) {
            min = position;
          }
        }

        return min;
      }
      /***/

    },

    /***/
    "WtKE":
    /*!**************************************************************!*\
      !*** ./node_modules/parse-entities/decode-entity.browser.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function WtKE(module, exports, __webpack_require__) {
      "use strict";
      /* eslint-env browser */

      var el;
      var semicolon = 59; //  ';'

      module.exports = decodeEntity;

      function decodeEntity(characters) {
        var entity = '&' + characters + ';';

        var _char;

        el = el || document.createElement('i');
        el.innerHTML = entity;
        _char = el.textContent; // Some entities do not require the closing semicolon (`&not` - for instance),
        // which leads to situations where parsing the assumed entity of &notit; will
        // result in the string `¬it;`.  When we encounter a trailing semicolon after
        // parsing and the entity to decode was not a semicolon (`&semi;`), we can
        // assume that the matching was incomplete

        if (_char.charCodeAt(_char.length - 1) === semicolon && characters !== 'semi') {
          return false;
        } // If the decoded string is equal to the input, the entity was not valid


        return _char === entity ? false : _char;
      }
      /***/

    },

    /***/
    "XJsG":
    /*!********************************************************!*\
      !*** ./prism/src/lib/tokenizer/tokenizer.component.ts ***!
      \********************************************************/

    /*! exports provided: PrismTokenizer */

    /***/
    function XJsG(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "PrismTokenizer", function () {
        return PrismTokenizer;
      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/common */
      "SVse");

      var _c0 = ["tokenize", ""];

      function PrismTokenizer_ng_container_0_ng_container_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var token_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](token_r1);
        }
      }

      function PrismTokenizer_ng_container_0_ng_template_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "span", 3);
        }

        if (rf & 2) {
          var token_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMap"](ctx_r4.tokenClass(token_r1));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("tokenize", token_r1.content);
        }
      }

      function PrismTokenizer_ng_container_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PrismTokenizer_ng_container_0_ng_container_1_Template, 2, 1, "ng-container", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, PrismTokenizer_ng_container_0_ng_template_2_Template, 1, 3, "ng-template", null, 2, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var token_r1 = ctx.$implicit;

          var _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](3);

          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r0.isString(token_r1))("ngIfElse", _r3);
        }
      }

      var PrismTokenizer = /*#__PURE__*/function () {
        function PrismTokenizer() {
          _classCallCheck(this, PrismTokenizer);
        }

        _createClass(PrismTokenizer, [{
          key: "tokenize",
          set:
          /** Tokenizes the input string or pass along the already tokenized array */
          function set(source) {
            this.tokens = typeof source === 'string' ? [source] : source;
          }
          /** Helper for rendering strings */

        }, {
          key: "isString",
          value: function isString(token) {
            return typeof token === 'string';
          }
          /** Helper for rendering tokens */

        }, {
          key: "tokenClass",
          value: function tokenClass(token) {
            // Returns the basic token class + type and appends the aliases, if any 
            return token ? 'token ' + (token.type || '') + this.tokenAliases(token) : '';
          }
        }, {
          key: "tokenAliases",
          value: function tokenAliases(token) {
            // Skips when no aliases
            if (!token.alias) {
              return '';
            } // Appends the multiple aliases


            if (token.alias instanceof Array) {
              return token.alias.reduce(function (c, alias) {
                return c + ' ' + alias;
              }, '');
            } // Appends the single alias


            return ' ' + token.alias;
          }
        }]);

        return PrismTokenizer;
      }();

      PrismTokenizer.ɵfac = function PrismTokenizer_Factory(t) {
        return new (t || PrismTokenizer)();
      };

      PrismTokenizer.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: PrismTokenizer,
        selectors: [["", "tokenize", ""]],
        inputs: {
          tokenize: "tokenize"
        },
        attrs: _c0,
        decls: 1,
        vars: 1,
        consts: [[4, "ngFor", "ngForOf"], [4, "ngIf", "ngIfElse"], ["spanToken", ""], [3, "tokenize"]],
        template: function PrismTokenizer_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, PrismTokenizer_ng_container_0_Template, 4, 2, "ng-container", 0);
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.tokens);
          }
        },
        directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgForOf"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], PrismTokenizer],
        encapsulation: 2
      });
      /***/
    },

    /***/
    "YGTb":
    /*!*************************************************!*\
      !*** ./node_modules/remark-align/dist/index.js ***!
      \*************************************************/

    /*! no static exports found */

    /***/
    function YGTb(module, exports, __webpack_require__) {
      "use strict";

      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
      }

      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }

      function _iterableToArrayLimit(arr, i) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;

        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }

        return _arr;
      }

      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }

      var spaceSeparated = __webpack_require__(
      /*! space-separated-tokens */
      "TTG4");

      var C_NEWLINE = '\n';
      var C_NEWPARAGRAPH = '\n\n';

      module.exports = function plugin() {
        var classNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var locateMarker = new RegExp("[^\\\\]?(->|<-)");
        var endMarkers = ['->', '<-'];

        function alignTokenizer(eat, value, silent) {
          var keep = value.match(locateMarker);
          if (!keep || keep.index !== 0) return;
          var now = eat.now();

          var _keep = _slicedToArray(keep, 2),
              startMarker = _keep[1];
          /* istanbul ignore if - never used (yet) */


          if (silent) return true;
          var index = 0;
          var linesToEat = [];
          var finishedBlocks = [];
          var endMarker = '';
          var canEatLine = true;
          var blockStartIndex = 0;

          while (canEatLine) {
            var nextIndex = value.indexOf(C_NEWLINE, index + 1);
            var lineToEat = nextIndex !== -1 ? value.slice(index, nextIndex) : value.slice(index);
            linesToEat.push(lineToEat);
            var endIndex = endMarkers.indexOf(lineToEat.slice(-2)); // If nextIndex = (blockStartIndex + 2), it's the first marker of the block.

            if ((nextIndex > blockStartIndex + 2 || nextIndex === -1) && lineToEat.length >= 2 && endIndex !== -1) {
              if (endMarker === '') endMarker = lineToEat.slice(-2);
              finishedBlocks.push(linesToEat.join(C_NEWLINE)); // Check if another block is following

              if (value.indexOf('->', nextIndex) !== nextIndex + 1) break;
              linesToEat = [];
              blockStartIndex = nextIndex + 1;
            }

            index = nextIndex + 1;
            canEatLine = nextIndex !== -1;
          }

          var elementType = '';
          var classes = '';

          if (startMarker === '<-' && endMarker === '<-') {
            elementType = 'leftAligned';
            classes = classNames.left ? classNames.left : 'align-left';
          }

          if (startMarker === '->') {
            if (endMarker === '<-') {
              elementType = 'centerAligned';
              classes = classNames.center ? classNames.center : 'align-center';
            }

            if (endMarker === '->') {
              elementType = 'rightAligned';
              classes = classNames.right ? classNames.right : 'align-right';
            }
          }

          if (!elementType) return;
          if (finishedBlocks.length === 0) return;
          var stringToEat = '';
          var marker = finishedBlocks[0].substring(finishedBlocks[0].length - 2, finishedBlocks[0].length);
          var toEat = [];

          for (var i = 0; i < finishedBlocks.length; ++i) {
            var block = finishedBlocks[i];
            if (marker !== block.substring(block.length - 2, block.length)) break;
            toEat.push(block);
            stringToEat += block.slice(2, -2) + C_NEWPARAGRAPH;
          }

          var add = eat(toEat.join(C_NEWLINE));
          var exit = this.enterBlock();
          var values = this.tokenizeBlock(stringToEat, now);
          exit();
          return add({
            type: elementType,
            children: values,
            data: {
              hName: 'div',
              hProperties: {
                "class": spaceSeparated.parse(classes)
              }
            }
          });
        }

        var Parser = this.Parser; // Inject blockTokenizer

        var blockTokenizers = Parser.prototype.blockTokenizers;
        var blockMethods = Parser.prototype.blockMethods;
        blockTokenizers.alignBlocks = alignTokenizer;
        blockMethods.splice(blockMethods.indexOf('list') + 1, 0, 'alignBlocks');
        var Compiler = this.Compiler; // Stringify

        if (Compiler) {
          var visitors = Compiler.prototype.visitors;
          if (!visitors) return;

          var alignCompiler = function alignCompiler(node) {
            var innerContent = this.all(node);
            var markers = {
              left: ['<-', '<-'],
              right: ['->', '->'],
              center: ['->', '<-']
            };
            var alignType = node.type.slice(0, -7);
            if (!markers[alignType]) return innerContent.join('\n\n');

            var _markers$alignType = _slicedToArray(markers[alignType], 2),
                start = _markers$alignType[0],
                end = _markers$alignType[1];

            if (innerContent.length < 2) return "".concat(start, " ").concat(innerContent.join('\n').trim(), " ").concat(end);
            return "".concat(start, "\n").concat(innerContent.join('\n\n').trim(), "\n").concat(end);
          };

          visitors.leftAligned = alignCompiler;
          visitors.rightAligned = alignCompiler;
          visitors.centerAligned = alignCompiler;
        }
      };
      /***/

    },

    /***/
    "Z87L":
    /*!*************************************************************!*\
      !*** ./node_modules/character-reference-invalid/index.json ***!
      \*************************************************************/

    /*! exports provided: 0, 128, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 142, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 158, 159, default */

    /***/
    function Z87L(module) {
      module.exports = JSON.parse("{\"0\":\"�\",\"128\":\"€\",\"130\":\"‚\",\"131\":\"ƒ\",\"132\":\"„\",\"133\":\"…\",\"134\":\"†\",\"135\":\"‡\",\"136\":\"ˆ\",\"137\":\"‰\",\"138\":\"Š\",\"139\":\"‹\",\"140\":\"Œ\",\"142\":\"Ž\",\"145\":\"‘\",\"146\":\"’\",\"147\":\"“\",\"148\":\"”\",\"149\":\"•\",\"150\":\"–\",\"151\":\"—\",\"152\":\"˜\",\"153\":\"™\",\"154\":\"š\",\"155\":\"›\",\"156\":\"œ\",\"158\":\"ž\",\"159\":\"Ÿ\"}");
      /***/
    },

    /***/
    "ZJXm":
    /*!**************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/html-block.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function ZJXm(module, exports, __webpack_require__) {
      "use strict";

      var openCloseTag = __webpack_require__(
      /*! ../util/html */
      "TjP8").openCloseTag;

      module.exports = blockHtml;
      var tab = '\t';
      var space = ' ';
      var lineFeed = '\n';
      var lessThan = '<';
      var rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i;
      var rawCloseExpression = /<\/(script|pre|style)>/i;
      var commentOpenExpression = /^<!--/;
      var commentCloseExpression = /-->/;
      var instructionOpenExpression = /^<\?/;
      var instructionCloseExpression = /\?>/;
      var directiveOpenExpression = /^<![A-Za-z]/;
      var directiveCloseExpression = />/;
      var cdataOpenExpression = /^<!\[CDATA\[/;
      var cdataCloseExpression = /]]>/;
      var elementCloseExpression = /^$/;
      var otherElementOpenExpression = new RegExp(openCloseTag.source + '\\s*$');

      function blockHtml(eat, value, silent) {
        var self = this;
        var blocks = self.options.blocks.join('|');
        var elementOpenExpression = new RegExp('^</?(' + blocks + ')(?=(\\s|/?>|$))', 'i');
        var length = value.length;
        var index = 0;
        var next;
        var line;
        var offset;
        var character;
        var count;
        var sequence;
        var subvalue;
        var sequences = [[rawOpenExpression, rawCloseExpression, true], [commentOpenExpression, commentCloseExpression, true], [instructionOpenExpression, instructionCloseExpression, true], [directiveOpenExpression, directiveCloseExpression, true], [cdataOpenExpression, cdataCloseExpression, true], [elementOpenExpression, elementCloseExpression, true], [otherElementOpenExpression, elementCloseExpression, false]]; // Eat initial spacing.

        while (index < length) {
          character = value.charAt(index);

          if (character !== tab && character !== space) {
            break;
          }

          index++;
        }

        if (value.charAt(index) !== lessThan) {
          return;
        }

        next = value.indexOf(lineFeed, index + 1);
        next = next === -1 ? length : next;
        line = value.slice(index, next);
        offset = -1;
        count = sequences.length;

        while (++offset < count) {
          if (sequences[offset][0].test(line)) {
            sequence = sequences[offset];
            break;
          }
        }

        if (!sequence) {
          return;
        }

        if (silent) {
          return sequence[2];
        }

        index = next;

        if (!sequence[1].test(line)) {
          while (index < length) {
            next = value.indexOf(lineFeed, index + 1);
            next = next === -1 ? length : next;
            line = value.slice(index + 1, next);

            if (sequence[1].test(line)) {
              if (line) {
                index = next;
              }

              break;
            }

            index = next;
          }
        }

        subvalue = value.slice(0, index);
        return eat(subvalue)({
          type: 'html',
          value: subvalue
        });
      }
      /***/

    },

    /***/
    "ZONP":
    /*!******************************************!*\
      !*** ./node_modules/is-decimal/index.js ***!
      \******************************************/

    /*! no static exports found */

    /***/
    function ZONP(module, exports, __webpack_require__) {
      "use strict";

      module.exports = decimal; // Check if the given character code, or the character code at the first
      // character, is decimal.

      function decimal(character) {
        var code = typeof character === 'string' ? character.charCodeAt(0) : character;
        return code >= 48 && code <= 57;
        /* 0-9 */
      }
      /***/

    },

    /***/
    "ZWk2":
    /*!**********************************************!*\
      !*** ./node_modules/parse-entities/index.js ***!
      \**********************************************/

    /*! no static exports found */

    /***/
    function ZWk2(module, exports, __webpack_require__) {
      "use strict";

      var legacy = __webpack_require__(
      /*! character-entities-legacy */
      "m2n9");

      var invalid = __webpack_require__(
      /*! character-reference-invalid */
      "Z87L");

      var decimal = __webpack_require__(
      /*! is-decimal */
      "ZONP");

      var hexadecimal = __webpack_require__(
      /*! is-hexadecimal */
      "fjrl");

      var alphanumerical = __webpack_require__(
      /*! is-alphanumerical */
      "J5yW");

      var decodeEntity = __webpack_require__(
      /*! ./decode-entity */
      "WtKE");

      module.exports = parseEntities;
      var own = {}.hasOwnProperty;
      var fromCharCode = String.fromCharCode;
      var noop = Function.prototype; // Default settings.

      var defaults = {
        warning: null,
        reference: null,
        text: null,
        warningContext: null,
        referenceContext: null,
        textContext: null,
        position: {},
        additional: null,
        attribute: false,
        nonTerminated: true
      }; // Characters.

      var tab = 9; // '\t'

      var lineFeed = 10; // '\n'

      var formFeed = 12; // '\f'

      var space = 32; // ' '

      var ampersand = 38; // '&'

      var semicolon = 59; // ';'

      var lessThan = 60; // '<'

      var equalsTo = 61; // '='

      var numberSign = 35; // '#'

      var uppercaseX = 88; // 'X'

      var lowercaseX = 120; // 'x'

      var replacementCharacter = 65533; // '�'
      // Reference types.

      var name = 'named';
      var hexa = 'hexadecimal';
      var deci = 'decimal'; // Map of bases.

      var bases = {};
      bases[hexa] = 16;
      bases[deci] = 10; // Map of types to tests.
      // Each type of character reference accepts different characters.
      // This test is used to detect whether a reference has ended (as the semicolon
      // is not strictly needed).

      var tests = {};
      tests[name] = alphanumerical;
      tests[deci] = decimal;
      tests[hexa] = hexadecimal; // Warning types.

      var namedNotTerminated = 1;
      var numericNotTerminated = 2;
      var namedEmpty = 3;
      var numericEmpty = 4;
      var namedUnknown = 5;
      var numericDisallowed = 6;
      var numericProhibited = 7; // Warning messages.

      var messages = {};
      messages[namedNotTerminated] = 'Named character references must be terminated by a semicolon';
      messages[numericNotTerminated] = 'Numeric character references must be terminated by a semicolon';
      messages[namedEmpty] = 'Named character references cannot be empty';
      messages[numericEmpty] = 'Numeric character references cannot be empty';
      messages[namedUnknown] = 'Named character references must be known';
      messages[numericDisallowed] = 'Numeric character references cannot be disallowed';
      messages[numericProhibited] = 'Numeric character references cannot be outside the permissible Unicode range'; // Wrap to ensure clean parameters are given to `parse`.

      function parseEntities(value, options) {
        var settings = {};
        var option;
        var key;

        if (!options) {
          options = {};
        }

        for (key in defaults) {
          option = options[key];
          settings[key] = option === null || option === undefined ? defaults[key] : option;
        }

        if (settings.position.indent || settings.position.start) {
          settings.indent = settings.position.indent || [];
          settings.position = settings.position.start;
        }

        return parse(value, settings);
      } // Parse entities.
      // eslint-disable-next-line complexity


      function parse(value, settings) {
        var additional = settings.additional;
        var nonTerminated = settings.nonTerminated;
        var handleText = settings.text;
        var handleReference = settings.reference;
        var handleWarning = settings.warning;
        var textContext = settings.textContext;
        var referenceContext = settings.referenceContext;
        var warningContext = settings.warningContext;
        var pos = settings.position;
        var indent = settings.indent || [];
        var length = value.length;
        var index = 0;
        var lines = -1;
        var column = pos.column || 1;
        var line = pos.line || 1;
        var queue = '';
        var result = [];
        var entityCharacters;
        var namedEntity;
        var terminated;
        var characters;
        var character;
        var reference;
        var following;
        var warning;
        var reason;
        var output;
        var entity;
        var begin;
        var start;
        var type;
        var test;
        var prev;
        var next;
        var diff;
        var end;

        if (typeof additional === 'string') {
          additional = additional.charCodeAt(0);
        } // Cache the current point.


        prev = now(); // Wrap `handleWarning`.

        warning = handleWarning ? parseError : noop; // Ensure the algorithm walks over the first character and the end
        // (inclusive).

        index--;
        length++;

        while (++index < length) {
          // If the previous character was a newline.
          if (character === lineFeed) {
            column = indent[lines] || 1;
          }

          character = value.charCodeAt(index);

          if (character === ampersand) {
            following = value.charCodeAt(index + 1); // The behaviour depends on the identity of the next character.

            if (following === tab || following === lineFeed || following === formFeed || following === space || following === ampersand || following === lessThan || following !== following || additional && following === additional) {
              // Not a character reference.
              // No characters are consumed, and nothing is returned.
              // This is not an error, either.
              queue += fromCharCode(character);
              column++;
              continue;
            }

            start = index + 1;
            begin = start;
            end = start;

            if (following === numberSign) {
              // Numerical entity.
              end = ++begin; // The behaviour further depends on the next character.

              following = value.charCodeAt(end);

              if (following === uppercaseX || following === lowercaseX) {
                // ASCII hex digits.
                type = hexa;
                end = ++begin;
              } else {
                // ASCII digits.
                type = deci;
              }
            } else {
              // Named entity.
              type = name;
            }

            entityCharacters = '';
            entity = '';
            characters = '';
            test = tests[type];
            end--;

            while (++end < length) {
              following = value.charCodeAt(end);

              if (!test(following)) {
                break;
              }

              characters += fromCharCode(following); // Check if we can match a legacy named reference.
              // If so, we cache that as the last viable named reference.
              // This ensures we do not need to walk backwards later.

              if (type === name && own.call(legacy, characters)) {
                entityCharacters = characters;
                entity = legacy[characters];
              }
            }

            terminated = value.charCodeAt(end) === semicolon;

            if (terminated) {
              end++;
              namedEntity = type === name ? decodeEntity(characters) : false;

              if (namedEntity) {
                entityCharacters = characters;
                entity = namedEntity;
              }
            }

            diff = 1 + end - start;

            if (!terminated && !nonTerminated) {// Empty.
            } else if (!characters) {
              // An empty (possible) entity is valid, unless it’s numeric (thus an
              // ampersand followed by an octothorp).
              if (type !== name) {
                warning(numericEmpty, diff);
              }
            } else if (type === name) {
              // An ampersand followed by anything unknown, and not terminated, is
              // invalid.
              if (terminated && !entity) {
                warning(namedUnknown, 1);
              } else {
                // If theres something after an entity name which is not known, cap
                // the reference.
                if (entityCharacters !== characters) {
                  end = begin + entityCharacters.length;
                  diff = 1 + end - begin;
                  terminated = false;
                } // If the reference is not terminated, warn.


                if (!terminated) {
                  reason = entityCharacters ? namedNotTerminated : namedEmpty;

                  if (settings.attribute) {
                    following = value.charCodeAt(end);

                    if (following === equalsTo) {
                      warning(reason, diff);
                      entity = null;
                    } else if (alphanumerical(following)) {
                      entity = null;
                    } else {
                      warning(reason, diff);
                    }
                  } else {
                    warning(reason, diff);
                  }
                }
              }

              reference = entity;
            } else {
              if (!terminated) {
                // All non-terminated numeric entities are not rendered, and trigger a
                // warning.
                warning(numericNotTerminated, diff);
              } // When terminated and number, parse as either hexadecimal or decimal.


              reference = parseInt(characters, bases[type]); // Trigger a warning when the parsed number is prohibited, and replace
              // with replacement character.

              if (prohibited(reference)) {
                warning(numericProhibited, diff);
                reference = fromCharCode(replacementCharacter);
              } else if (reference in invalid) {
                // Trigger a warning when the parsed number is disallowed, and replace
                // by an alternative.
                warning(numericDisallowed, diff);
                reference = invalid[reference];
              } else {
                // Parse the number.
                output = ''; // Trigger a warning when the parsed number should not be used.

                if (disallowed(reference)) {
                  warning(numericDisallowed, diff);
                } // Stringify the number.


                if (reference > 0xffff) {
                  reference -= 0x10000;
                  output += fromCharCode(reference >>> (10 & 0x3ff) | 0xd800);
                  reference = 0xdc00 | reference & 0x3ff;
                }

                reference = output + fromCharCode(reference);
              }
            } // Found it!
            // First eat the queued characters as normal text, then eat an entity.


            if (reference) {
              flush();
              prev = now();
              index = end - 1;
              column += end - start + 1;
              result.push(reference);
              next = now();
              next.offset++;

              if (handleReference) {
                handleReference.call(referenceContext, reference, {
                  start: prev,
                  end: next
                }, value.slice(start - 1, end));
              }

              prev = next;
            } else {
              // If we could not find a reference, queue the checked characters (as
              // normal characters), and move the pointer to their end.
              // This is possible because we can be certain neither newlines nor
              // ampersands are included.
              characters = value.slice(start - 1, end);
              queue += characters;
              column += characters.length;
              index = end - 1;
            }
          } else {
            // Handle anything other than an ampersand, including newlines and EOF.
            if (character === 10 // Line feed
            ) {
                line++;
                lines++;
                column = 0;
              }

            if (character === character) {
              queue += fromCharCode(character);
              column++;
            } else {
              flush();
            }
          }
        } // Return the reduced nodes.


        return result.join(''); // Get current position.

        function now() {
          return {
            line: line,
            column: column,
            offset: index + (pos.offset || 0)
          };
        } // “Throw” a parse-error: a warning.


        function parseError(code, offset) {
          var position = now();
          position.column += offset;
          position.offset += offset;
          handleWarning.call(warningContext, messages[code], position, code);
        } // Flush `queue` (normal text).
        // Macro invoked before each entity and at the end of `value`.
        // Does nothing when `queue` is empty.


        function flush() {
          if (queue) {
            result.push(queue);

            if (handleText) {
              handleText.call(textContext, queue, {
                start: prev,
                end: now()
              });
            }

            queue = '';
          }
        }
      } // Check if `character` is outside the permissible unicode range.


      function prohibited(code) {
        return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;
      } // Check if `character` is disallowed.


      function disallowed(code) {
        return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;
      }
      /***/

    },

    /***/
    "Zasy":
    /*!***********************************************!*\
      !*** ./node_modules/unist-util-is/convert.js ***!
      \***********************************************/

    /*! no static exports found */

    /***/
    function Zasy(module, exports, __webpack_require__) {
      "use strict";

      module.exports = convert;

      function convert(test) {
        if (test == null) {
          return ok;
        }

        if (typeof test === 'string') {
          return typeFactory(test);
        }

        if (typeof test === 'object') {
          return 'length' in test ? anyFactory(test) : allFactory(test);
        }

        if (typeof test === 'function') {
          return test;
        }

        throw new Error('Expected function, string, or object as test');
      } // Utility assert each property in `test` is represented in `node`, and each
      // values are strictly equal.


      function allFactory(test) {
        return all;

        function all(node) {
          var key;

          for (key in test) {
            if (node[key] !== test[key]) return false;
          }

          return true;
        }
      }

      function anyFactory(tests) {
        var checks = [];
        var index = -1;

        while (++index < tests.length) {
          checks[index] = convert(tests[index]);
        }

        return any;

        function any() {
          var index = -1;

          while (++index < checks.length) {
            if (checks[index].apply(this, arguments)) {
              return true;
            }
          }

          return false;
        }
      } // Utility to convert a string into a function which checks a given node’s type
      // for said string.


      function typeFactory(test) {
        return type;

        function type(node) {
          return Boolean(node && node.type === test);
        }
      } // Utility to return true.


      function ok() {
        return true;
      }
      /***/

    },

    /***/
    "ZkSf":
    /*!************************************************!*\
      !*** ./node_modules/unist-util-visit/index.js ***!
      \************************************************/

    /*! no static exports found */

    /***/
    function ZkSf(module, exports, __webpack_require__) {
      "use strict";

      module.exports = visit;

      var visitParents = __webpack_require__(
      /*! unist-util-visit-parents */
      "uzq8");

      var CONTINUE = visitParents.CONTINUE;
      var SKIP = visitParents.SKIP;
      var EXIT = visitParents.EXIT;
      visit.CONTINUE = CONTINUE;
      visit.SKIP = SKIP;
      visit.EXIT = EXIT;

      function visit(tree, test, visitor, reverse) {
        if (typeof test === 'function' && typeof visitor !== 'function') {
          reverse = visitor;
          visitor = test;
          test = null;
        }

        visitParents(tree, test, overload, reverse);

        function overload(node, parents) {
          var parent = parents[parents.length - 1];
          var index = parent ? parent.children.indexOf(node) : null;
          return visitor(node, index, parent);
        }
      }
      /***/

    },

    /***/
    "Zpkj":
    /*!******************************************************************!*\
      !*** ./node_modules/remark-parse/lib/util/remove-indentation.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function Zpkj(module, exports, __webpack_require__) {
      "use strict";

      var trim = __webpack_require__(
      /*! trim */
      "RsFJ");

      var repeat = __webpack_require__(
      /*! repeat-string */
      "RjOF");

      var getIndent = __webpack_require__(
      /*! ./get-indentation */
      "my8H");

      module.exports = indentation;
      var lineFeed = '\n';
      var space = ' ';
      var exclamationMark = '!'; // Remove the minimum indent from every line in `value`.  Supports both tab,
      // spaced, and mixed indentation (as well as possible).

      function indentation(value, maximum) {
        var values = value.split(lineFeed);
        var position = values.length + 1;
        var minIndent = Infinity;
        var matrix = [];
        var index;
        var indentation;
        var stops;
        values.unshift(repeat(space, maximum) + exclamationMark);

        while (position--) {
          indentation = getIndent(values[position]);
          matrix[position] = indentation.stops;

          if (trim(values[position]).length === 0) {
            continue;
          }

          if (indentation.indent) {
            if (indentation.indent > 0 && indentation.indent < minIndent) {
              minIndent = indentation.indent;
            }
          } else {
            minIndent = Infinity;
            break;
          }
        }

        if (minIndent !== Infinity) {
          position = values.length;

          while (position--) {
            stops = matrix[position];
            index = minIndent;

            while (index && !(index in stops)) {
              index--;
            }

            values[position] = values[position].slice(stops[index] + 1);
          }
        }

        values.shift();
        return values.join(lineFeed);
      }
      /***/

    },

    /***/
    "aCXt":
    /*!*********************************************!*\
      !*** ./node_modules/vfile-message/index.js ***!
      \*********************************************/

    /*! no static exports found */

    /***/
    function aCXt(module, exports, __webpack_require__) {
      "use strict";

      var stringify = __webpack_require__(
      /*! unist-util-stringify-position */
      "/qNp");

      module.exports = VMessage; // Inherit from `Error#`.

      function VMessagePrototype() {}

      VMessagePrototype.prototype = Error.prototype;
      VMessage.prototype = new VMessagePrototype(); // Message properties.

      var proto = VMessage.prototype;
      proto.file = '';
      proto.name = '';
      proto.reason = '';
      proto.message = '';
      proto.stack = '';
      proto.fatal = null;
      proto.column = null;
      proto.line = null; // Construct a new VMessage.
      //
      // Note: We cannot invoke `Error` on the created context, as that adds readonly
      // `line` and `column` attributes on Safari 9, thus throwing and failing the
      // data.

      function VMessage(reason, position, origin) {
        var parts;
        var range;
        var location;

        if (typeof position === 'string') {
          origin = position;
          position = null;
        }

        parts = parseOrigin(origin);
        range = stringify(position) || '1:1';
        location = {
          start: {
            line: null,
            column: null
          },
          end: {
            line: null,
            column: null
          }
        }; // Node.

        if (position && position.position) {
          position = position.position;
        }

        if (position) {
          // Position.
          if (position.start) {
            location = position;
            position = position.start;
          } else {
            // Point.
            location.start = position;
          }
        }

        if (reason.stack) {
          this.stack = reason.stack;
          reason = reason.message;
        }

        this.message = reason;
        this.name = range;
        this.reason = reason;
        this.line = position ? position.line : null;
        this.column = position ? position.column : null;
        this.location = location;
        this.source = parts[0];
        this.ruleId = parts[1];
      }

      function parseOrigin(origin) {
        var result = [null, null];
        var index;

        if (typeof origin === 'string') {
          index = origin.indexOf(':');

          if (index === -1) {
            result[1] = origin;
          } else {
            result[0] = origin.slice(0, index);
            result[1] = origin.slice(index + 1);
          }
        }

        return result;
      }
      /***/

    },

    /***/
    "aTp6":
    /*!*******************************************************!*\
      !*** ./node_modules/remark-parse/lib/locate/break.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function aTp6(module, exports, __webpack_require__) {
      "use strict";

      module.exports = locate;

      function locate(value, fromIndex) {
        var index = value.indexOf('\n', fromIndex);

        while (index > fromIndex) {
          if (value.charAt(index - 1) !== ' ') {
            break;
          }

          index--;
        }

        return index;
      }
      /***/

    },

    /***/
    "afWh":
    /*!*****************************************************!*\
      !*** ./node_modules/remark-parse/lib/locate/tag.js ***!
      \*****************************************************/

    /*! no static exports found */

    /***/
    function afWh(module, exports, __webpack_require__) {
      "use strict";

      module.exports = locate;

      function locate(value, fromIndex) {
        return value.indexOf('<', fromIndex);
      }
      /***/

    },

    /***/
    "bY2E":
    /*!************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/emphasis.js ***!
      \************************************************************/

    /*! no static exports found */

    /***/
    function bY2E(module, exports, __webpack_require__) {
      "use strict";

      var trim = __webpack_require__(
      /*! trim */
      "RsFJ");

      var word = __webpack_require__(
      /*! is-word-character */
      "obXZ");

      var whitespace = __webpack_require__(
      /*! is-whitespace-character */
      "IPAr");

      var locate = __webpack_require__(
      /*! ../locate/emphasis */
      "CRs9");

      module.exports = emphasis;
      emphasis.locator = locate;
      var asterisk = '*';
      var underscore = '_';
      var backslash = '\\';

      function emphasis(eat, value, silent) {
        var self = this;
        var index = 0;
        var character = value.charAt(index);
        var now;
        var pedantic;
        var marker;
        var queue;
        var subvalue;
        var length;
        var previous;

        if (character !== asterisk && character !== underscore) {
          return;
        }

        pedantic = self.options.pedantic;
        subvalue = character;
        marker = character;
        length = value.length;
        index++;
        queue = '';
        character = '';

        if (pedantic && whitespace(value.charAt(index))) {
          return;
        }

        while (index < length) {
          previous = character;
          character = value.charAt(index);

          if (character === marker && (!pedantic || !whitespace(previous))) {
            character = value.charAt(++index);

            if (character !== marker) {
              if (!trim(queue) || previous === marker) {
                return;
              }

              if (!pedantic && marker === underscore && word(character)) {
                queue += marker;
                continue;
              }
              /* istanbul ignore if - never used (yet) */


              if (silent) {
                return true;
              }

              now = eat.now();
              now.column++;
              now.offset++;
              return eat(subvalue + queue + marker)({
                type: 'emphasis',
                children: self.tokenizeInline(queue, now)
              });
            }

            queue += marker;
          }

          if (!pedantic && character === backslash) {
            queue += character;
            character = value.charAt(++index);
          }

          queue += character;
          index++;
        }
      }
      /***/

    },

    /***/
    "bspj":
    /*!***************************************************!*\
      !*** ./markdown/src/lib/block/block.component.ts ***!
      \***************************************************/

    /*! exports provided: MarkdownBlock */

    /***/
    function bspj(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "MarkdownBlock", function () {
        return MarkdownBlock;
      });
      /* harmony import */


      var _tree_tree_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ../tree/tree.service */
      "6opK");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");

      var _c0 = ["wm-block", ""];

      function MarkdownBlock_ng_container_0_ng_container_2_h1_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "h1", 10);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2).$implicit;

          var ctx_r12 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("id", ctx_r12.toc(child_r1))("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("data-line", ctx_r12.pos(child_r1));
        }
      }

      function MarkdownBlock_ng_container_0_ng_container_2_h2_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "h2", 10);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2).$implicit;

          var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("id", ctx_r13.toc(child_r1))("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("data-line", ctx_r13.pos(child_r1));
        }
      }

      function MarkdownBlock_ng_container_0_ng_container_2_h3_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "h3", 10);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2).$implicit;

          var ctx_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("id", ctx_r14.toc(child_r1))("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("data-line", ctx_r14.pos(child_r1));
        }
      }

      function MarkdownBlock_ng_container_0_ng_container_2_h4_4_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "h4", 10);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2).$implicit;

          var ctx_r15 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("id", ctx_r15.toc(child_r1))("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("data-line", ctx_r15.pos(child_r1));
        }
      }

      function MarkdownBlock_ng_container_0_ng_container_2_h5_5_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "h5", 10);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2).$implicit;

          var ctx_r16 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("id", ctx_r16.toc(child_r1))("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("data-line", ctx_r16.pos(child_r1));
        }
      }

      function MarkdownBlock_ng_container_0_ng_container_2_h6_6_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "h6", 10);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2).$implicit;

          var ctx_r17 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("id", ctx_r17.toc(child_r1))("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("data-line", ctx_r17.pos(child_r1));
        }
      }

      function MarkdownBlock_ng_container_0_ng_container_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](1, MarkdownBlock_ng_container_0_ng_container_2_h1_1_Template, 1, 3, "h1", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](2, MarkdownBlock_ng_container_0_ng_container_2_h2_2_Template, 1, 3, "h2", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](3, MarkdownBlock_ng_container_0_ng_container_2_h3_3_Template, 1, 3, "h3", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](4, MarkdownBlock_ng_container_0_ng_container_2_h4_4_Template, 1, 3, "h4", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](5, MarkdownBlock_ng_container_0_ng_container_2_h5_5_Template, 1, 3, "h5", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](6, MarkdownBlock_ng_container_0_ng_container_2_h6_6_Template, 1, 3, "h6", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", child_r1.depth === 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", child_r1.depth === 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", child_r1.depth === 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", child_r1.depth === 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", child_r1.depth === 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", child_r1.depth === 6);
        }
      }

      function MarkdownBlock_ng_container_0_p_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "p", 11);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]().$implicit;

          var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("data-line", ctx_r3.pos(child_r1));
        }
      }

      function MarkdownBlock_ng_container_0_ng_container_4_ol_1_li_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "li", 16);
        }

        if (rf & 2) {
          var item_r29 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("wm-block", item_r29);
        }
      }

      function MarkdownBlock_ng_container_0_ng_container_4_ol_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](0, "ol", 14);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](1, MarkdownBlock_ng_container_0_ng_container_4_ol_1_li_1_Template, 1, 1, "li", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2).$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("start", child_r1.start);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngForOf", child_r1.children);
        }
      }

      function MarkdownBlock_ng_container_0_ng_container_4_ul_2_li_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "li", 16);
        }

        if (rf & 2) {
          var item_r32 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("wm-block", item_r32);
        }
      }

      function MarkdownBlock_ng_container_0_ng_container_4_ul_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](0, "ul");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](1, MarkdownBlock_ng_container_0_ng_container_4_ul_2_li_1_Template, 1, 1, "li", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](2).$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngForOf", child_r1.children);
        }
      }

      function MarkdownBlock_ng_container_0_ng_container_4_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](1, MarkdownBlock_ng_container_0_ng_container_4_ol_1_Template, 2, 2, "ol", 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](2, MarkdownBlock_ng_container_0_ng_container_4_ul_2_Template, 2, 1, "ul", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", child_r1.ordered);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngIf", !child_r1.ordered);
        }
      }

      function MarkdownBlock_ng_container_0_table_5_tr_2_td_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "td", 11);
        }

        if (rf & 2) {
          var cell_r38 = ctx.$implicit;
          var i_r39 = ctx.index;

          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"](3).$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("wm-inline", cell_r38);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("align", child_r1.align[i_r39] || "");
        }
      }

      function MarkdownBlock_ng_container_0_table_5_tr_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](0, "tr");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](1, MarkdownBlock_ng_container_0_table_5_tr_2_td_1_Template, 1, 2, "td", 17);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var row_r36 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngForOf", row_r36.children);
        }
      }

      function MarkdownBlock_ng_container_0_table_5_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](0, "table");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](1, "tbody");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](2, MarkdownBlock_ng_container_0_table_5_tr_2_Template, 2, 1, "tr", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]().$implicit;

          var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("data-line", ctx_r5.pos(child_r1));

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngForOf", child_r1.children);
        }
      }

      function MarkdownBlock_ng_container_0_hr_6_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "hr");
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]().$implicit;

          var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("data-line", ctx_r6.pos(child_r1));
        }
      }

      function MarkdownBlock_ng_container_0_blockquote_7_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "blockquote", 16);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("wm-block", child_r1);
        }
      }

      function MarkdownBlock_ng_container_0_span_8_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "span", 18);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("wm-block", child_r1);
        }
      }

      function MarkdownBlock_ng_container_0_span_9_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "span", 19);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("wm-block", child_r1);
        }
      }

      function MarkdownBlock_ng_container_0_span_10_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelement"](0, "span", 20);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("wm-block", child_r1);
        }
      }

      function MarkdownBlock_ng_container_0_pre_11_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](0, "pre", 21);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtext"](1, "      ");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtext"](2, "\n      ");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementStart"](3, "code");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtext"](4);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtext"](5, "\n    ");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]().$implicit;

          var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("disabled", ctx_r11.tree.disableHighlighting)("language", child_r1.lang)("wm-prism", child_r1.value);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("data-line", ctx_r11.pos(child_r1));

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](4);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtextInterpolate"](child_r1.value);
        }
      }

      function MarkdownBlock_ng_container_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerStart"](1, 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](2, MarkdownBlock_ng_container_0_ng_container_2_Template, 7, 6, "ng-container", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](3, MarkdownBlock_ng_container_0_p_3_Template, 1, 2, "p", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](4, MarkdownBlock_ng_container_0_ng_container_4_Template, 3, 2, "ng-container", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](5, MarkdownBlock_ng_container_0_table_5_Template, 3, 2, "table", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](6, MarkdownBlock_ng_container_0_hr_6_Template, 1, 1, "hr", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](7, MarkdownBlock_ng_container_0_blockquote_7_Template, 1, 1, "blockquote", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](8, MarkdownBlock_ng_container_0_span_8_Template, 1, 1, "span", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](9, MarkdownBlock_ng_container_0_span_9_Template, 1, 1, "span", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](10, MarkdownBlock_ng_container_0_span_10_Template, 1, 1, "span", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](11, MarkdownBlock_ng_container_0_pre_11_Template, 6, 5, "pre", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var child_r1 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngSwitch", child_r1.type);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngSwitchCase", "heading");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngSwitchCase", "paragraph");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngSwitchCase", "list");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngSwitchCase", "table");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngSwitchCase", "thematicBreak");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngSwitchCase", "blockquote");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngSwitchCase", "leftAligned");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngSwitchCase", "centerAligned");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngSwitchCase", "rightAligned");

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngSwitchCase", "code");
        }
      }
      /** Renders a markdown text into an angular view */


      var MarkdownBlock = /*#__PURE__*/function () {
        function MarkdownBlock(tree) {
          _classCallCheck(this, MarkdownBlock);

          this.tree = tree;
        } // AOT safe children from the node


        _createClass(MarkdownBlock, [{
          key: "children",
          get: function get() {
            return "children" in this.node ? this.node.children : [];
          } // Table of content anchor helper

        }, {
          key: "toc",
          value: function toc(heading) {
            return this.tree.text(heading) // Removes any non alphanumerical characters (keeps spaces)
            .replace(/[^a-zA-Z0-9 ]/g, '') // Replaces spaces with '-'
            .replace(/\s+/g, '-') // Lowers the case
            .toLowerCase();
          }
        }, {
          key: "pos",
          value: function pos(node) {
            return '' + (!!node && !!node.position && node.position.start.line);
          }
        }]);

        return MarkdownBlock;
      }();

      MarkdownBlock.ɵfac = function MarkdownBlock_Factory(t) {
        return new (t || MarkdownBlock)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_tree_tree_service__WEBPACK_IMPORTED_MODULE_0__["MarkdownTree"]));
      };

      MarkdownBlock.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineComponent"]({
        type: MarkdownBlock,
        selectors: [["", "wm-block", ""]],
        inputs: {
          node: ["wm-block", "node"]
        },
        attrs: _c0,
        decls: 1,
        vars: 1,
        consts: [[4, "ngFor", "ngForOf"], [3, "ngSwitch"], [4, "ngSwitchCase"], [3, "wm-inline", 4, "ngSwitchCase"], [3, "wm-block", 4, "ngSwitchCase"], ["align", "left", 3, "wm-block", 4, "ngSwitchCase"], ["align", "center", 3, "wm-block", 4, "ngSwitchCase"], ["align", "right", 3, "wm-block", 4, "ngSwitchCase"], [3, "disabled", "language", "wm-prism", 4, "ngSwitchCase"], [3, "id", "wm-inline", 4, "ngIf"], [3, "id", "wm-inline"], [3, "wm-inline"], [3, "start", 4, "ngIf"], [4, "ngIf"], [3, "start"], [3, "wm-block", 4, "ngFor", "ngForOf"], [3, "wm-block"], [3, "wm-inline", 4, "ngFor", "ngForOf"], ["align", "left", 3, "wm-block"], ["align", "center", 3, "wm-block"], ["align", "right", 3, "wm-block"], [3, "disabled", "language", "wm-prism"]],
        template: function MarkdownBlock_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵtemplate"](0, MarkdownBlock_ng_container_0_Template, 12, 11, "ng-container", 0);
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵproperty"]("ngForOf", ctx.children);
          }
        },
        styles: [".wm-markdown[inline] * {\n  display: inline;\n}\n.wm-markdown p {\n  text-align: justify;\n}\n.wm-markdown td[align=left] {\n  text-align: left;\n}\n.wm-markdown td[align=center] {\n  text-align: center;\n}\n.wm-markdown td[align=right] {\n  text-align: right;\n}\n.wm-markdown span[align=left] > h1, .wm-markdown span[align=left] h2, .wm-markdown span[align=left] h3, .wm-markdown span[align=left] h4, .wm-markdown span[align=left] h5, .wm-markdown span[align=left] h6, .wm-markdown span[align=left] p {\n  text-align: left;\n}\n.wm-markdown span[align=left] > table {\n  margin-right: auto;\n}\n.wm-markdown span[align=center] > h1, .wm-markdown span[align=center] h2, .wm-markdown span[align=center] h3, .wm-markdown span[align=center] h4, .wm-markdown span[align=center] h5, .wm-markdown span[align=center] h6, .wm-markdown span[align=center] p {\n  text-align: center;\n}\n.wm-markdown span[align=center] > table {\n  margin-left: auto;\n  margin-right: auto;\n}\n.wm-markdown span[align=right] > h1, .wm-markdown span[align=right] h2, .wm-markdown span[align=right] h3, .wm-markdown span[align=right] h4, .wm-markdown span[align=right] h5, .wm-markdown span[align=right] h6, .wm-markdown span[align=right] p {\n  text-align: right;\n}\n.wm-markdown span[align=right] > table {\n  margin-left: auto;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2Jsb2NrLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdjO0VBQUksZUFBQTtBQURsQjtBQUlFO0VBQUksbUJBQUE7QUFETjtBQUtJO0VBQWtCLGdCQUFBO0FBRnRCO0FBR0k7RUFBb0Isa0JBQUE7QUFBeEI7QUFDSTtFQUFtQixpQkFBQTtBQUV2QjtBQU1NO0VBQ0UsZ0JBQUE7QUFKUjtBQU9NO0VBQ0Usa0JBQUE7QUFMUjtBQVVNO0VBQ0Usa0JBQUE7QUFSUjtBQVVNO0VBQ0UsaUJBQUE7RUFDQSxrQkFBQTtBQVJSO0FBYU07RUFDRSxpQkFBQTtBQVhSO0FBYU07RUFDRSxpQkFBQTtBQVhSIiwiZmlsZSI6ImJsb2NrLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiXG4ud20tbWFya2Rvd24ge1xuICAvLyBGb3JjZXMgYWxsIHRoZSBlbGVtZW50cyB0byBpbmxpbmUgXG4gICZbaW5saW5lXSB7ICogeyBkaXNwbGF5OiBpbmxpbmU7IH0gfVxuXG4gIC8vIEp1c3RpZmllcyBwYXJhZ3JhcGhzIGJ5IGRlZmF1bHRcbiAgcCB7IHRleHQtYWxpZ246IGp1c3RpZnk7IH1cblxuICAvLyBUYWJsZSBjZWxscyBhbGlnbmVtZW50XG4gIHRkIHtcbiAgICAmW2FsaWduPVwibGVmdFwiXSB7IHRleHQtYWxpZ246IGxlZnQ7IH1cbiAgICAmW2FsaWduPVwiY2VudGVyXCJdIHsgdGV4dC1hbGlnbjogY2VudGVyOyB9XG4gICAgJlthbGlnbj1cInJpZ2h0XCJdIHsgdGV4dC1hbGlnbjogcmlnaHQ7IH1cbiAgfVxuXG4gIC8vIEJsb2NrIGFsaWduZW1lbnRcbiAgc3BhbiB7XG5cbiAgICAvLyBBbGlnbnMgY2hpbGRyZW4gaGVhZGluZ3MgYW5kIHBhcmFncmFwaHNcbiAgICAmW2FsaWduPVwibGVmdFwiXSAgeyBcbiAgICAgICYgPiBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBwIHsgXG4gICAgICAgIHRleHQtYWxpZ246IGxlZnQ7IFxuICAgICAgfVxuICAgICAgLy8gQWxpZ25zIGNoaWxkcmVuIHRhYmxlc1xuICAgICAgJiA+IHRhYmxlIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiBhdXRvOyBcbiAgICAgIH1cbiAgICB9XG4gICAgICBcbiAgICAmW2FsaWduPVwiY2VudGVyXCJdIHsgXG4gICAgICAmID4gaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgcCB7IFxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxuICAgICAgfVxuICAgICAgJiA+IHRhYmxlIHsgXG4gICAgICAgIG1hcmdpbi1sZWZ0OiBhdXRvOyBcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiBhdXRvOyBcbiAgICAgIH1cbiAgICB9XG5cbiAgICAmW2FsaWduPVwicmlnaHRcIl0geyBcbiAgICAgICYgPiBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBwIHsgXG4gICAgICAgIHRleHQtYWxpZ246IHJpZ2h0OyBcbiAgICAgIH1cbiAgICAgICYgPiB0YWJsZSB7IFxuICAgICAgICBtYXJnaW4tbGVmdDogYXV0bzsgXG4gICAgICB9XG4gICAgfVxuICB9XG59Il19 */"],
        encapsulation: 2
      });
      /***/
    },

    /***/
    "cBNe":
    /*!**********************************************************!*\
      !*** ./node_modules/unist-util-remove-position/index.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function cBNe(module, exports, __webpack_require__) {
      "use strict";

      var visit = __webpack_require__(
      /*! unist-util-visit */
      "ZkSf");

      module.exports = removePosition;

      function removePosition(node, force) {
        visit(node, force ? hard : soft);
        return node;
      }

      function hard(node) {
        delete node.position;
      }

      function soft(node) {
        node.position = undefined;
      }
      /***/

    },

    /***/
    "eyKa":
    /*!*****************************************************!*\
      !*** ./wizdm/src/app/pages/static/static.module.ts ***!
      \*****************************************************/

    /*! exports provided: StaticModule */

    /***/
    function eyKa(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "StaticModule", function () {
        return StaticModule;
      });
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/common */
      "SVse");
      /* harmony import */


      var _angular_common_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/common/http */
      "IheW");
      /* harmony import */


      var _angular_material_divider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/material/divider */
      "BSbQ");
      /* harmony import */


      var _angular_material_button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @angular/material/button */
      "Dxy4");
      /* harmony import */


      var _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! @angular/material/tooltip */
      "ZFy/");
      /* harmony import */


      var _wizdm_content__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! @wizdm/content */
      "g7MM");
      /* harmony import */


      var _wizdm_gtag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
      /*! @wizdm/gtag */
      "fi6C");
      /* harmony import */


      var _wizdm_animate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
      /*! @wizdm/animate */
      "EycX");
      /* harmony import */


      var _wizdm_markdown__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
      /*! @wizdm/markdown */
      "Q1h6");
      /* harmony import */


      var _wizdm_prism__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
      /*! @wizdm/prism */
      "6lw0");
      /* harmony import */


      var _wizdm_elements_icon__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
      /*! @wizdm/elements/icon */
      "txmD");
      /* harmony import */


      var app_navigator_fab__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
      /*! app/navigator/fab */
      "u8yb");
      /* harmony import */


      var app_navigator_sidenav__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
      /*! app/navigator/sidenav */
      "sFr1");
      /* harmony import */


      var app_navigator_actionbar__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
      /*! app/navigator/actionbar */
      "kNiW");
      /* harmony import */


      var app_utils_scrolling__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
      /*! app/utils/scrolling */
      "DwbE");
      /* harmony import */


      var app_utils_size_lock__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
      /*! app/utils/size-lock */
      "l+ob");
      /* harmony import */


      var _static_resolver_service__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
      /*! ./static-resolver.service */
      "xeKF");
      /* harmony import */


      var _static_component__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(
      /*! ./static.component */
      "hB5y");
      /* harmony import */


      var _toc__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(
      /*! ./toc */
      "q4Aa");
      /* harmony import */


      var env_environment__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(
      /*! env/environment */
      "HOC2");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /* harmony import */


      var _markdown_src_lib_markdown_module__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(
      /*! ../../../../../markdown/src/lib/markdown.module */
      "JZ3d");
      /* harmony import */


      var _prism_src_lib_prism_module__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(
      /*! ../../../../../prism/src/lib/prism.module */
      "FkM1");
      /* harmony import */


      var _content_src_lib_router_content_router_module__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(
      /*! ../../../../../content/src/lib/router/content-router.module */
      "J3Me"); // Environment


      var _env_environment__WEB = env_environment__WEBPACK_IMPORTED_MODULE_19__["environment"],
          markdown = _env_environment__WEB.markdown,
          prism = _env_environment__WEB.prism;
      var routes = [{
        path: '',
        content: 'static',
        component: _static_component__WEBPACK_IMPORTED_MODULE_17__["StaticComponent"],
        data: {
          source: 'assets/doc'
        },
        resolve: {
          document: _static_resolver_service__WEBPACK_IMPORTED_MODULE_16__["StaticResolver"]
        }
      }];

      var StaticModule = function StaticModule() {
        _classCallCheck(this, StaticModule);
      };

      StaticModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_20__["ɵɵdefineNgModule"]({
        type: StaticModule
      });
      StaticModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_20__["ɵɵdefineInjector"]({
        factory: function StaticModule_Factory(t) {
          return new (t || StaticModule)();
        },
        providers: [_static_resolver_service__WEBPACK_IMPORTED_MODULE_16__["StaticResolver"]],
        imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"], _angular_common_http__WEBPACK_IMPORTED_MODULE_1__["HttpClientModule"], _angular_material_divider__WEBPACK_IMPORTED_MODULE_2__["MatDividerModule"], _angular_material_button__WEBPACK_IMPORTED_MODULE_3__["MatButtonModule"], _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_4__["MatTooltipModule"], _wizdm_gtag__WEBPACK_IMPORTED_MODULE_6__["GtagModule"], _wizdm_animate__WEBPACK_IMPORTED_MODULE_7__["AnimateModule"], _wizdm_elements_icon__WEBPACK_IMPORTED_MODULE_10__["IconModule"], app_navigator_fab__WEBPACK_IMPORTED_MODULE_11__["FabModule"], app_navigator_sidenav__WEBPACK_IMPORTED_MODULE_12__["SidenavModule"], app_navigator_actionbar__WEBPACK_IMPORTED_MODULE_13__["ActionbarModule"], app_utils_scrolling__WEBPACK_IMPORTED_MODULE_14__["ScrollingModule"], app_utils_size_lock__WEBPACK_IMPORTED_MODULE_15__["SizeLockModule"], _toc__WEBPACK_IMPORTED_MODULE_18__["TocModule"], _wizdm_markdown__WEBPACK_IMPORTED_MODULE_8__["MarkdownModule"].init(markdown), _wizdm_prism__WEBPACK_IMPORTED_MODULE_9__["PrismModule"].init(prism), _wizdm_content__WEBPACK_IMPORTED_MODULE_5__["ContentRouterModule"].forChild(routes)]]
      });

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_20__["ɵɵsetNgModuleScope"](StaticModule, {
          declarations: [_static_component__WEBPACK_IMPORTED_MODULE_17__["StaticComponent"]],
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"], _angular_common_http__WEBPACK_IMPORTED_MODULE_1__["HttpClientModule"], _angular_material_divider__WEBPACK_IMPORTED_MODULE_2__["MatDividerModule"], _angular_material_button__WEBPACK_IMPORTED_MODULE_3__["MatButtonModule"], _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_4__["MatTooltipModule"], _wizdm_gtag__WEBPACK_IMPORTED_MODULE_6__["GtagModule"], _wizdm_animate__WEBPACK_IMPORTED_MODULE_7__["AnimateModule"], _wizdm_elements_icon__WEBPACK_IMPORTED_MODULE_10__["IconModule"], app_navigator_fab__WEBPACK_IMPORTED_MODULE_11__["FabModule"], app_navigator_sidenav__WEBPACK_IMPORTED_MODULE_12__["SidenavModule"], app_navigator_actionbar__WEBPACK_IMPORTED_MODULE_13__["ActionbarModule"], app_utils_scrolling__WEBPACK_IMPORTED_MODULE_14__["ScrollingModule"], app_utils_size_lock__WEBPACK_IMPORTED_MODULE_15__["SizeLockModule"], _toc__WEBPACK_IMPORTED_MODULE_18__["TocModule"], _markdown_src_lib_markdown_module__WEBPACK_IMPORTED_MODULE_21__["MarkdownModule"], _prism_src_lib_prism_module__WEBPACK_IMPORTED_MODULE_22__["PrismModule"], _content_src_lib_router_content_router_module__WEBPACK_IMPORTED_MODULE_23__["ContentRouterModule"]]
        });
      })();
      /***/

    },

    /***/
    "fUUT":
    /*!********************************************!*\
      !*** ./node_modules/remark-parse/index.js ***!
      \********************************************/

    /*! no static exports found */

    /***/
    function fUUT(module, exports, __webpack_require__) {
      "use strict";

      var unherit = __webpack_require__(
      /*! unherit */
      "5t69");

      var xtend = __webpack_require__(
      /*! xtend */
      "U6jy");

      var Parser = __webpack_require__(
      /*! ./lib/parser.js */
      "fduw");

      module.exports = parse;
      parse.Parser = Parser;

      function parse(options) {
        var settings = this.data('settings');
        var Local = unherit(Parser);
        Local.prototype.options = xtend(Local.prototype.options, settings, options);
        this.Parser = Local;
      }
      /***/

    },

    /***/
    "fduw":
    /*!*************************************************!*\
      !*** ./node_modules/remark-parse/lib/parser.js ***!
      \*************************************************/

    /*! no static exports found */

    /***/
    function fduw(module, exports, __webpack_require__) {
      "use strict";

      var xtend = __webpack_require__(
      /*! xtend */
      "U6jy");

      var toggle = __webpack_require__(
      /*! state-toggle */
      "4MqD");

      var vfileLocation = __webpack_require__(
      /*! vfile-location */
      "7nPM");

      var unescape = __webpack_require__(
      /*! ./unescape */
      "EQPF");

      var decode = __webpack_require__(
      /*! ./decode */
      "Olrm");

      var tokenizer = __webpack_require__(
      /*! ./tokenizer */
      "A6mZ");

      module.exports = Parser;

      function Parser(doc, file) {
        this.file = file;
        this.offset = {};
        this.options = xtend(this.options);
        this.setOptions({});
        this.inList = false;
        this.inBlock = false;
        this.inLink = false;
        this.atStart = true;
        this.toOffset = vfileLocation(file).toOffset;
        this.unescape = unescape(this, 'escape');
        this.decode = decode(this);
      }

      var proto = Parser.prototype; // Expose core.

      proto.setOptions = __webpack_require__(
      /*! ./set-options */
      "nLKB");
      proto.parse = __webpack_require__(
      /*! ./parse */
      "zK1H"); // Expose `defaults`.

      proto.options = __webpack_require__(
      /*! ./defaults */
      "0lR2"); // Enter and exit helpers.

      proto.exitStart = toggle('atStart', true);
      proto.enterList = toggle('inList', false);
      proto.enterLink = toggle('inLink', false);
      proto.enterBlock = toggle('inBlock', false); // Nodes that can interupt a paragraph:
      //
      // ```markdown
      // A paragraph, followed by a thematic break.
      // ___
      // ```
      //
      // In the above example, the thematic break “interupts” the paragraph.

      proto.interruptParagraph = [['thematicBreak'], ['list'], ['atxHeading'], ['fencedCode'], ['blockquote'], ['html'], ['setextHeading', {
        commonmark: false
      }], ['definition', {
        commonmark: false
      }]]; // Nodes that can interupt a list:
      //
      // ```markdown
      // - One
      // ___
      // ```
      //
      // In the above example, the thematic break “interupts” the list.

      proto.interruptList = [['atxHeading', {
        pedantic: false
      }], ['fencedCode', {
        pedantic: false
      }], ['thematicBreak', {
        pedantic: false
      }], ['definition', {
        commonmark: false
      }]]; // Nodes that can interupt a blockquote:
      //
      // ```markdown
      // > A paragraph.
      // ___
      // ```
      //
      // In the above example, the thematic break “interupts” the blockquote.

      proto.interruptBlockquote = [['indentedCode', {
        commonmark: true
      }], ['fencedCode', {
        commonmark: true
      }], ['atxHeading', {
        commonmark: true
      }], ['setextHeading', {
        commonmark: true
      }], ['thematicBreak', {
        commonmark: true
      }], ['html', {
        commonmark: true
      }], ['list', {
        commonmark: true
      }], ['definition', {
        commonmark: false
      }]]; // Handlers.

      proto.blockTokenizers = {
        blankLine: __webpack_require__(
        /*! ./tokenize/blank-line */
        "l4Y6"),
        indentedCode: __webpack_require__(
        /*! ./tokenize/code-indented */
        "K2KW"),
        fencedCode: __webpack_require__(
        /*! ./tokenize/code-fenced */
        "Gqj6"),
        blockquote: __webpack_require__(
        /*! ./tokenize/blockquote */
        "PIlL"),
        atxHeading: __webpack_require__(
        /*! ./tokenize/heading-atx */
        "MHMH"),
        thematicBreak: __webpack_require__(
        /*! ./tokenize/thematic-break */
        "pyet"),
        list: __webpack_require__(
        /*! ./tokenize/list */
        "tGWH"),
        setextHeading: __webpack_require__(
        /*! ./tokenize/heading-setext */
        "NS2H"),
        html: __webpack_require__(
        /*! ./tokenize/html-block */
        "ZJXm"),
        definition: __webpack_require__(
        /*! ./tokenize/definition */
        "HRR4"),
        table: __webpack_require__(
        /*! ./tokenize/table */
        "ujgL"),
        paragraph: __webpack_require__(
        /*! ./tokenize/paragraph */
        "RSXs")
      };
      proto.inlineTokenizers = {
        escape: __webpack_require__(
        /*! ./tokenize/escape */
        "tgay"),
        autoLink: __webpack_require__(
        /*! ./tokenize/auto-link */
        "2yk8"),
        url: __webpack_require__(
        /*! ./tokenize/url */
        "UBI6"),
        email: __webpack_require__(
        /*! ./tokenize/email */
        "kRHz"),
        html: __webpack_require__(
        /*! ./tokenize/html-inline */
        "VRSw"),
        link: __webpack_require__(
        /*! ./tokenize/link */
        "jWrk"),
        reference: __webpack_require__(
        /*! ./tokenize/reference */
        "wCsn"),
        strong: __webpack_require__(
        /*! ./tokenize/strong */
        "KX5q"),
        emphasis: __webpack_require__(
        /*! ./tokenize/emphasis */
        "bY2E"),
        deletion: __webpack_require__(
        /*! ./tokenize/delete */
        "UIh7"),
        code: __webpack_require__(
        /*! ./tokenize/code-inline */
        "JlFY"),
        "break": __webpack_require__(
        /*! ./tokenize/break */
        "497W"),
        text: __webpack_require__(
        /*! ./tokenize/text */
        "SbiQ")
      }; // Expose precedence.

      proto.blockMethods = keys(proto.blockTokenizers);
      proto.inlineMethods = keys(proto.inlineTokenizers); // Tokenizers.

      proto.tokenizeBlock = tokenizer('block');
      proto.tokenizeInline = tokenizer('inline');
      proto.tokenizeFactory = tokenizer; // Get all keys in `value`.

      function keys(value) {
        var result = [];
        var key;

        for (key in value) {
          result.push(key);
        }

        return result;
      }
      /***/

    },

    /***/
    "fhd8":
    /*!****************************************!*\
      !*** ./prism/src/lib/prism.service.ts ***!
      \****************************************/

    /*! exports provided: LANGUAGE_MODULES, PrismService */

    /***/
    function fhd8(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "LANGUAGE_MODULES", function () {
        return LANGUAGE_MODULES;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "PrismService", function () {
        return PrismService;
      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /* harmony import */


      var prismjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! prismjs */
      "wZee");
      /* harmony import */


      var prismjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_1__);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! rxjs */
      "qCKp");
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! rxjs/operators */
      "kU1M");
      /** Prism Language Modules Token */


      var LANGUAGE_MODULES = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('wizdm.prism.language.modules');
      /** @dynamic - tells ngc to ignore the error on type PrismLanguages generated by strictEmitMetadata: true */

      var PrismService = /*#__PURE__*/function () {
        function PrismService(languages) {
          _classCallCheck(this, PrismService);

          this.languages = languages;
        }
        /** Tokenizes the input source by loading the grammar dynamically whenever necessary */


        _createClass(PrismService, [{
          key: "tokenize",
          value: function tokenize(source, language) {
            // Skips invalid source
            if (!source) {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(['']);
            } // Loads the grammar and tokenizes the source accordingly


            return this.loadGrammar(language).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (grammar) {
              return !!grammar ? prismjs__WEBPACK_IMPORTED_MODULE_1___default.a.tokenize(source, grammar) : [source];
            }));
          }
          /** Loads the Grammar */

        }, {
          key: "loadGrammar",
          value: function loadGrammar(language) {
            // No language, no grammar...
            if (!language) {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(undefined);
            } // Verifies the grammar has been already loaded


            if (prismjs__WEBPACK_IMPORTED_MODULE_1___default.a.languages[language]) {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(prismjs__WEBPACK_IMPORTED_MODULE_1___default.a.languages[language]);
            } // Attempts to load the grammar dynamically


            var loader = this.languages && this.languages.find(function (_ref) {
              var name = _ref.name;
              // Matches the requested language
              return Array.isArray(name) ? name.indexOf(language) >= 0 : name === language || name === '*';
            }); // Abort when no loader is found

            if (!loader) {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(undefined);
            } // Resolves the grammar by loading the module


            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["from"])(loader.load(language)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function () {
              return prismjs__WEBPACK_IMPORTED_MODULE_1___default.a.languages[language];
            }));
          }
        }]);

        return PrismService;
      }();

      PrismService.ɵfac = function PrismService_Factory(t) {
        return new (t || PrismService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](LANGUAGE_MODULES, 8));
      };

      PrismService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
        token: PrismService,
        factory: PrismService.ɵfac
      });
      /***/
    },

    /***/
    "fjrl":
    /*!**********************************************!*\
      !*** ./node_modules/is-hexadecimal/index.js ***!
      \**********************************************/

    /*! no static exports found */

    /***/
    function fjrl(module, exports, __webpack_require__) {
      "use strict";

      module.exports = hexadecimal; // Check if the given character code, or the character code at the first
      // character, is hexadecimal.

      function hexadecimal(character) {
        var code = typeof character === 'string' ? character.charCodeAt(0) : character;
        return code >= 97
        /* a */
        && code <= 102 ||
        /* z */
        code >= 65
        /* A */
        && code <= 70
        /* Z */
        || code >= 48
        /* A */
        && code <= 57
        /* Z */
        ;
      }
      /***/

    },

    /***/
    "hB5y":
    /*!********************************************************!*\
      !*** ./wizdm/src/app/pages/static/static.component.ts ***!
      \********************************************************/

    /*! exports provided: StaticComponent */

    /***/
    function hB5y(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "StaticComponent", function () {
        return StaticComponent;
      });
      /* harmony import */


      var _angular_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/router */
      "iInd");
      /* harmony import */


      var _wizdm_redirect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @wizdm/redirect */
      "CSIE");
      /* harmony import */


      var _toc_toc_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! ./toc/toc.component */
      "IOn0");
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! rxjs/operators */
      "kU1M");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /* harmony import */


      var _content_src_lib_streamer_content_directive__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! ../../../../../content/src/lib/streamer/content.directive */
      "Qfjl");
      /* harmony import */


      var _animate_src_lib_animate_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
      /*! ../../../../../animate/src/lib/animate.component */
      "/H1K");
      /* harmony import */


      var _utils_size_lock_size_lock_directive__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
      /*! ../../utils/size-lock/size-lock.directive */
      "1QJd");
      /* harmony import */


      var _markdown_src_lib_markdown_component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
      /*! ../../../../../markdown/src/lib/markdown.component */
      "xbVm");
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
      /*! @angular/common */
      "SVse");
      /* harmony import */


      var _utils_scrolling_scroll_behavior_directive__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
      /*! ../../utils/scrolling/scroll-behavior.directive */
      "OxU+");
      /* harmony import */


      var _gtag_src_lib_gtag_directive__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
      /*! ../../../../../gtag/src/lib/gtag.directive */
      "FkMH");
      /* harmony import */


      var _navigator_sidenav_sidenav_directive__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
      /*! ../../navigator/sidenav/sidenav.directive */
      "++Qg");
      /* harmony import */


      var _navigator_fab_fab_directive__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
      /*! ../../navigator/fab/fab.directive */
      "glcp");
      /* harmony import */


      var _angular_material_button__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
      /*! @angular/material/button */
      "Dxy4");
      /* harmony import */


      var _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
      /*! @angular/material/tooltip */
      "ZFy/");
      /* harmony import */


      var _elements_src_lib_icon_icon_component__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
      /*! ../../../../../elements/src/lib/icon/icon.component */
      "h0Qx");
      /* harmony import */


      var _navigator_actionbar_actionbar_directive__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(
      /*! ../../navigator/actionbar/actionbar.directive */
      "mx0f");
      /* harmony import */


      var _angular_material_divider__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(
      /*! @angular/material/divider */
      "BSbQ");

      function StaticComponent_ng_container_0_ng_container_2_ng_template_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r11 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementStart"](0, "div", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵlistener"]("navigate", function StaticComponent_ng_container_0_ng_container_2_ng_template_1_Template_div_navigate_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵrestoreView"](_r11);

            var ctx_r10 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"](3);

            return ctx_r10.navigate($event);
          })("selectedChange", function StaticComponent_ng_container_0_ng_container_2_ng_template_1_Template_div_selectedChange_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵrestoreView"](_r11);

            var mobile_r9 = ctx.isMobile;

            var ctx_r12 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"](3);

            return ctx_r12.tocChanged($event, mobile_r9);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵpipe"](1, "async");

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var toc_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"]().ngIf;

          var msgs_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"]().$implicit;

          var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("wm-toc", toc_r5.items)("path", _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵpipeBind1"](1, 3, ctx_r6.path$))("color", msgs_r3.color || "primary");
        }
      }

      function StaticComponent_ng_container_0_ng_container_2_2_ng_template_0_button_0_Template(rf, ctx) {
        if (rf & 1) {
          var _r19 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementStart"](0, "button", 10);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵlistener"]("click", function StaticComponent_ng_container_0_ng_container_2_2_ng_template_0_button_0_Template_button_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵrestoreView"](_r19);

            var ctx_r18 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"](5);

            return ctx_r18.openTOC = !ctx_r18.openTOC;
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelement"](1, "wm-icon", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var toc_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"](3).ngIf;

          var msgs_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("color", msgs_r3.color || "primary")("matTooltip", toc_r5.tooltip || "Table of contents");

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("icon", toc_r5.icon || "toc");
        }
      }

      function StaticComponent_ng_container_0_ng_container_2_2_ng_template_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵtemplate"](0, StaticComponent_ng_container_0_ng_container_2_2_ng_template_0_button_0_Template, 2, 3, "button", 9);
        }

        if (rf & 2) {
          var mobile_r16 = ctx.isMobile;

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("ngIf", !mobile_r16);
        }
      }

      function StaticComponent_ng_container_0_ng_container_2_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵtemplate"](0, StaticComponent_ng_container_0_ng_container_2_2_ng_template_0_Template, 1, 1, "ng-template", 8);
        }
      }

      function StaticComponent_ng_container_0_ng_container_2_3_ng_template_0_button_0_Template(rf, ctx) {
        if (rf & 1) {
          var _r26 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementStart"](0, "button", 14);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵlistener"]("click", function StaticComponent_ng_container_0_ng_container_2_3_ng_template_0_button_0_Template_button_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵrestoreView"](_r26);

            var ctx_r25 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"](5);

            return ctx_r25.openTOC = !ctx_r25.openTOC;
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelement"](1, "wm-icon", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var toc_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"](3).ngIf;

          var msgs_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("color", msgs_r3.color || "primary");

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("icon", toc_r5.icon || "toc");
        }
      }

      function StaticComponent_ng_container_0_ng_container_2_3_ng_template_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵtemplate"](0, StaticComponent_ng_container_0_ng_container_2_3_ng_template_0_button_0_Template, 2, 2, "button", 13);
        }

        if (rf & 2) {
          var mobile_r23 = ctx.isMobile;

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("ngIf", mobile_r23);
        }
      }

      function StaticComponent_ng_container_0_ng_container_2_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵtemplate"](0, StaticComponent_ng_container_0_ng_container_2_3_ng_template_0_Template, 1, 1, "ng-template", 12);
        }
      }

      function StaticComponent_ng_container_0_ng_container_2_Template(rf, ctx) {
        if (rf & 1) {
          var _r30 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵtemplate"](1, StaticComponent_ng_container_0_ng_container_2_ng_template_1_Template, 2, 5, "ng-template", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵlistener"]("openedChange", function StaticComponent_ng_container_0_ng_container_2_Template_ng_template_openedChange_1_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵrestoreView"](_r30);

            var ctx_r29 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"](2);

            return ctx_r29.openTOC = $event;
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵtemplate"](2, StaticComponent_ng_container_0_ng_container_2_2_Template, 1, 0, undefined, 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵtemplate"](3, StaticComponent_ng_container_0_ng_container_2_3_Template, 1, 0, undefined, 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("opened", !!ctx_r4.tocItem && ctx_r4.openTOC);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("ngIf", !!ctx_r4.tocItem);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("ngIf", !!ctx_r4.tocItem);
        }
      }

      function StaticComponent_ng_container_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementContainerStart"](0, 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵpipe"](1, "async");

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵtemplate"](2, StaticComponent_ng_container_0_ng_container_2_Template, 4, 3, "ng-container", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var msgs_r3 = ctx.$implicit;

          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("path", _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵpipeBind1"](1, 2, ctx_r0.path$));

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("ngIf", msgs_r3.toc);
        }
      }

      function StaticComponent_section_6_div_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementStart"](0, "div");

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelement"](2, "span", 16);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var note_r32 = ctx.$implicit;
          var i_r33 = ctx.index;

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵtextInterpolate1"](" ", i_r33 + 1, " - ");

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("wm-markdown", note_r32);
        }
      }

      function StaticComponent_section_6_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementStart"](0, "section");

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelement"](1, "mat-divider");

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵtemplate"](2, StaticComponent_section_6_div_2_Template, 3, 2, "div", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵnextContext"]();

          var _r1 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵreference"](4);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("ngForOf", _r1.notes);
        }
      }

      var StaticComponent = /*#__PURE__*/function () {
        function StaticComponent(redirect, route) {
          _classCallCheck(this, StaticComponent);

          this.redirect = redirect;
          /** Tracks the status of the TOC panel */

          this.openTOC = true; // Extracts the path$ observable from the resolved static data

          this.path$ = route.data.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (data) {
            var _a;

            return ((_a = data.document) === null || _a === void 0 ? void 0 : _a.path) || '';
          })); // Extracts the body$ observable from the resolved static data

          this.body$ = route.data.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (data) {
            var _a;

            return ((_a = data.document) === null || _a === void 0 ? void 0 : _a.body) || '';
          }));
        } // Tracks the toc changes


        _createClass(StaticComponent, [{
          key: "tocChanged",
          value: function tocChanged(item, mobile) {
            // Force closing the toc panel while navigating on small screens or the item is null (aka the current document isn't referred within the toc)
            if (mobile || !item) {
              this.openTOC = false;
            } // Force opening the toc panel whenever display a document referred within the toc for the first time
            else if (!this.tocItem) {
                this.openTOC = true;
              } // Keep track of the current toc item.


            this.tocItem = item;
          }
          /** Navigates towards the requested url redirecting toc requests when formatted like:
           * 'toc?go=next' or 'toc?go=prev' for stepping forward or backward within the table
           * of content respectively */

        }, {
          key: "navigate",
          value: function navigate(url) {
            var _a, _b; // Intercepts TOC requests and redirects the url towards the next/previous page


            var toc = (_a = url.match(/.*toc\?go=(next|prev)$/)) === null || _a === void 0 ? void 0 : _a[1];

            if (toc) {
              url = (_b = toc === 'prev' ? this.toc.previousPage() : this.toc.nextPage()) === null || _b === void 0 ? void 0 : _b.link;
            }

            console.log('Navigating to:', url); // Performs the navigation

            return this.redirect.navigate(url);
          }
        }]);

        return StaticComponent;
      }();

      StaticComponent.ɵfac = function StaticComponent_Factory(t) {
        return new (t || StaticComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdirectiveInject"](_wizdm_redirect__WEBPACK_IMPORTED_MODULE_1__["RedirectService"]), _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdirectiveInject"](_angular_router__WEBPACK_IMPORTED_MODULE_0__["ActivatedRoute"]));
      };

      StaticComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineComponent"]({
        type: StaticComponent,
        selectors: [["wm-static"]],
        viewQuery: function StaticComponent_Query(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵviewQuery"](_toc_toc_component__WEBPACK_IMPORTED_MODULE_2__["TocComponent"], 1);
          }

          if (rf & 2) {
            var _t;

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵloadQuery"]()) && (ctx.toc = _t.first);
          }
        },
        decls: 7,
        vars: 8,
        consts: [["scrollPositionRestoration", "enabled", "anchorScrolling", "enabled", "gtag", "static", 3, "path", 4, "wmContent", "wmContentSelect"], ["wmAnimate", "fadeIn", "speed", "faster", "lockMaxWidth", "", 1, "foreground", 3, "replay"], [3, "wm-markdown", "navigate"], ["body", ""], [4, "ngIf"], ["scrollPositionRestoration", "enabled", "anchorScrolling", "enabled", "gtag", "static", 3, "path"], ["wmSidenav", "", 3, "opened", "openedChange"], [3, "wm-toc", "path", "color", "navigate", "selectedChange"], ["wmFab", "", "side", "left", "edge", "top"], ["mat-icon-button", "", "class", "mat-elevation-z2 background-color", 3, "color", "matTooltip", "click", 4, "ngIf"], ["mat-icon-button", "", 1, "mat-elevation-z2", "background-color", 3, "color", "matTooltip", "click"], [3, "icon"], ["wmActionbar", ""], ["mat-icon-button", "", 3, "color", "click", 4, "ngIf"], ["mat-icon-button", "", 3, "color", "click"], [4, "ngFor", "ngForOf"], ["inline", "", 3, "wm-markdown"]],
        template: function StaticComponent_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵtemplate"](0, StaticComponent_ng_container_0_Template, 3, 4, "ng-container", 0);

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementStart"](1, "article", 1);

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵpipe"](2, "async");

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementStart"](3, "section", 2, 3);

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵlistener"]("navigate", function StaticComponent_Template_section_navigate_3_listener($event) {
              return ctx.navigate($event);
            });

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵpipe"](5, "async");

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementEnd"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵtemplate"](6, StaticComponent_section_6_Template, 3, 1, "section", 4);

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵelementEnd"]();
          }

          if (rf & 2) {
            var _r1 = _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵreference"](4);

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("wmContentSelect", "static");

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("replay", _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵpipeBind1"](2, 4, ctx.body$));

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵadvance"](2);

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("wm-markdown", _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵpipeBind1"](5, 6, ctx.body$));

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵadvance"](3);

            _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵproperty"]("ngIf", _r1.notes.length > 0);
          }
        },
        directives: [_content_src_lib_streamer_content_directive__WEBPACK_IMPORTED_MODULE_5__["ContentDirective"], _animate_src_lib_animate_component__WEBPACK_IMPORTED_MODULE_6__["AnimateComponent"], _utils_size_lock_size_lock_directive__WEBPACK_IMPORTED_MODULE_7__["SizeLockDirective"], _markdown_src_lib_markdown_component__WEBPACK_IMPORTED_MODULE_8__["MarkdownRoot"], _angular_common__WEBPACK_IMPORTED_MODULE_9__["NgIf"], _utils_scrolling_scroll_behavior_directive__WEBPACK_IMPORTED_MODULE_10__["ScrollBehaviorDirective"], _gtag_src_lib_gtag_directive__WEBPACK_IMPORTED_MODULE_11__["GtagDirective"], _navigator_sidenav_sidenav_directive__WEBPACK_IMPORTED_MODULE_12__["SidenavDirective"], _toc_toc_component__WEBPACK_IMPORTED_MODULE_2__["TocComponent"], _navigator_fab_fab_directive__WEBPACK_IMPORTED_MODULE_13__["FabDirective"], _angular_material_button__WEBPACK_IMPORTED_MODULE_14__["MatButton"], _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_15__["MatTooltip"], _elements_src_lib_icon_icon_component__WEBPACK_IMPORTED_MODULE_16__["IconComponent"], _navigator_actionbar_actionbar_directive__WEBPACK_IMPORTED_MODULE_17__["ActionbarDirective"], _angular_material_divider__WEBPACK_IMPORTED_MODULE_18__["MatDivider"], _angular_common__WEBPACK_IMPORTED_MODULE_9__["NgForOf"]],
        pipes: [_angular_common__WEBPACK_IMPORTED_MODULE_9__["AsyncPipe"]],
        styles: ["[_nghost-%COMP%] {\n  position: relative;\n  display: block;\n  width: 100%;\n}\n[_nghost-%COMP%]   .foreground[_ngcontent-%COMP%] {\n  position: relative;\n  display: block;\n  width: 100%;\n  padding: 5vw;\n  box-sizing: border-box;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3N0YXRpYy5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQTtFQUVFLGtCQUFBO0VBQ0EsY0FBQTtFQUNBLFdBQUE7QUFERjtBQU1FO0VBQ0Usa0JBQUE7RUFDQSxjQUFBO0VBQ0EsV0FBQTtFQUNBLFlBQUE7RUFDQSxzQkFBQTtBQUpKIiwiZmlsZSI6InN0YXRpYy5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIlxuOmhvc3Qge1xuXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHdpZHRoOiAxMDAlO1xuICBcbiAgLy8gZm9yZWdyb3VuZyBhcnRpY2xlIG1heC13aWR0aCBpcyBsb2NrZWQgdG8gdGhlIHZpZXdwb3J0IHdpZHRoIGJ5IGEgZGlyZWN0aXZlIGZvcmNpbmdcbiAgLy8gaXRzIGNvbnRlbnQgdG8gc2Nyb2xsIGhvcml6b250YWxseSAoZXNwZWNpYWxseSBjb2RlIGJsb2NrcykgZGVzcGl0ZSB0aGUgZWxlbWVudCBpc1xuICAvLyByZWxhdGl2ZWx5IHBvc2l0aW9uZWRcbiAgLmZvcmVncm91bmQge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwYWRkaW5nOiA1dnc7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgfVxufSJdfQ== */"]
      });
      /***/
    },

    /***/
    "jWrk":
    /*!********************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/link.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function jWrk(module, exports, __webpack_require__) {
      "use strict";

      var whitespace = __webpack_require__(
      /*! is-whitespace-character */
      "IPAr");

      var locate = __webpack_require__(
      /*! ../locate/link */
      "EmYC");

      module.exports = link;
      link.locator = locate;
      var lineFeed = '\n';
      var exclamationMark = '!';
      var quotationMark = '"';
      var apostrophe = "'";
      var leftParenthesis = '(';
      var rightParenthesis = ')';
      var lessThan = '<';
      var greaterThan = '>';
      var leftSquareBracket = '[';
      var backslash = '\\';
      var rightSquareBracket = ']';
      var graveAccent = '`';

      function link(eat, value, silent) {
        var self = this;
        var subvalue = '';
        var index = 0;
        var character = value.charAt(0);
        var pedantic = self.options.pedantic;
        var commonmark = self.options.commonmark;
        var gfm = self.options.gfm;
        var closed;
        var count;
        var opening;
        var beforeURL;
        var beforeTitle;
        var subqueue;
        var hasMarker;
        var isImage;
        var content;
        var marker;
        var length;
        var title;
        var depth;
        var queue;
        var url;
        var now;
        var exit;
        var node; // Detect whether this is an image.

        if (character === exclamationMark) {
          isImage = true;
          subvalue = character;
          character = value.charAt(++index);
        } // Eat the opening.


        if (character !== leftSquareBracket) {
          return;
        } // Exit when this is a link and we’re already inside a link.


        if (!isImage && self.inLink) {
          return;
        }

        subvalue += character;
        queue = '';
        index++; // Eat the content.

        length = value.length;
        now = eat.now();
        depth = 0;
        now.column += index;
        now.offset += index;

        while (index < length) {
          character = value.charAt(index);
          subqueue = character;

          if (character === graveAccent) {
            // Inline-code in link content.
            count = 1;

            while (value.charAt(index + 1) === graveAccent) {
              subqueue += character;
              index++;
              count++;
            }

            if (!opening) {
              opening = count;
            } else if (count >= opening) {
              opening = 0;
            }
          } else if (character === backslash) {
            // Allow brackets to be escaped.
            index++;
            subqueue += value.charAt(index);
          } else if ((!opening || gfm) && character === leftSquareBracket) {
            // In GFM mode, brackets in code still count.  In all other modes,
            // they don’t.
            depth++;
          } else if ((!opening || gfm) && character === rightSquareBracket) {
            if (depth) {
              depth--;
            } else {
              if (value.charAt(index + 1) !== leftParenthesis) {
                return;
              }

              subqueue += leftParenthesis;
              closed = true;
              index++;
              break;
            }
          }

          queue += subqueue;
          subqueue = '';
          index++;
        } // Eat the content closing.


        if (!closed) {
          return;
        }

        content = queue;
        subvalue += queue + subqueue;
        index++; // Eat white-space.

        while (index < length) {
          character = value.charAt(index);

          if (!whitespace(character)) {
            break;
          }

          subvalue += character;
          index++;
        } // Eat the URL.


        character = value.charAt(index);
        queue = '';
        beforeURL = subvalue;

        if (character === lessThan) {
          index++;
          beforeURL += lessThan;

          while (index < length) {
            character = value.charAt(index);

            if (character === greaterThan) {
              break;
            }

            if (commonmark && character === lineFeed) {
              return;
            }

            queue += character;
            index++;
          }

          if (value.charAt(index) !== greaterThan) {
            return;
          }

          subvalue += lessThan + queue + greaterThan;
          url = queue;
          index++;
        } else {
          character = null;
          subqueue = '';

          while (index < length) {
            character = value.charAt(index);

            if (subqueue && (character === quotationMark || character === apostrophe || commonmark && character === leftParenthesis)) {
              break;
            }

            if (whitespace(character)) {
              if (!pedantic) {
                break;
              }

              subqueue += character;
            } else {
              if (character === leftParenthesis) {
                depth++;
              } else if (character === rightParenthesis) {
                if (depth === 0) {
                  break;
                }

                depth--;
              }

              queue += subqueue;
              subqueue = '';

              if (character === backslash) {
                queue += backslash;
                character = value.charAt(++index);
              }

              queue += character;
            }

            index++;
          }

          subvalue += queue;
          url = queue;
          index = subvalue.length;
        } // Eat white-space.


        queue = '';

        while (index < length) {
          character = value.charAt(index);

          if (!whitespace(character)) {
            break;
          }

          queue += character;
          index++;
        }

        character = value.charAt(index);
        subvalue += queue; // Eat the title.

        if (queue && (character === quotationMark || character === apostrophe || commonmark && character === leftParenthesis)) {
          index++;
          subvalue += character;
          queue = '';
          marker = character === leftParenthesis ? rightParenthesis : character;
          beforeTitle = subvalue; // In commonmark-mode, things are pretty easy: the marker cannot occur
          // inside the title.  Non-commonmark does, however, support nested
          // delimiters.

          if (commonmark) {
            while (index < length) {
              character = value.charAt(index);

              if (character === marker) {
                break;
              }

              if (character === backslash) {
                queue += backslash;
                character = value.charAt(++index);
              }

              index++;
              queue += character;
            }

            character = value.charAt(index);

            if (character !== marker) {
              return;
            }

            title = queue;
            subvalue += queue + character;
            index++;

            while (index < length) {
              character = value.charAt(index);

              if (!whitespace(character)) {
                break;
              }

              subvalue += character;
              index++;
            }
          } else {
            subqueue = '';

            while (index < length) {
              character = value.charAt(index);

              if (character === marker) {
                if (hasMarker) {
                  queue += marker + subqueue;
                  subqueue = '';
                }

                hasMarker = true;
              } else if (!hasMarker) {
                queue += character;
              } else if (character === rightParenthesis) {
                subvalue += queue + marker + subqueue;
                title = queue;
                break;
              } else if (whitespace(character)) {
                subqueue += character;
              } else {
                queue += marker + subqueue + character;
                subqueue = '';
                hasMarker = false;
              }

              index++;
            }
          }
        }

        if (value.charAt(index) !== rightParenthesis) {
          return;
        }
        /* istanbul ignore if - never used (yet) */


        if (silent) {
          return true;
        }

        subvalue += rightParenthesis;
        url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {
          nonTerminated: false
        });

        if (title) {
          beforeTitle = eat(beforeTitle).test().end;
          title = self.decode.raw(self.unescape(title), beforeTitle);
        }

        node = {
          type: isImage ? 'image' : 'link',
          title: title || null,
          url: url
        };

        if (isImage) {
          node.alt = self.decode.raw(self.unescape(content), now) || null;
        } else {
          exit = self.enterLink();
          node.children = self.tokenizeInline(content, now);
          exit();
        }

        return eat(subvalue)(node);
      }
      /***/

    },

    /***/
    "k1+7":
    /*!**************************************************************!*\
      !*** ./node_modules/unified/node_modules/is-buffer/index.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function k17(module, exports) {
      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <https://feross.org>
       * @license  MIT
       */
      module.exports = function isBuffer(obj) {
        return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
      };
      /***/

    },

    /***/
    "kNiW":
    /*!****************************************************!*\
      !*** ./wizdm/src/app/navigator/actionbar/index.ts ***!
      \****************************************************/

    /*! exports provided: ActionComponent, ActionbarDirective, ActionbarModule */

    /***/
    function kNiW(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony import */


      var _action_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./action.component */
      "39VJ");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "ActionComponent", function () {
        return _action_component__WEBPACK_IMPORTED_MODULE_0__["ActionComponent"];
      });
      /* harmony import */


      var _actionbar_directive__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./actionbar.directive */
      "mx0f");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "ActionbarDirective", function () {
        return _actionbar_directive__WEBPACK_IMPORTED_MODULE_1__["ActionbarDirective"];
      });
      /* harmony import */


      var _actionbar_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! ./actionbar.module */
      "Dfl8");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "ActionbarModule", function () {
        return _actionbar_module__WEBPACK_IMPORTED_MODULE_2__["ActionbarModule"];
      });
      /***/

    },

    /***/
    "kRHz":
    /*!*********************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/email.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function kRHz(module, exports, __webpack_require__) {
      "use strict";

      var decode = __webpack_require__(
      /*! parse-entities */
      "ZWk2");

      var decimal = __webpack_require__(
      /*! is-decimal */
      "ZONP");

      var alphabetical = __webpack_require__(
      /*! is-alphabetical */
      "1iAE");

      var locate = __webpack_require__(
      /*! ../locate/email */
      "lIBa");

      module.exports = email;
      email.locator = locate;
      email.notInLink = true;
      var plusSign = 43; // '+'

      var dash = 45; // '-'

      var dot = 46; // '.'

      var atSign = 64; // '@'

      var underscore = 95; // '_'

      function email(eat, value, silent) {
        var self = this;
        var gfm = self.options.gfm;
        var tokenizers = self.inlineTokenizers;
        var index = 0;
        var length = value.length;
        var firstDot = -1;
        var code;
        var content;
        var children;
        var exit;

        if (!gfm) {
          return;
        }

        code = value.charCodeAt(index);

        while (decimal(code) || alphabetical(code) || code === plusSign || code === dash || code === dot || code === underscore) {
          code = value.charCodeAt(++index);
        }

        if (index === 0) {
          return;
        }

        if (code !== atSign) {
          return;
        }

        index++;

        while (index < length) {
          code = value.charCodeAt(index);

          if (decimal(code) || alphabetical(code) || code === dash || code === dot || code === underscore) {
            index++;

            if (firstDot === -1 && code === dot) {
              firstDot = index;
            }

            continue;
          }

          break;
        }

        if (firstDot === -1 || firstDot === index || code === dash || code === underscore) {
          return;
        }

        if (code === dot) {
          index--;
        }

        content = value.slice(0, index);
        /* istanbul ignore if - never used (yet) */

        if (silent) {
          return true;
        }

        exit = self.enterLink(); // Temporarily remove all tokenizers except text in url.

        self.inlineTokenizers = {
          text: tokenizers.text
        };
        children = self.tokenizeInline(content, eat.now());
        self.inlineTokenizers = tokenizers;
        exit();
        return eat(content)({
          type: 'link',
          title: null,
          url: 'mailto:' + decode(content, {
            nonTerminated: false
          }),
          children: children
        });
      }
      /***/

    },

    /***/
    "kaWx":
    /*!*********************************************************!*\
      !*** ./node_modules/remark-parse/lib/util/normalize.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function kaWx(module, exports, __webpack_require__) {
      "use strict";

      var collapseWhiteSpace = __webpack_require__(
      /*! collapse-white-space */
      "JqBK");

      module.exports = normalize; // Normalize an identifier.  Collapses multiple white space characters into a
      // single space, and removes casing.

      function normalize(value) {
        return collapseWhiteSpace(value).toLowerCase();
      }
      /***/

    },

    /***/
    "l+ob":
    /*!************************************************!*\
      !*** ./wizdm/src/app/utils/size-lock/index.ts ***!
      \************************************************/

    /*! exports provided: SizeLockDirective, SizeLockModule */

    /***/
    function lOb(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony import */


      var _size_lock_directive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./size-lock.directive */
      "1QJd");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "SizeLockDirective", function () {
        return _size_lock_directive__WEBPACK_IMPORTED_MODULE_0__["SizeLockDirective"];
      });
      /* harmony import */


      var _size_lock_module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./size-lock.module */
      "EJE9");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "SizeLockModule", function () {
        return _size_lock_module__WEBPACK_IMPORTED_MODULE_1__["SizeLockModule"];
      });
      /***/

    },

    /***/
    "l4Y6":
    /*!**************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/blank-line.js ***!
      \**************************************************************/

    /*! no static exports found */

    /***/
    function l4Y6(module, exports, __webpack_require__) {
      "use strict"; // A line containing no characters, or a line containing only spaces (U+0020) or
      // tabs (U+0009), is called a blank line.
      // See <https://spec.commonmark.org/0.29/#blank-line>.

      var reBlankLine = /^[ \t]*(\n|$)/; // Note that though blank lines play a special role in lists to determine
      // whether the list is tight or loose
      // (<https://spec.commonmark.org/0.29/#blank-lines>), it’s done by the list
      // tokenizer and this blank line tokenizer does not have to be responsible for
      // that.
      // Therefore, configs such as `blankLine.notInList` do not have to be set here.

      module.exports = blankLine;

      function blankLine(eat, value, silent) {
        var match;
        var subvalue = '';
        var index = 0;
        var length = value.length;

        while (index < length) {
          match = reBlankLine.exec(value.slice(index));

          if (match == null) {
            break;
          }

          index += match[0].length;
          subvalue += match[0];
        }

        if (subvalue === '') {
          return;
        }
        /* istanbul ignore if - never used (yet) */


        if (silent) {
          return true;
        }

        eat(subvalue);
      }
      /***/

    },

    /***/
    "lIBa":
    /*!*******************************************************!*\
      !*** ./node_modules/remark-parse/lib/locate/email.js ***!
      \*******************************************************/

    /*! no static exports found */

    /***/
    function lIBa(module, exports, __webpack_require__) {
      "use strict";

      var decimal = __webpack_require__(
      /*! is-decimal */
      "ZONP");

      var alphabetical = __webpack_require__(
      /*! is-alphabetical */
      "1iAE");

      var plusSign = 43; // '+'

      var dash = 45; // '-'

      var dot = 46; // '.'

      var underscore = 95; // '_'

      module.exports = locate; // See: <https://github.github.com/gfm/#extended-email-autolink>

      function locate(value, fromIndex) {
        var self = this;
        var at;
        var position;

        if (!this.options.gfm) {
          return -1;
        }

        at = value.indexOf('@', fromIndex);

        if (at === -1) {
          return -1;
        }

        position = at;

        if (position === fromIndex || !isGfmAtext(value.charCodeAt(position - 1))) {
          return locate.call(self, value, at + 1);
        }

        while (position > fromIndex && isGfmAtext(value.charCodeAt(position - 1))) {
          position--;
        }

        return position;
      }

      function isGfmAtext(code) {
        return decimal(code) || alphabetical(code) || code === plusSign || code === dash || code === dot || code === underscore;
      }
      /***/

    },

    /***/
    "m2n9":
    /*!***********************************************************!*\
      !*** ./node_modules/character-entities-legacy/index.json ***!
      \***********************************************************/

    /*! exports provided: AElig, AMP, Aacute, Acirc, Agrave, Aring, Atilde, Auml, COPY, Ccedil, ETH, Eacute, Ecirc, Egrave, Euml, GT, Iacute, Icirc, Igrave, Iuml, LT, Ntilde, Oacute, Ocirc, Ograve, Oslash, Otilde, Ouml, QUOT, REG, THORN, Uacute, Ucirc, Ugrave, Uuml, Yacute, aacute, acirc, acute, aelig, agrave, amp, aring, atilde, auml, brvbar, ccedil, cedil, cent, copy, curren, deg, divide, eacute, ecirc, egrave, eth, euml, frac12, frac14, frac34, gt, iacute, icirc, iexcl, igrave, iquest, iuml, laquo, lt, macr, micro, middot, nbsp, not, ntilde, oacute, ocirc, ograve, ordf, ordm, oslash, otilde, ouml, para, plusmn, pound, quot, raquo, reg, sect, shy, sup1, sup2, sup3, szlig, thorn, times, uacute, ucirc, ugrave, uml, uuml, yacute, yen, yuml, default */

    /***/
    function m2n9(module) {
      module.exports = JSON.parse("{\"AElig\":\"Æ\",\"AMP\":\"&\",\"Aacute\":\"Á\",\"Acirc\":\"Â\",\"Agrave\":\"À\",\"Aring\":\"Å\",\"Atilde\":\"Ã\",\"Auml\":\"Ä\",\"COPY\":\"©\",\"Ccedil\":\"Ç\",\"ETH\":\"Ð\",\"Eacute\":\"É\",\"Ecirc\":\"Ê\",\"Egrave\":\"È\",\"Euml\":\"Ë\",\"GT\":\">\",\"Iacute\":\"Í\",\"Icirc\":\"Î\",\"Igrave\":\"Ì\",\"Iuml\":\"Ï\",\"LT\":\"<\",\"Ntilde\":\"Ñ\",\"Oacute\":\"Ó\",\"Ocirc\":\"Ô\",\"Ograve\":\"Ò\",\"Oslash\":\"Ø\",\"Otilde\":\"Õ\",\"Ouml\":\"Ö\",\"QUOT\":\"\\\"\",\"REG\":\"®\",\"THORN\":\"Þ\",\"Uacute\":\"Ú\",\"Ucirc\":\"Û\",\"Ugrave\":\"Ù\",\"Uuml\":\"Ü\",\"Yacute\":\"Ý\",\"aacute\":\"á\",\"acirc\":\"â\",\"acute\":\"´\",\"aelig\":\"æ\",\"agrave\":\"à\",\"amp\":\"&\",\"aring\":\"å\",\"atilde\":\"ã\",\"auml\":\"ä\",\"brvbar\":\"¦\",\"ccedil\":\"ç\",\"cedil\":\"¸\",\"cent\":\"¢\",\"copy\":\"©\",\"curren\":\"¤\",\"deg\":\"°\",\"divide\":\"÷\",\"eacute\":\"é\",\"ecirc\":\"ê\",\"egrave\":\"è\",\"eth\":\"ð\",\"euml\":\"ë\",\"frac12\":\"½\",\"frac14\":\"¼\",\"frac34\":\"¾\",\"gt\":\">\",\"iacute\":\"í\",\"icirc\":\"î\",\"iexcl\":\"¡\",\"igrave\":\"ì\",\"iquest\":\"¿\",\"iuml\":\"ï\",\"laquo\":\"«\",\"lt\":\"<\",\"macr\":\"¯\",\"micro\":\"µ\",\"middot\":\"·\",\"nbsp\":\" \",\"not\":\"¬\",\"ntilde\":\"ñ\",\"oacute\":\"ó\",\"ocirc\":\"ô\",\"ograve\":\"ò\",\"ordf\":\"ª\",\"ordm\":\"º\",\"oslash\":\"ø\",\"otilde\":\"õ\",\"ouml\":\"ö\",\"para\":\"¶\",\"plusmn\":\"±\",\"pound\":\"£\",\"quot\":\"\\\"\",\"raquo\":\"»\",\"reg\":\"®\",\"sect\":\"§\",\"shy\":\"­\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"szlig\":\"ß\",\"thorn\":\"þ\",\"times\":\"×\",\"uacute\":\"ú\",\"ucirc\":\"û\",\"ugrave\":\"ù\",\"uml\":\"¨\",\"uuml\":\"ü\",\"yacute\":\"ý\",\"yen\":\"¥\",\"yuml\":\"ÿ\"}");
      /***/
    },

    /***/
    "my8H":
    /*!***************************************************************!*\
      !*** ./node_modules/remark-parse/lib/util/get-indentation.js ***!
      \***************************************************************/

    /*! no static exports found */

    /***/
    function my8H(module, exports, __webpack_require__) {
      "use strict";

      module.exports = indentation;
      var tab = '\t';
      var space = ' ';
      var spaceSize = 1;
      var tabSize = 4; // Gets indentation information for a line.

      function indentation(value) {
        var index = 0;
        var indent = 0;
        var character = value.charAt(index);
        var stops = {};
        var size;
        var lastIndent = 0;

        while (character === tab || character === space) {
          size = character === tab ? tabSize : spaceSize;
          indent += size;

          if (size > 1) {
            indent = Math.floor(indent / size) * size;
          }

          while (lastIndent < indent) {
            stops[++lastIndent] = index;
          }

          character = value.charAt(++index);
        }

        return {
          indent: indent,
          stops: stops
        };
      }
      /***/

    },

    /***/
    "nLKB":
    /*!******************************************************!*\
      !*** ./node_modules/remark-parse/lib/set-options.js ***!
      \******************************************************/

    /*! no static exports found */

    /***/
    function nLKB(module, exports, __webpack_require__) {
      "use strict";

      var xtend = __webpack_require__(
      /*! xtend */
      "U6jy");

      var escapes = __webpack_require__(
      /*! markdown-escapes */
      "MQ5/");

      var defaults = __webpack_require__(
      /*! ./defaults */
      "0lR2");

      module.exports = setOptions;

      function setOptions(options) {
        var self = this;
        var current = self.options;
        var key;
        var value;

        if (options == null) {
          options = {};
        } else if (typeof options === 'object') {
          options = xtend(options);
        } else {
          throw new Error('Invalid value `' + options + '` for setting `options`');
        }

        for (key in defaults) {
          value = options[key];

          if (value == null) {
            value = current[key];
          }

          if (key !== 'blocks' && typeof value !== 'boolean' || key === 'blocks' && typeof value !== 'object') {
            throw new Error('Invalid value `' + value + '` for setting `options.' + key + '`');
          }

          options[key] = value;
        }

        self.options = options;
        self.escape = escapes(options);
        return self;
      }
      /***/

    },

    /***/
    "obXZ":
    /*!*************************************************!*\
      !*** ./node_modules/is-word-character/index.js ***!
      \*************************************************/

    /*! no static exports found */

    /***/
    function obXZ(module, exports, __webpack_require__) {
      "use strict";

      module.exports = wordCharacter;
      var fromCode = String.fromCharCode;
      var re = /\w/; // Check if the given character code, or the character code at the first
      // character, is a word character.

      function wordCharacter(character) {
        return re.test(typeof character === 'number' ? fromCode(character) : character.charAt(0));
      }
      /***/

    },

    /***/
    "pUFf":
    /*!******************************************************!*\
      !*** ./wizdm/src/app/pages/static/toc/toc.module.ts ***!
      \******************************************************/

    /*! exports provided: TocModule */

    /***/
    function pUFf(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "TocModule", function () {
        return TocModule;
      });
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/common */
      "SVse");
      /* harmony import */


      var _angular_flex_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/flex-layout */
      "u9T3");
      /* harmony import */


      var _angular_material_button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/material/button */
      "Dxy4");
      /* harmony import */


      var _angular_material_icon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @angular/material/icon */
      "Tj54");
      /* harmony import */


      var _toc_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! ./toc.component */
      "IOn0");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");

      var TocModule = function TocModule() {
        _classCallCheck(this, TocModule);
      };

      TocModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵdefineNgModule"]({
        type: TocModule
      });
      TocModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵdefineInjector"]({
        factory: function TocModule_Factory(t) {
          return new (t || TocModule)();
        },
        imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"], _angular_flex_layout__WEBPACK_IMPORTED_MODULE_1__["FlexLayoutModule"], _angular_material_button__WEBPACK_IMPORTED_MODULE_2__["MatButtonModule"], _angular_material_icon__WEBPACK_IMPORTED_MODULE_3__["MatIconModule"]]]
      });

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵsetNgModuleScope"](TocModule, {
          declarations: [_toc_component__WEBPACK_IMPORTED_MODULE_4__["TocComponent"]],
          imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["CommonModule"], _angular_flex_layout__WEBPACK_IMPORTED_MODULE_1__["FlexLayoutModule"], _angular_material_button__WEBPACK_IMPORTED_MODULE_2__["MatButtonModule"], _angular_material_icon__WEBPACK_IMPORTED_MODULE_3__["MatIconModule"]],
          exports: [_toc_component__WEBPACK_IMPORTED_MODULE_4__["TocComponent"]]
        });
      })();
      /***/

    },

    /***/
    "pyet":
    /*!******************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/thematic-break.js ***!
      \******************************************************************/

    /*! no static exports found */

    /***/
    function pyet(module, exports, __webpack_require__) {
      "use strict";

      module.exports = thematicBreak;
      var tab = '\t';
      var lineFeed = '\n';
      var space = ' ';
      var asterisk = '*';
      var dash = '-';
      var underscore = '_';
      var maxCount = 3;

      function thematicBreak(eat, value, silent) {
        var index = -1;
        var length = value.length + 1;
        var subvalue = '';
        var character;
        var marker;
        var markerCount;
        var queue;

        while (++index < length) {
          character = value.charAt(index);

          if (character !== tab && character !== space) {
            break;
          }

          subvalue += character;
        }

        if (character !== asterisk && character !== dash && character !== underscore) {
          return;
        }

        marker = character;
        subvalue += character;
        markerCount = 1;
        queue = '';

        while (++index < length) {
          character = value.charAt(index);

          if (character === marker) {
            markerCount++;
            subvalue += queue + marker;
            queue = '';
          } else if (character === space) {
            queue += character;
          } else if (markerCount >= maxCount && (!character || character === lineFeed)) {
            subvalue += queue;

            if (silent) {
              return true;
            }

            return eat(subvalue)({
              type: 'thematicBreak'
            });
          } else {
            return;
          }
        }
      }
      /***/

    },

    /***/
    "q4Aa":
    /*!*************************************************!*\
      !*** ./wizdm/src/app/pages/static/toc/index.ts ***!
      \*************************************************/

    /*! exports provided: TocComponent, TocModule */

    /***/
    function q4Aa(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony import */


      var _toc_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./toc.component */
      "IOn0");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "TocComponent", function () {
        return _toc_component__WEBPACK_IMPORTED_MODULE_0__["TocComponent"];
      });
      /* harmony import */


      var _toc_module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./toc.module */
      "pUFf");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "TocModule", function () {
        return _toc_module__WEBPACK_IMPORTED_MODULE_1__["TocModule"];
      });
      /***/

    },

    /***/
    "qCv1":
    /*!*****************************************************!*\
      !*** ./markdown/src/lib/inline/inline.component.ts ***!
      \*****************************************************/

    /*! exports provided: MarkdownInline */

    /***/
    function qCv1(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "MarkdownInline", function () {
        return MarkdownInline;
      });
      /* harmony import */


      var _tree_tree_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ../tree/tree.service */
      "6opK");
      /* harmony import */


      var _markdown_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ../markdown.component */
      "xbVm");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @angular/common */
      "SVse");
      /* harmony import */


      var _emoji_src_lib_text_emoji_text_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! ../../../../emoji/src/lib/text/emoji-text.component */
      "xS4v");
      /* harmony import */


      var _emoji_src_lib_names_emoji_names_pipe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! ../../../../emoji/src/lib/names/emoji-names.pipe */
      "qyca");

      var _c0 = ["wm-inline", ""];

      function MarkdownInline_ng_container_0_em_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "em", 7);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("wm-inline", child_r1);
        }
      }

      function MarkdownInline_ng_container_0_strong_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "strong", 7);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("wm-inline", child_r1);
        }
      }

      function MarkdownInline_ng_container_0_del_4_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "del", 7);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("wm-inline", child_r1);
        }
      }

      function MarkdownInline_ng_container_0_code_5_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "code");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

          var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate"](ctx_r5._T(child_r1.value));
        }
      }

      function MarkdownInline_ng_container_0_sub_6_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "sub", 7);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("wm-inline", child_r1);
        }
      }

      function MarkdownInline_ng_container_0_sup_7_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "sup", 7);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("wm-inline", child_r1);
        }
      }

      function MarkdownInline_ng_container_0_sup_8_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "sup");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

          var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate1"]("[", ctx_r8.tree.footnoteIndex(child_r1), "]");
        }
      }

      function MarkdownInline_ng_container_0_span_9_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "span", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipe"](1, "emojiNames");
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

          var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("wm-emoji-text", _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipeBind1"](1, 2, ctx_r9._T(child_r1.value)))("mode", ctx_r9.tree.emojiMode);
        }
      }

      function MarkdownInline_ng_container_0_br_10_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "br");
        }
      }

      function MarkdownInline_ng_container_0_a_11_Template(rf, ctx) {
        if (rf & 1) {
          var _r25 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "a", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵlistener"]("click", function MarkdownInline_ng_container_0_a_11_Template_a_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵrestoreView"](_r25);

            var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

            var ctx_r23 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]();

            return ctx_r23.navigate(child_r1.url);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("href", child_r1.url, _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeUrl"])("wm-inline", child_r1);
        }
      }

      function MarkdownInline_ng_container_0_ng_container_12_a_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r30 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "a", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵlistener"]("click", function MarkdownInline_ng_container_0_ng_container_12_a_1_Template_a_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵrestoreView"](_r30);

            var def_r28 = ctx.ngIf;

            var ctx_r29 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](3);

            return ctx_r29.navigate(def_r28.url);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var def_r28 = ctx.ngIf;

          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](2).$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("href", def_r28.url, _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeUrl"])("wm-inline", child_r1);
        }
      }

      function MarkdownInline_ng_container_0_ng_container_12_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](1, MarkdownInline_ng_container_0_ng_container_12_a_1_Template, 1, 2, "a", 10);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

          var ctx_r12 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", ctx_r12.tree.definition(child_r1));
        }
      }

      function MarkdownInline_ng_container_0_img_13_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "img", 11);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

          var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("src", child_r1.url, _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeUrl"])("title", ctx_r13._T(child_r1.title))("alt", ctx_r13._T(child_r1.alt));
        }
      }

      function MarkdownInline_ng_container_0_ng_container_14_img_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "img", 11);
        }

        if (rf & 2) {
          var def_r35 = ctx.ngIf;

          var ctx_r34 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("src", def_r35.url, _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵsanitizeUrl"])("title", ctx_r34._T(def_r35.title))("alt", ctx_r34._T(def_r35.alt));
        }
      }

      function MarkdownInline_ng_container_0_ng_container_14_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](1, MarkdownInline_ng_container_0_ng_container_14_img_1_Template, 1, 3, "img", 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

          var ctx_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", ctx_r14.tree.definition(child_r1));
        }
      }

      function MarkdownInline_ng_container_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainerStart"](1, 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](2, MarkdownInline_ng_container_0_em_2_Template, 1, 1, "em", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](3, MarkdownInline_ng_container_0_strong_3_Template, 1, 1, "strong", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](4, MarkdownInline_ng_container_0_del_4_Template, 1, 1, "del", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](5, MarkdownInline_ng_container_0_code_5_Template, 2, 1, "code", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](6, MarkdownInline_ng_container_0_sub_6_Template, 1, 1, "sub", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](7, MarkdownInline_ng_container_0_sup_7_Template, 1, 1, "sup", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](8, MarkdownInline_ng_container_0_sup_8_Template, 2, 1, "sup", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](9, MarkdownInline_ng_container_0_span_9_Template, 2, 4, "span", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](10, MarkdownInline_ng_container_0_br_10_Template, 1, 0, "br", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](11, MarkdownInline_ng_container_0_a_11_Template, 1, 2, "a", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](12, MarkdownInline_ng_container_0_ng_container_12_Template, 2, 1, "ng-container", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](13, MarkdownInline_ng_container_0_img_13_Template, 1, 3, "img", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](14, MarkdownInline_ng_container_0_ng_container_14_Template, 2, 1, "ng-container", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainerEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var child_r1 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitch", child_r1.type);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitchCase", "emphasis");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitchCase", "strong");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitchCase", "delete");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitchCase", "inlineCode");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitchCase", "sub");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitchCase", "sup");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitchCase", "footnoteReference");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitchCase", "text");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitchCase", "break");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitchCase", "link");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitchCase", "linkReference");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitchCase", "image");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngSwitchCase", "imageReference");
        }
      }

      var MarkdownInline = /*#__PURE__*/function () {
        function MarkdownInline(tree, root) {
          _classCallCheck(this, MarkdownInline);

          this.tree = tree;
          this.root = root;
        } // AOT safe children from the node


        _createClass(MarkdownInline, [{
          key: "children",
          get: function get() {
            return "children" in this.node ? this.node.children : [];
          } // Text rendering helper

        }, {
          key: "_T",
          value: function _T(value) {
            return value || '';
          } // Navigation helper functions

        }, {
          key: "navigate",
          value: function navigate(url) {
            // Relies on the root parent navigation mechanism 
            this.root.navigate.emit(url); // Prevents default navigation towards href

            return false;
          }
        }]);

        return MarkdownInline;
      }();

      MarkdownInline.ɵfac = function MarkdownInline_Factory(t) {
        return new (t || MarkdownInline)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_tree_tree_service__WEBPACK_IMPORTED_MODULE_0__["MarkdownTree"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_markdown_component__WEBPACK_IMPORTED_MODULE_1__["MarkdownRoot"]));
      };

      MarkdownInline.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineComponent"]({
        type: MarkdownInline,
        selectors: [["", "wm-inline", ""]],
        inputs: {
          node: ["wm-inline", "node"]
        },
        attrs: _c0,
        decls: 1,
        vars: 1,
        consts: [[4, "ngFor", "ngForOf"], [3, "ngSwitch"], [3, "wm-inline", 4, "ngSwitchCase"], [4, "ngSwitchCase"], [3, "wm-emoji-text", "mode", 4, "ngSwitchCase"], [3, "href", "wm-inline", "click", 4, "ngSwitchCase"], [3, "src", "title", "alt", 4, "ngSwitchCase"], [3, "wm-inline"], [3, "wm-emoji-text", "mode"], [3, "href", "wm-inline", "click"], [3, "href", "wm-inline", "click", 4, "ngIf"], [3, "src", "title", "alt"], [3, "src", "title", "alt", 4, "ngIf"]],
        template: function MarkdownInline_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](0, MarkdownInline_ng_container_0_Template, 15, 14, "ng-container", 0);
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngForOf", ctx.children);
          }
        },
        directives: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["NgForOf"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgSwitch"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgSwitchCase"], MarkdownInline, _emoji_src_lib_text_emoji_text_component__WEBPACK_IMPORTED_MODULE_4__["EmojiText"], _angular_common__WEBPACK_IMPORTED_MODULE_3__["NgIf"]],
        pipes: [_emoji_src_lib_names_emoji_names_pipe__WEBPACK_IMPORTED_MODULE_5__["EmojiNamesPipe"]],
        styles: [".wm-markdown img {\n  max-width: 100%;\n  box-sizing: border-box;\n}\n.wm-markdown img[src*=\"#25\"] {\n  max-width: 25%;\n}\n.wm-markdown img[src*=\"#33\"] {\n  max-width: 33%;\n}\n.wm-markdown img[src*=\"#50\"] {\n  max-width: 50%;\n}\n.wm-markdown img[src*=\"#66\"] {\n  max-width: 66%;\n}\n.wm-markdown img[src*=\"#75\"] {\n  max-width: 75%;\n}\n.wm-markdown img[src*=\"#regular\"] {\n  max-width: 1024px;\n}\n.wm-markdown img[src*=\"#small\"] {\n  max-width: 400px;\n}\n.wm-markdown img[src*=\"#thumb\"] {\n  max-width: 150px;\n}\n.wm-markdown img[src*=\"#icon\"] {\n  max-width: 48px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2lubGluZS5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHRTtFQUVFLGVBQUE7RUFDQSxzQkFBQTtBQUhKO0FBTUk7RUFBZ0IsY0FBQTtBQUhwQjtBQUlJO0VBQWdCLGNBQUE7QUFEcEI7QUFFSTtFQUFnQixjQUFBO0FBQ3BCO0FBQUk7RUFBZ0IsY0FBQTtBQUdwQjtBQUZJO0VBQWdCLGNBQUE7QUFLcEI7QUFGSTtFQUFxQixpQkFBQTtBQUt6QjtBQUpJO0VBQW1CLGdCQUFBO0FBT3ZCO0FBTkk7RUFBbUIsZ0JBQUE7QUFTdkI7QUFSSTtFQUFrQixlQUFBO0FBV3RCIiwiZmlsZSI6ImlubGluZS5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLndtLW1hcmtkb3duIHtcbiAgXG4gIGltZyB7XG4gICAgLy8gTGltaXRzIGltYWdlIHNpemUgdG8gMTAwJVxuICAgIG1heC13aWR0aDogMTAwJTtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OyBcblxuICAgIC8vICUgcmVzaXplaW5nIHNob3J0Y3V0c1xuICAgICZbc3JjKj1cIiMyNVwiXSB7IG1heC13aWR0aDogMjUlOyB9IFxuICAgICZbc3JjKj1cIiMzM1wiXSB7IG1heC13aWR0aDogMzMlOyB9IFxuICAgICZbc3JjKj1cIiM1MFwiXSB7IG1heC13aWR0aDogNTAlOyB9XG4gICAgJltzcmMqPVwiIzY2XCJdIHsgbWF4LXdpZHRoOiA2NiU7IH1cbiAgICAmW3NyYyo9XCIjNzVcIl0geyBtYXgtd2lkdGg6IDc1JTsgfSBcblxuICAgIC8vIHB4IHJlc2l6aW5nIHNob3J0Y3V0c1xuICAgICZbc3JjKj1cIiNyZWd1bGFyXCJdIHsgbWF4LXdpZHRoOiAxMDI0cHg7IH1cbiAgICAmW3NyYyo9XCIjc21hbGxcIl0geyBtYXgtd2lkdGg6IDQwMHB4OyB9XG4gICAgJltzcmMqPVwiI3RodW1iXCJdIHsgbWF4LXdpZHRoOiAxNTBweDsgfVxuICAgICZbc3JjKj1cIiNpY29uXCJdIHsgbWF4LXdpZHRoOiA0OHB4OyB9XG4gIH1cbn0iXX0= */"],
        encapsulation: 2
      });
      /***/
    },

    /***/
    "qyca":
    /*!*************************************************!*\
      !*** ./emoji/src/lib/names/emoji-names.pipe.ts ***!
      \*************************************************/

    /*! exports provided: EmojiNamesPipe */

    /***/
    function qyca(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "EmojiNamesPipe", function () {
        return EmojiNamesPipe;
      });
      /* harmony import */


      var _emoji_names__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./emoji-names */
      "FKt/");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /** Replaces emoji colons short names into their corresponding code-points sequence */


      var EmojiNamesPipe = /*#__PURE__*/function () {
        function EmojiNamesPipe() {
          _classCallCheck(this, EmojiNamesPipe);
        }

        _createClass(EmojiNamesPipe, [{
          key: "transform",
          value: function transform(value) {
            if (typeof value !== 'string') {
              return value;
            }

            return value.replace(/:(100|1234|\w+):/g, function (_, name) {
              return _emoji_names__WEBPACK_IMPORTED_MODULE_0__["emojiNames"][name] || name;
            });
          }
        }]);

        return EmojiNamesPipe;
      }();

      EmojiNamesPipe.ɵfac = function EmojiNamesPipe_Factory(t) {
        return new (t || EmojiNamesPipe)();
      };

      EmojiNamesPipe.ɵpipe = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefinePipe"]({
        name: "emojiNames",
        type: EmojiNamesPipe,
        pure: true
      });
      /***/
    },

    /***/
    "r0km":
    /*!*********************************************!*\
      !*** ./markdown/src/lib/tree/tree-types.ts ***!
      \*********************************************/

    /*! no exports provided */

    /***/
    function r0km(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /***/

    },

    /***/
    "sFr1":
    /*!**************************************************!*\
      !*** ./wizdm/src/app/navigator/sidenav/index.ts ***!
      \**************************************************/

    /*! exports provided: SidenavDirective, SidenavModule */

    /***/
    function sFr1(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony import */


      var _sidenav_directive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./sidenav.directive */
      "++Qg");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "SidenavDirective", function () {
        return _sidenav_directive__WEBPACK_IMPORTED_MODULE_0__["SidenavDirective"];
      });
      /* harmony import */


      var _sidenav_module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./sidenav.module */
      "JtLf");
      /* harmony reexport (safe) */


      __webpack_require__.d(__webpack_exports__, "SidenavModule", function () {
        return _sidenav_module__WEBPACK_IMPORTED_MODULE_1__["SidenavModule"];
      });
      /***/

    },

    /***/
    "tGWH":
    /*!********************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/list.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function tGWH(module, exports, __webpack_require__) {
      "use strict";

      var trim = __webpack_require__(
      /*! trim */
      "RsFJ");

      var repeat = __webpack_require__(
      /*! repeat-string */
      "RjOF");

      var decimal = __webpack_require__(
      /*! is-decimal */
      "ZONP");

      var getIndent = __webpack_require__(
      /*! ../util/get-indentation */
      "my8H");

      var removeIndent = __webpack_require__(
      /*! ../util/remove-indentation */
      "Zpkj");

      var interrupt = __webpack_require__(
      /*! ../util/interrupt */
      "KJAg");

      module.exports = list;
      var asterisk = '*';
      var underscore = '_';
      var plusSign = '+';
      var dash = '-';
      var dot = '.';
      var space = ' ';
      var lineFeed = '\n';
      var tab = '\t';
      var rightParenthesis = ')';
      var lowercaseX = 'x';
      var tabSize = 4;
      var looseListItemExpression = /\n\n(?!\s*$)/;
      var taskItemExpression = /^\[([ X\tx])][ \t]/;
      var bulletExpression = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
      var pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
      var initialIndentExpression = /^( {1,4}|\t)?/gm;

      function list(eat, value, silent) {
        var self = this;
        var commonmark = self.options.commonmark;
        var pedantic = self.options.pedantic;
        var tokenizers = self.blockTokenizers;
        var interuptors = self.interruptList;
        var index = 0;
        var length = value.length;
        var start = null;
        var size;
        var queue;
        var ordered;
        var character;
        var marker;
        var nextIndex;
        var startIndex;
        var prefixed;
        var currentMarker;
        var content;
        var line;
        var previousEmpty;
        var empty;
        var items;
        var allLines;
        var emptyLines;
        var item;
        var enterTop;
        var exitBlockquote;
        var spread = false;
        var node;
        var now;
        var end;
        var indented;

        while (index < length) {
          character = value.charAt(index);

          if (character !== tab && character !== space) {
            break;
          }

          index++;
        }

        character = value.charAt(index);

        if (character === asterisk || character === plusSign || character === dash) {
          marker = character;
          ordered = false;
        } else {
          ordered = true;
          queue = '';

          while (index < length) {
            character = value.charAt(index);

            if (!decimal(character)) {
              break;
            }

            queue += character;
            index++;
          }

          character = value.charAt(index);

          if (!queue || !(character === dot || commonmark && character === rightParenthesis)) {
            return;
          }
          /* Slightly abusing `silent` mode, whose goal is to make interrupting
           * paragraphs work.
           * Well, that’s exactly what we want to do here: don’t interrupt:
           * 2. here, because the “list” doesn’t start with `1`. */


          if (silent && queue !== '1') {
            return;
          }

          start = parseInt(queue, 10);
          marker = character;
        }

        character = value.charAt(++index);

        if (character !== space && character !== tab && (pedantic || character !== lineFeed && character !== '')) {
          return;
        }

        if (silent) {
          return true;
        }

        index = 0;
        items = [];
        allLines = [];
        emptyLines = [];

        while (index < length) {
          nextIndex = value.indexOf(lineFeed, index);
          startIndex = index;
          prefixed = false;
          indented = false;

          if (nextIndex === -1) {
            nextIndex = length;
          }

          size = 0;

          while (index < length) {
            character = value.charAt(index);

            if (character === tab) {
              size += tabSize - size % tabSize;
            } else if (character === space) {
              size++;
            } else {
              break;
            }

            index++;
          }

          if (item && size >= item.indent) {
            indented = true;
          }

          character = value.charAt(index);
          currentMarker = null;

          if (!indented) {
            if (character === asterisk || character === plusSign || character === dash) {
              currentMarker = character;
              index++;
              size++;
            } else {
              queue = '';

              while (index < length) {
                character = value.charAt(index);

                if (!decimal(character)) {
                  break;
                }

                queue += character;
                index++;
              }

              character = value.charAt(index);
              index++;

              if (queue && (character === dot || commonmark && character === rightParenthesis)) {
                currentMarker = character;
                size += queue.length + 1;
              }
            }

            if (currentMarker) {
              character = value.charAt(index);

              if (character === tab) {
                size += tabSize - size % tabSize;
                index++;
              } else if (character === space) {
                end = index + tabSize;

                while (index < end) {
                  if (value.charAt(index) !== space) {
                    break;
                  }

                  index++;
                  size++;
                }

                if (index === end && value.charAt(index) === space) {
                  index -= tabSize - 1;
                  size -= tabSize - 1;
                }
              } else if (character !== lineFeed && character !== '') {
                currentMarker = null;
              }
            }
          }

          if (currentMarker) {
            if (!pedantic && marker !== currentMarker) {
              break;
            }

            prefixed = true;
          } else {
            if (!commonmark && !indented && value.charAt(startIndex) === space) {
              indented = true;
            } else if (commonmark && item) {
              indented = size >= item.indent || size > tabSize;
            }

            prefixed = false;
            index = startIndex;
          }

          line = value.slice(startIndex, nextIndex);
          content = startIndex === index ? line : value.slice(index, nextIndex);

          if (currentMarker === asterisk || currentMarker === underscore || currentMarker === dash) {
            if (tokenizers.thematicBreak.call(self, eat, line, true)) {
              break;
            }
          }

          previousEmpty = empty;
          empty = !prefixed && !trim(content).length;

          if (indented && item) {
            item.value = item.value.concat(emptyLines, line);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
          } else if (prefixed) {
            if (emptyLines.length !== 0) {
              spread = true;
              item.value.push('');
              item.trail = emptyLines.concat();
            }

            item = {
              value: [line],
              indent: size,
              trail: []
            };
            items.push(item);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
          } else if (empty) {
            if (previousEmpty && !commonmark) {
              break;
            }

            emptyLines.push(line);
          } else {
            if (previousEmpty) {
              break;
            }

            if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {
              break;
            }

            item.value = item.value.concat(emptyLines, line);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
          }

          index = nextIndex + 1;
        }

        node = eat(allLines.join(lineFeed)).reset({
          type: 'list',
          ordered: ordered,
          start: start,
          spread: spread,
          children: []
        });
        enterTop = self.enterList();
        exitBlockquote = self.enterBlock();
        index = -1;
        length = items.length;

        while (++index < length) {
          item = items[index].value.join(lineFeed);
          now = eat.now();
          eat(item)(listItem(self, item, now), node);
          item = items[index].trail.join(lineFeed);

          if (index !== length - 1) {
            item += lineFeed;
          }

          eat(item);
        }

        enterTop();
        exitBlockquote();
        return node;
      }

      function listItem(ctx, value, position) {
        var offsets = ctx.offset;
        var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;
        var checked = null;
        var task;
        var indent;
        value = fn.apply(null, arguments);

        if (ctx.options.gfm) {
          task = value.match(taskItemExpression);

          if (task) {
            indent = task[0].length;
            checked = task[1].toLowerCase() === lowercaseX;
            offsets[position.line] += indent;
            value = value.slice(indent);
          }
        }

        return {
          type: 'listItem',
          spread: looseListItemExpression.test(value),
          checked: checked,
          children: ctx.tokenizeBlock(value, position)
        };
      } // Create a list-item using overly simple mechanics.


      function pedanticListItem(ctx, value, position) {
        var offsets = ctx.offset;
        var line = position.line; // Remove the list-item’s bullet.

        value = value.replace(pedanticBulletExpression, replacer); // The initial line was also matched by the below, so we reset the `line`.

        line = position.line;
        return value.replace(initialIndentExpression, replacer); // A simple replacer which removed all matches, and adds their length to
        // `offset`.

        function replacer($0) {
          offsets[line] = (offsets[line] || 0) + $0.length;
          line++;
          return '';
        }
      } // Create a list-item using sane mechanics.


      function normalListItem(ctx, value, position) {
        var offsets = ctx.offset;
        var line = position.line;
        var max;
        var bullet;
        var rest;
        var lines;
        var trimmedLines;
        var index;
        var length; // Remove the list-item’s bullet.

        value = value.replace(bulletExpression, replacer);
        lines = value.split(lineFeed);
        trimmedLines = removeIndent(value, getIndent(max).indent).split(lineFeed); // We replaced the initial bullet with something else above, which was used
        // to trick `removeIndentation` into removing some more characters when
        // possible.  However, that could result in the initial line to be stripped
        // more than it should be.

        trimmedLines[0] = rest;
        offsets[line] = (offsets[line] || 0) + bullet.length;
        line++;
        index = 0;
        length = lines.length;

        while (++index < length) {
          offsets[line] = (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;
          line++;
        }

        return trimmedLines.join(lineFeed);
        /* eslint-disable-next-line max-params */

        function replacer($0, $1, $2, $3, $4) {
          bullet = $1 + $2 + $3;
          rest = $4; // Make sure that the first nine numbered list items can indent with an
          // extra space.  That is, when the bullet did not receive an extra final
          // space.

          if (Number($2) < 10 && bullet.length % 2 === 1) {
            $2 = space + $2;
          }

          max = $1 + repeat(space, $2.length) + $3;
          return max + rest;
        }
      }
      /***/

    },

    /***/
    "tgGP":
    /*!****************************************!*\
      !*** ./node_modules/vfile/lib/core.js ***!
      \****************************************/

    /*! no static exports found */

    /***/
    function tgGP(module, exports, __webpack_require__) {
      "use strict";

      var p = __webpack_require__(
      /*! ./minpath */
      "ueQ+");

      var proc = __webpack_require__(
      /*! ./minproc */
      "+OJB");

      var buffer = __webpack_require__(
      /*! is-buffer */
      "k1+7");

      module.exports = VFile;
      var own = {}.hasOwnProperty; // Order of setting (least specific to most), we need this because otherwise
      // `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
      // stem can be set.

      var order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname'];
      VFile.prototype.toString = toString; // Access full path (`~/index.min.js`).

      Object.defineProperty(VFile.prototype, 'path', {
        get: getPath,
        set: setPath
      }); // Access parent path (`~`).

      Object.defineProperty(VFile.prototype, 'dirname', {
        get: getDirname,
        set: setDirname
      }); // Access basename (`index.min.js`).

      Object.defineProperty(VFile.prototype, 'basename', {
        get: getBasename,
        set: setBasename
      }); // Access extname (`.js`).

      Object.defineProperty(VFile.prototype, 'extname', {
        get: getExtname,
        set: setExtname
      }); // Access stem (`index.min`).

      Object.defineProperty(VFile.prototype, 'stem', {
        get: getStem,
        set: setStem
      }); // Construct a new file.

      function VFile(options) {
        var prop;
        var index;

        if (!options) {
          options = {};
        } else if (typeof options === 'string' || buffer(options)) {
          options = {
            contents: options
          };
        } else if ('message' in options && 'messages' in options) {
          return options;
        }

        if (!(this instanceof VFile)) {
          return new VFile(options);
        }

        this.data = {};
        this.messages = [];
        this.history = [];
        this.cwd = proc.cwd(); // Set path related properties in the correct order.

        index = -1;

        while (++index < order.length) {
          prop = order[index];

          if (own.call(options, prop)) {
            this[prop] = options[prop];
          }
        } // Set non-path related properties.


        for (prop in options) {
          if (order.indexOf(prop) < 0) {
            this[prop] = options[prop];
          }
        }
      }

      function getPath() {
        return this.history[this.history.length - 1];
      }

      function setPath(path) {
        assertNonEmpty(path, 'path');

        if (this.path !== path) {
          this.history.push(path);
        }
      }

      function getDirname() {
        return typeof this.path === 'string' ? p.dirname(this.path) : undefined;
      }

      function setDirname(dirname) {
        assertPath(this.path, 'dirname');
        this.path = p.join(dirname || '', this.basename);
      }

      function getBasename() {
        return typeof this.path === 'string' ? p.basename(this.path) : undefined;
      }

      function setBasename(basename) {
        assertNonEmpty(basename, 'basename');
        assertPart(basename, 'basename');
        this.path = p.join(this.dirname || '', basename);
      }

      function getExtname() {
        return typeof this.path === 'string' ? p.extname(this.path) : undefined;
      }

      function setExtname(extname) {
        assertPart(extname, 'extname');
        assertPath(this.path, 'extname');

        if (extname) {
          if (extname.charCodeAt(0) !== 46
          /* `.` */
          ) {
              throw new Error('`extname` must start with `.`');
            }

          if (extname.indexOf('.', 1) > -1) {
            throw new Error('`extname` cannot contain multiple dots');
          }
        }

        this.path = p.join(this.dirname, this.stem + (extname || ''));
      }

      function getStem() {
        return typeof this.path === 'string' ? p.basename(this.path, this.extname) : undefined;
      }

      function setStem(stem) {
        assertNonEmpty(stem, 'stem');
        assertPart(stem, 'stem');
        this.path = p.join(this.dirname || '', stem + (this.extname || ''));
      } // Get the value of the file.


      function toString(encoding) {
        return (this.contents || '').toString(encoding);
      } // Assert that `part` is not a path (i.e., does not contain `p.sep`).


      function assertPart(part, name) {
        if (part && part.indexOf(p.sep) > -1) {
          throw new Error('`' + name + '` cannot be a path: did not expect `' + p.sep + '`');
        }
      } // Assert that `part` is not empty.


      function assertNonEmpty(part, name) {
        if (!part) {
          throw new Error('`' + name + '` cannot be empty');
        }
      } // Assert `path` exists.


      function assertPath(path, name) {
        if (!path) {
          throw new Error('Setting `' + name + '` requires `path` to be set too');
        }
      }
      /***/

    },

    /***/
    "tgay":
    /*!**********************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/escape.js ***!
      \**********************************************************/

    /*! no static exports found */

    /***/
    function tgay(module, exports, __webpack_require__) {
      "use strict";

      var locate = __webpack_require__(
      /*! ../locate/escape */
      "NFD0");

      module.exports = escape;
      escape.locator = locate;
      var lineFeed = '\n';
      var backslash = '\\';

      function escape(eat, value, silent) {
        var self = this;
        var character;
        var node;

        if (value.charAt(0) === backslash) {
          character = value.charAt(1);

          if (self.escape.indexOf(character) !== -1) {
            /* istanbul ignore if - never used (yet) */
            if (silent) {
              return true;
            }

            if (character === lineFeed) {
              node = {
                type: 'break'
              };
            } else {
              node = {
                type: 'text',
                value: character
              };
            }

            return eat(backslash + character)(node);
          }
        }
      }
      /***/

    },

    /***/
    "ueQ+":
    /*!***************************************************!*\
      !*** ./node_modules/vfile/lib/minpath.browser.js ***!
      \***************************************************/

    /*! no static exports found */

    /***/
    function ueQ(module, exports, __webpack_require__) {
      "use strict"; // A derivative work based on:
      // <https://github.com/browserify/path-browserify>.
      // Which is licensed:
      //
      // MIT License
      //
      // Copyright (c) 2013 James Halliday
      //
      // Permission is hereby granted, free of charge, to any person obtaining a copy of
      // this software and associated documentation files (the "Software"), to deal in
      // the Software without restriction, including without limitation the rights to
      // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      // the Software, and to permit persons to whom the Software is furnished to do so,
      // subject to the following conditions:
      //
      // The above copyright notice and this permission notice shall be included in all
      // copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
      // FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
      // COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
      // IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
      // CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      // A derivative work based on:
      //
      // Parts of that are extracted from Node’s internal `path` module:
      // <https://github.com/nodejs/node/blob/master/lib/path.js>.
      // Which is licensed:
      //
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      exports.basename = basename;
      exports.dirname = dirname;
      exports.extname = extname;
      exports.join = join;
      exports.sep = '/';

      function basename(path, ext) {
        var start = 0;
        var end = -1;
        var index;
        var firstNonSlashEnd;
        var seenNonSlash;
        var extIndex;

        if (ext !== undefined && typeof ext !== 'string') {
          throw new TypeError('"ext" argument must be a string');
        }

        assertPath(path);
        index = path.length;

        if (ext === undefined || !ext.length || ext.length > path.length) {
          while (index--) {
            if (path.charCodeAt(index) === 47
            /* `/` */
            ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now.
                if (seenNonSlash) {
                  start = index + 1;
                  break;
                }
              } else if (end < 0) {
              // We saw the first non-path separator, mark this as the end of our
              // path component.
              seenNonSlash = true;
              end = index + 1;
            }
          }

          return end < 0 ? '' : path.slice(start, end);
        }

        if (ext === path) {
          return '';
        }

        firstNonSlashEnd = -1;
        extIndex = ext.length - 1;

        while (index--) {
          if (path.charCodeAt(index) === 47
          /* `/` */
          ) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now.
              if (seenNonSlash) {
                start = index + 1;
                break;
              }
            } else {
            if (firstNonSlashEnd < 0) {
              // We saw the first non-path separator, remember this index in case
              // we need it if the extension ends up not matching.
              seenNonSlash = true;
              firstNonSlashEnd = index + 1;
            }

            if (extIndex > -1) {
              // Try to match the explicit extension.
              if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {
                if (extIndex < 0) {
                  // We matched the extension, so mark this as the end of our path
                  // component
                  end = index;
                }
              } else {
                // Extension does not match, so our result is the entire path
                // component
                extIndex = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }

        if (start === end) {
          end = firstNonSlashEnd;
        } else if (end < 0) {
          end = path.length;
        }

        return path.slice(start, end);
      }

      function dirname(path) {
        var end;
        var unmatchedSlash;
        var index;
        assertPath(path);

        if (!path.length) {
          return '.';
        }

        end = -1;
        index = path.length; // Prefix `--` is important to not run on `0`.

        while (--index) {
          if (path.charCodeAt(index) === 47
          /* `/` */
          ) {
              if (unmatchedSlash) {
                end = index;
                break;
              }
            } else if (!unmatchedSlash) {
            // We saw the first non-path separator
            unmatchedSlash = true;
          }
        }

        return end < 0 ? path.charCodeAt(0) === 47
        /* `/` */
        ? '/' : '.' : end === 1 && path.charCodeAt(0) === 47
        /* `/` */
        ? '//' : path.slice(0, end);
      }

      function extname(path) {
        var startDot = -1;
        var startPart = 0;
        var end = -1; // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find.

        var preDotState = 0;
        var unmatchedSlash;
        var code;
        var index;
        assertPath(path);
        index = path.length;

        while (index--) {
          code = path.charCodeAt(index);

          if (code === 47
          /* `/` */
          ) {
              // If we reached a path separator that was not part of a set of path
              // separators at the end of the string, stop now.
              if (unmatchedSlash) {
                startPart = index + 1;
                break;
              }

              continue;
            }

          if (end < 0) {
            // We saw the first non-path separator, mark this as the end of our
            // extension.
            unmatchedSlash = true;
            end = index + 1;
          }

          if (code === 46
          /* `.` */
          ) {
              // If this is our first dot, mark it as the start of our extension.
              if (startDot < 0) {
                startDot = index;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot > -1) {
            // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension.
            preDotState = -1;
          }
        }

        if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
        preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return '';
        }

        return path.slice(startDot, end);
      }

      function join() {
        var index = -1;
        var joined;

        while (++index < arguments.length) {
          assertPath(arguments[index]);

          if (arguments[index]) {
            joined = joined === undefined ? arguments[index] : joined + '/' + arguments[index];
          }
        }

        return joined === undefined ? '.' : normalize(joined);
      } // Note: `normalize` is not exposed as `path.normalize`, so some code is
      // manually removed from it.


      function normalize(path) {
        var absolute;
        var value;
        assertPath(path);
        absolute = path.charCodeAt(0) === 47;
        /* `/` */
        // Normalize the path according to POSIX rules.

        value = normalizeString(path, !absolute);

        if (!value.length && !absolute) {
          value = '.';
        }

        if (value.length && path.charCodeAt(path.length - 1) === 47
        /* / */
        ) {
            value += '/';
          }

        return absolute ? '/' + value : value;
      } // Resolve `.` and `..` elements in a path with directory names.


      function normalizeString(path, allowAboveRoot) {
        var result = '';
        var lastSegmentLength = 0;
        var lastSlash = -1;
        var dots = 0;
        var index = -1;
        var code;
        var lastSlashIndex;

        while (++index <= path.length) {
          if (index < path.length) {
            code = path.charCodeAt(index);
          } else if (code === 47
          /* `/` */
          ) {
              break;
            } else {
            code = 47;
            /* `/` */
          }

          if (code === 47
          /* `/` */
          ) {
              if (lastSlash === index - 1 || dots === 1) {// Empty.
              } else if (lastSlash !== index - 1 && dots === 2) {
                if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46
                /* `.` */
                || result.charCodeAt(result.length - 2) !== 46
                /* `.` */
                ) {
                    if (result.length > 2) {
                      lastSlashIndex = result.lastIndexOf('/');
                      /* istanbul ignore else - No clue how to cover it. */

                      if (lastSlashIndex !== result.length - 1) {
                        if (lastSlashIndex < 0) {
                          result = '';
                          lastSegmentLength = 0;
                        } else {
                          result = result.slice(0, lastSlashIndex);
                          lastSegmentLength = result.length - 1 - result.lastIndexOf('/');
                        }

                        lastSlash = index;
                        dots = 0;
                        continue;
                      }
                    } else if (result.length) {
                      result = '';
                      lastSegmentLength = 0;
                      lastSlash = index;
                      dots = 0;
                      continue;
                    }
                  }

                if (allowAboveRoot) {
                  result = result.length ? result + '/..' : '..';
                  lastSegmentLength = 2;
                }
              } else {
                if (result.length) {
                  result += '/' + path.slice(lastSlash + 1, index);
                } else {
                  result = path.slice(lastSlash + 1, index);
                }

                lastSegmentLength = index - lastSlash - 1;
              }

              lastSlash = index;
              dots = 0;
            } else if (code === 46
          /* `.` */
          && dots > -1) {
            dots++;
          } else {
            dots = -1;
          }
        }

        return result;
      }

      function assertPath(path) {
        if (typeof path !== 'string') {
          throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
        }
      }
      /***/

    },

    /***/
    "ujgL":
    /*!*********************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/table.js ***!
      \*********************************************************/

    /*! no static exports found */

    /***/
    function ujgL(module, exports, __webpack_require__) {
      "use strict";

      var whitespace = __webpack_require__(
      /*! is-whitespace-character */
      "IPAr");

      module.exports = table;
      var tab = '\t';
      var lineFeed = '\n';
      var space = ' ';
      var dash = '-';
      var colon = ':';
      var backslash = '\\';
      var verticalBar = '|';
      var minColumns = 1;
      var minRows = 2;
      var left = 'left';
      var center = 'center';
      var right = 'right';

      function table(eat, value, silent) {
        var self = this;
        var index;
        var alignments;
        var alignment;
        var subvalue;
        var row;
        var length;
        var lines;
        var queue;
        var character;
        var hasDash;
        var align;
        var cell;
        var preamble;
        var now;
        var position;
        var lineCount;
        var line;
        var rows;
        var table;
        var lineIndex;
        var pipeIndex;
        var first; // Exit when not in gfm-mode.

        if (!self.options.gfm) {
          return;
        } // Get the rows.
        // Detecting tables soon is hard, so there are some checks for performance
        // here, such as the minimum number of rows, and allowed characters in the
        // alignment row.


        index = 0;
        lineCount = 0;
        length = value.length + 1;
        lines = [];

        while (index < length) {
          lineIndex = value.indexOf(lineFeed, index);
          pipeIndex = value.indexOf(verticalBar, index + 1);

          if (lineIndex === -1) {
            lineIndex = value.length;
          }

          if (pipeIndex === -1 || pipeIndex > lineIndex) {
            if (lineCount < minRows) {
              return;
            }

            break;
          }

          lines.push(value.slice(index, lineIndex));
          lineCount++;
          index = lineIndex + 1;
        } // Parse the alignment row.


        subvalue = lines.join(lineFeed);
        alignments = lines.splice(1, 1)[0] || [];
        index = 0;
        length = alignments.length;
        lineCount--;
        alignment = false;
        align = [];

        while (index < length) {
          character = alignments.charAt(index);

          if (character === verticalBar) {
            hasDash = null;

            if (alignment === false) {
              if (first === false) {
                return;
              }
            } else {
              align.push(alignment);
              alignment = false;
            }

            first = false;
          } else if (character === dash) {
            hasDash = true;
            alignment = alignment || null;
          } else if (character === colon) {
            if (alignment === left) {
              alignment = center;
            } else if (hasDash && alignment === null) {
              alignment = right;
            } else {
              alignment = left;
            }
          } else if (!whitespace(character)) {
            return;
          }

          index++;
        }

        if (alignment !== false) {
          align.push(alignment);
        } // Exit when without enough columns.


        if (align.length < minColumns) {
          return;
        }
        /* istanbul ignore if - never used (yet) */


        if (silent) {
          return true;
        } // Parse the rows.


        position = -1;
        rows = [];
        table = eat(subvalue).reset({
          type: 'table',
          align: align,
          children: rows
        });

        while (++position < lineCount) {
          line = lines[position];
          row = {
            type: 'tableRow',
            children: []
          }; // Eat a newline character when this is not the first row.

          if (position) {
            eat(lineFeed);
          } // Eat the row.


          eat(line).reset(row, table);
          length = line.length + 1;
          index = 0;
          queue = '';
          cell = '';
          preamble = true;

          while (index < length) {
            character = line.charAt(index);

            if (character === tab || character === space) {
              if (cell) {
                queue += character;
              } else {
                eat(character);
              }

              index++;
              continue;
            }

            if (character === '' || character === verticalBar) {
              if (preamble) {
                eat(character);
              } else {
                if ((cell || character) && !preamble) {
                  subvalue = cell;

                  if (queue.length > 1) {
                    if (character) {
                      subvalue += queue.slice(0, -1);
                      queue = queue.charAt(queue.length - 1);
                    } else {
                      subvalue += queue;
                      queue = '';
                    }
                  }

                  now = eat.now();
                  eat(subvalue)({
                    type: 'tableCell',
                    children: self.tokenizeInline(cell, now)
                  }, row);
                }

                eat(queue + character);
                queue = '';
                cell = '';
              }
            } else {
              if (queue) {
                cell += queue;
                queue = '';
              }

              cell += character;

              if (character === backslash && index !== length - 2) {
                cell += line.charAt(index + 1);
                index++;
              }
            }

            preamble = false;
            index++;
          } // Eat the alignment row.


          if (!position) {
            eat(lineFeed + alignments);
          }
        }

        return table;
      }
      /***/

    },

    /***/
    "uzq8":
    /*!********************************************************!*\
      !*** ./node_modules/unist-util-visit-parents/index.js ***!
      \********************************************************/

    /*! no static exports found */

    /***/
    function uzq8(module, exports, __webpack_require__) {
      "use strict";

      module.exports = visitParents;

      var convert = __webpack_require__(
      /*! unist-util-is/convert */
      "Zasy");

      var color = __webpack_require__(
      /*! ./color */
      "AJTF");

      var CONTINUE = true;
      var SKIP = 'skip';
      var EXIT = false;
      visitParents.CONTINUE = CONTINUE;
      visitParents.SKIP = SKIP;
      visitParents.EXIT = EXIT;

      function visitParents(tree, test, visitor, reverse) {
        var step;
        var is;

        if (typeof test === 'function' && typeof visitor !== 'function') {
          reverse = visitor;
          visitor = test;
          test = null;
        }

        is = convert(test);
        step = reverse ? -1 : 1;
        factory(tree, null, [])();

        function factory(node, index, parents) {
          var value = typeof node === 'object' && node !== null ? node : {};
          var name;

          if (typeof value.type === 'string') {
            name = typeof value.tagName === 'string' ? value.tagName : typeof value.name === 'string' ? value.name : undefined;
            visit.displayName = 'node (' + color(value.type + (name ? '<' + name + '>' : '')) + ')';
          }

          return visit;

          function visit() {
            var grandparents = parents.concat(node);
            var result = [];
            var subresult;
            var offset;

            if (!test || is(node, index, parents[parents.length - 1] || null)) {
              result = toResult(visitor(node, parents));

              if (result[0] === EXIT) {
                return result;
              }
            }

            if (node.children && result[0] !== SKIP) {
              offset = (reverse ? node.children.length : -1) + step;

              while (offset > -1 && offset < node.children.length) {
                subresult = factory(node.children[offset], offset, grandparents)();

                if (subresult[0] === EXIT) {
                  return subresult;
                }

                offset = typeof subresult[1] === 'number' ? subresult[1] : offset + step;
              }
            }

            return result;
          }
        }
      }

      function toResult(value) {
        if (value !== null && typeof value === 'object' && 'length' in value) {
          return value;
        }

        if (typeof value === 'number') {
          return [CONTINUE, value];
        }

        return [value];
      }
      /***/

    },

    /***/
    "wCsn":
    /*!*************************************************************!*\
      !*** ./node_modules/remark-parse/lib/tokenize/reference.js ***!
      \*************************************************************/

    /*! no static exports found */

    /***/
    function wCsn(module, exports, __webpack_require__) {
      "use strict";

      var whitespace = __webpack_require__(
      /*! is-whitespace-character */
      "IPAr");

      var locate = __webpack_require__(
      /*! ../locate/link */
      "EmYC");

      var normalize = __webpack_require__(
      /*! ../util/normalize */
      "kaWx");

      module.exports = reference;
      reference.locator = locate;
      var link = 'link';
      var image = 'image';
      var shortcut = 'shortcut';
      var collapsed = 'collapsed';
      var full = 'full';
      var exclamationMark = '!';
      var leftSquareBracket = '[';
      var backslash = '\\';
      var rightSquareBracket = ']';

      function reference(eat, value, silent) {
        var self = this;
        var commonmark = self.options.commonmark;
        var character = value.charAt(0);
        var index = 0;
        var length = value.length;
        var subvalue = '';
        var intro = '';
        var type = link;
        var referenceType = shortcut;
        var content;
        var identifier;
        var now;
        var node;
        var exit;
        var queue;
        var bracketed;
        var depth; // Check whether we’re eating an image.

        if (character === exclamationMark) {
          type = image;
          intro = character;
          character = value.charAt(++index);
        }

        if (character !== leftSquareBracket) {
          return;
        }

        index++;
        intro += character;
        queue = ''; // Eat the text.

        depth = 0;

        while (index < length) {
          character = value.charAt(index);

          if (character === leftSquareBracket) {
            bracketed = true;
            depth++;
          } else if (character === rightSquareBracket) {
            if (!depth) {
              break;
            }

            depth--;
          }

          if (character === backslash) {
            queue += backslash;
            character = value.charAt(++index);
          }

          queue += character;
          index++;
        }

        subvalue = queue;
        content = queue;
        character = value.charAt(index);

        if (character !== rightSquareBracket) {
          return;
        }

        index++;
        subvalue += character;
        queue = '';

        if (!commonmark) {
          // The original markdown syntax definition explicitly allows for whitespace
          // between the link text and link label; commonmark departs from this, in
          // part to improve support for shortcut reference links
          while (index < length) {
            character = value.charAt(index);

            if (!whitespace(character)) {
              break;
            }

            queue += character;
            index++;
          }
        }

        character = value.charAt(index);

        if (character === leftSquareBracket) {
          identifier = '';
          queue += character;
          index++;

          while (index < length) {
            character = value.charAt(index);

            if (character === leftSquareBracket || character === rightSquareBracket) {
              break;
            }

            if (character === backslash) {
              identifier += backslash;
              character = value.charAt(++index);
            }

            identifier += character;
            index++;
          }

          character = value.charAt(index);

          if (character === rightSquareBracket) {
            referenceType = identifier ? full : collapsed;
            queue += identifier + character;
            index++;
          } else {
            identifier = '';
          }

          subvalue += queue;
          queue = '';
        } else {
          if (!content) {
            return;
          }

          identifier = content;
        } // Brackets cannot be inside the identifier.


        if (referenceType !== full && bracketed) {
          return;
        }

        subvalue = intro + subvalue;

        if (type === link && self.inLink) {
          return null;
        }
        /* istanbul ignore if - never used (yet) */


        if (silent) {
          return true;
        }

        now = eat.now();
        now.column += intro.length;
        now.offset += intro.length;
        identifier = referenceType === full ? identifier : content;
        node = {
          type: type + 'Reference',
          identifier: normalize(identifier),
          label: identifier,
          referenceType: referenceType
        };

        if (type === link) {
          exit = self.enterLink();
          node.children = self.tokenizeInline(content, now);
          exit();
        } else {
          node.alt = self.decode.raw(self.unescape(content), now) || null;
        }

        return eat(subvalue)(node);
      }
      /***/

    },

    /***/
    "wZee":
    /*!***************************************!*\
      !*** ./node_modules/prismjs/prism.js ***!
      \***************************************/

    /*! no static exports found */

    /***/
    function wZee(module, exports, __webpack_require__) {
      /* **********************************************
           Begin prism-core.js
      ********************************************** */
      /// <reference lib="WebWorker"/>
      var _self = typeof window !== 'undefined' ? window // if in browser
      : typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self // if in worker
      : {} // if in node js
      ;
      /**
       * Prism: Lightweight, robust, elegant syntax highlighting
       *
       * @license MIT <https://opensource.org/licenses/MIT>
       * @author Lea Verou <https://lea.verou.me>
       * @namespace
       * @public
       */


      var Prism = function (_self) {
        // Private helper vars
        var lang = /\blang(?:uage)?-([\w-]+)\b/i;
        var uniqueId = 0;
        var _ = {
          /**
           * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
           * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
           * additional languages or plugins yourself.
           *
           * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
           *
           * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
           * empty Prism object into the global scope before loading the Prism script like this:
           *
           * ```js
           * window.Prism = window.Prism || {};
           * Prism.manual = true;
           * // add a new <script> to load Prism's script
           * ```
           *
           * @default false
           * @type {boolean}
           * @memberof Prism
           * @public
           */
          manual: _self.Prism && _self.Prism.manual,
          disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

          /**
           * A namespace for utility methods.
           *
           * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
           * change or disappear at any time.
           *
           * @namespace
           * @memberof Prism
           */
          util: {
            encode: function encode(tokens) {
              if (tokens instanceof Token) {
                return new Token(tokens.type, encode(tokens.content), tokens.alias);
              } else if (Array.isArray(tokens)) {
                return tokens.map(encode);
              } else {
                return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
              }
            },

            /**
             * Returns the name of the type of the given value.
             *
             * @param {any} o
             * @returns {string}
             * @example
             * type(null)      === 'Null'
             * type(undefined) === 'Undefined'
             * type(123)       === 'Number'
             * type('foo')     === 'String'
             * type(true)      === 'Boolean'
             * type([1, 2])    === 'Array'
             * type({})        === 'Object'
             * type(String)    === 'Function'
             * type(/abc+/)    === 'RegExp'
             */
            type: function type(o) {
              return Object.prototype.toString.call(o).slice(8, -1);
            },

            /**
             * Returns a unique number for the given object. Later calls will still return the same number.
             *
             * @param {Object} obj
             * @returns {number}
             */
            objId: function objId(obj) {
              if (!obj['__id']) {
                Object.defineProperty(obj, '__id', {
                  value: ++uniqueId
                });
              }

              return obj['__id'];
            },

            /**
             * Creates a deep clone of the given object.
             *
             * The main intended use of this function is to clone language definitions.
             *
             * @param {T} o
             * @param {Record<number, any>} [visited]
             * @returns {T}
             * @template T
             */
            clone: function deepClone(o, visited) {
              visited = visited || {};
              var clone, id;

              switch (_.util.type(o)) {
                case 'Object':
                  id = _.util.objId(o);

                  if (visited[id]) {
                    return visited[id];
                  }

                  clone =
                  /** @type {Record<string, any>} */
                  {};
                  visited[id] = clone;

                  for (var key in o) {
                    if (o.hasOwnProperty(key)) {
                      clone[key] = deepClone(o[key], visited);
                    }
                  }

                  return (
                    /** @type {any} */
                    clone
                  );

                case 'Array':
                  id = _.util.objId(o);

                  if (visited[id]) {
                    return visited[id];
                  }

                  clone = [];
                  visited[id] = clone;

                  /** @type {Array} */

                  /** @type {any} */
                  o.forEach(function (v, i) {
                    clone[i] = deepClone(v, visited);
                  });
                  return (
                    /** @type {any} */
                    clone
                  );

                default:
                  return o;
              }
            },

            /**
             * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
             *
             * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
             *
             * @param {Element} element
             * @returns {string}
             */
            getLanguage: function getLanguage(element) {
              while (element && !lang.test(element.className)) {
                element = element.parentElement;
              }

              if (element) {
                return (element.className.match(lang) || [, 'none'])[1].toLowerCase();
              }

              return 'none';
            },

            /**
             * Returns the script element that is currently executing.
             *
             * This does __not__ work for line script element.
             *
             * @returns {HTMLScriptElement | null}
             */
            currentScript: function currentScript() {
              if (typeof document === 'undefined') {
                return null;
              }

              if ('currentScript' in document && 1 < 2
              /* hack to trip TS' flow analysis */
              ) {
                  return (
                    /** @type {any} */
                    document.currentScript
                  );
                } // IE11 workaround
              // we'll get the src of the current script by parsing IE11's error stack trace
              // this will not work for inline scripts


              try {
                throw new Error();
              } catch (err) {
                // Get file src url from stack. Specifically works with the format of stack traces in IE.
                // A stack will look like this:
                //
                // Error
                //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
                //    at Global code (http://localhost/components/prism-core.js:606:1)
                var src = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(err.stack) || [])[1];

                if (src) {
                  var scripts = document.getElementsByTagName('script');

                  for (var i in scripts) {
                    if (scripts[i].src == src) {
                      return scripts[i];
                    }
                  }
                }

                return null;
              }
            },

            /**
             * Returns whether a given class is active for `element`.
             *
             * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
             * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
             * given class is just the given class with a `no-` prefix.
             *
             * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
             * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
             * ancestors have the given class or the negated version of it, then the default activation will be returned.
             *
             * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
             * version of it, the class is considered active.
             *
             * @param {Element} element
             * @param {string} className
             * @param {boolean} [defaultActivation=false]
             * @returns {boolean}
             */
            isActive: function isActive(element, className, defaultActivation) {
              var no = 'no-' + className;

              while (element) {
                var classList = element.classList;

                if (classList.contains(className)) {
                  return true;
                }

                if (classList.contains(no)) {
                  return false;
                }

                element = element.parentElement;
              }

              return !!defaultActivation;
            }
          },

          /**
           * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
           *
           * @namespace
           * @memberof Prism
           * @public
           */
          languages: {
            /**
             * Creates a deep copy of the language with the given id and appends the given tokens.
             *
             * If a token in `redef` also appears in the copied language, then the existing token in the copied language
             * will be overwritten at its original position.
             *
             * ## Best practices
             *
             * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
             * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
             * understand the language definition because, normally, the order of tokens matters in Prism grammars.
             *
             * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
             * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
             *
             * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
             * @param {Grammar} redef The new tokens to append.
             * @returns {Grammar} The new language created.
             * @public
             * @example
             * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
             *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
             *     // at its original position
             *     'comment': { ... },
             *     // CSS doesn't have a 'color' token, so this token will be appended
             *     'color': /\b(?:red|green|blue)\b/
             * });
             */
            extend: function extend(id, redef) {
              var lang = _.util.clone(_.languages[id]);

              for (var key in redef) {
                lang[key] = redef[key];
              }

              return lang;
            },

            /**
             * Inserts tokens _before_ another token in a language definition or any other grammar.
             *
             * ## Usage
             *
             * This helper method makes it easy to modify existing languages. For example, the CSS language definition
             * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
             * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
             * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
             * this:
             *
             * ```js
             * Prism.languages.markup.style = {
             *     // token
             * };
             * ```
             *
             * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
             * before existing tokens. For the CSS example above, you would use it like this:
             *
             * ```js
             * Prism.languages.insertBefore('markup', 'cdata', {
             *     'style': {
             *         // token
             *     }
             * });
             * ```
             *
             * ## Special cases
             *
             * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
             * will be ignored.
             *
             * This behavior can be used to insert tokens after `before`:
             *
             * ```js
             * Prism.languages.insertBefore('markup', 'comment', {
             *     'comment': Prism.languages.markup.comment,
             *     // tokens after 'comment'
             * });
             * ```
             *
             * ## Limitations
             *
             * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
             * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
             * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
             * deleting properties which is necessary to insert at arbitrary positions.
             *
             * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
             * Instead, it will create a new object and replace all references to the target object with the new one. This
             * can be done without temporarily deleting properties, so the iteration order is well-defined.
             *
             * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
             * you hold the target object in a variable, then the value of the variable will not change.
             *
             * ```js
             * var oldMarkup = Prism.languages.markup;
             * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
             *
             * assert(oldMarkup !== Prism.languages.markup);
             * assert(newMarkup === Prism.languages.markup);
             * ```
             *
             * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
             * object to be modified.
             * @param {string} before The key to insert before.
             * @param {Grammar} insert An object containing the key-value pairs to be inserted.
             * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
             * object to be modified.
             *
             * Defaults to `Prism.languages`.
             * @returns {Grammar} The new grammar object.
             * @public
             */
            insertBefore: function insertBefore(inside, before, insert, root) {
              root = root ||
              /** @type {any} */
              _.languages;
              var grammar = root[inside];
              /** @type {Grammar} */

              var ret = {};

              for (var token in grammar) {
                if (grammar.hasOwnProperty(token)) {
                  if (token == before) {
                    for (var newToken in insert) {
                      if (insert.hasOwnProperty(newToken)) {
                        ret[newToken] = insert[newToken];
                      }
                    }
                  } // Do not insert token which also occur in insert. See #1525


                  if (!insert.hasOwnProperty(token)) {
                    ret[token] = grammar[token];
                  }
                }
              }

              var old = root[inside];
              root[inside] = ret; // Update references in other language definitions

              _.languages.DFS(_.languages, function (key, value) {
                if (value === old && key != inside) {
                  this[key] = ret;
                }
              });

              return ret;
            },
            // Traverse a language definition with Depth First Search
            DFS: function DFS(o, callback, type, visited) {
              visited = visited || {};
              var objId = _.util.objId;

              for (var i in o) {
                if (o.hasOwnProperty(i)) {
                  callback.call(o, i, o[i], type || i);

                  var property = o[i],
                      propertyType = _.util.type(property);

                  if (propertyType === 'Object' && !visited[objId(property)]) {
                    visited[objId(property)] = true;
                    DFS(property, callback, null, visited);
                  } else if (propertyType === 'Array' && !visited[objId(property)]) {
                    visited[objId(property)] = true;
                    DFS(property, callback, i, visited);
                  }
                }
              }
            }
          },
          plugins: {},

          /**
           * This is the most high-level function in Prism’s API.
           * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
           * each one of them.
           *
           * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
           *
           * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
           * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
           * @memberof Prism
           * @public
           */
          highlightAll: function highlightAll(async, callback) {
            _.highlightAllUnder(document, async, callback);
          },

          /**
           * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
           * {@link Prism.highlightElement} on each one of them.
           *
           * The following hooks will be run:
           * 1. `before-highlightall`
           * 2. `before-all-elements-highlight`
           * 3. All hooks of {@link Prism.highlightElement} for each element.
           *
           * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
           * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
           * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
           * @memberof Prism
           * @public
           */
          highlightAllUnder: function highlightAllUnder(container, async, callback) {
            var env = {
              callback: callback,
              container: container,
              selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };

            _.hooks.run('before-highlightall', env);

            env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

            _.hooks.run('before-all-elements-highlight', env);

            for (var i = 0, element; element = env.elements[i++];) {
              _.highlightElement(element, async === true, env.callback);
            }
          },

          /**
           * Highlights the code inside a single element.
           *
           * The following hooks will be run:
           * 1. `before-sanity-check`
           * 2. `before-highlight`
           * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
           * 4. `before-insert`
           * 5. `after-highlight`
           * 6. `complete`
           *
           * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
           * the element's language.
           *
           * @param {Element} element The element containing the code.
           * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
           * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
           * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
           * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
           *
           * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
           * asynchronous highlighting to work. You can build your own bundle on the
           * [Download page](https://prismjs.com/download.html).
           * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
           * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
           * @memberof Prism
           * @public
           */
          highlightElement: function highlightElement(element, async, callback) {
            // Find language
            var language = _.util.getLanguage(element);

            var grammar = _.languages[language]; // Set language on the element, if not present

            element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language; // Set language on the parent, for styling

            var parent = element.parentElement;

            if (parent && parent.nodeName.toLowerCase() === 'pre') {
              parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
            }

            var code = element.textContent;
            var env = {
              element: element,
              language: language,
              grammar: grammar,
              code: code
            };

            function insertHighlightedCode(highlightedCode) {
              env.highlightedCode = highlightedCode;

              _.hooks.run('before-insert', env);

              env.element.innerHTML = env.highlightedCode;

              _.hooks.run('after-highlight', env);

              _.hooks.run('complete', env);

              callback && callback.call(env.element);
            }

            _.hooks.run('before-sanity-check', env);

            if (!env.code) {
              _.hooks.run('complete', env);

              callback && callback.call(env.element);
              return;
            }

            _.hooks.run('before-highlight', env);

            if (!env.grammar) {
              insertHighlightedCode(_.util.encode(env.code));
              return;
            }

            if (async && _self.Worker) {
              var worker = new Worker(_.filename);

              worker.onmessage = function (evt) {
                insertHighlightedCode(evt.data);
              };

              worker.postMessage(JSON.stringify({
                language: env.language,
                code: env.code,
                immediateClose: true
              }));
            } else {
              insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
            }
          },

          /**
           * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
           * and the language definitions to use, and returns a string with the HTML produced.
           *
           * The following hooks will be run:
           * 1. `before-tokenize`
           * 2. `after-tokenize`
           * 3. `wrap`: On each {@link Token}.
           *
           * @param {string} text A string with the code to be highlighted.
           * @param {Grammar} grammar An object containing the tokens to use.
           *
           * Usually a language definition like `Prism.languages.markup`.
           * @param {string} language The name of the language definition passed to `grammar`.
           * @returns {string} The highlighted HTML.
           * @memberof Prism
           * @public
           * @example
           * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
           */
          highlight: function highlight(text, grammar, language) {
            var env = {
              code: text,
              grammar: grammar,
              language: language
            };

            _.hooks.run('before-tokenize', env);

            env.tokens = _.tokenize(env.code, env.grammar);

            _.hooks.run('after-tokenize', env);

            return Token.stringify(_.util.encode(env.tokens), env.language);
          },

          /**
           * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
           * and the language definitions to use, and returns an array with the tokenized code.
           *
           * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
           *
           * This method could be useful in other contexts as well, as a very crude parser.
           *
           * @param {string} text A string with the code to be highlighted.
           * @param {Grammar} grammar An object containing the tokens to use.
           *
           * Usually a language definition like `Prism.languages.markup`.
           * @returns {TokenStream} An array of strings and tokens, a token stream.
           * @memberof Prism
           * @public
           * @example
           * let code = `var foo = 0;`;
           * let tokens = Prism.tokenize(code, Prism.languages.javascript);
           * tokens.forEach(token => {
           *     if (token instanceof Prism.Token && token.type === 'number') {
           *         console.log(`Found numeric literal: ${token.content}`);
           *     }
           * });
           */
          tokenize: function tokenize(text, grammar) {
            var rest = grammar.rest;

            if (rest) {
              for (var token in rest) {
                grammar[token] = rest[token];
              }

              delete grammar.rest;
            }

            var tokenList = new LinkedList();
            addAfter(tokenList, tokenList.head, text);
            matchGrammar(text, tokenList, grammar, tokenList.head, 0);
            return toArray(tokenList);
          },

          /**
           * @namespace
           * @memberof Prism
           * @public
           */
          hooks: {
            all: {},

            /**
             * Adds the given callback to the list of callbacks for the given hook.
             *
             * The callback will be invoked when the hook it is registered for is run.
             * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
             *
             * One callback function can be registered to multiple hooks and the same hook multiple times.
             *
             * @param {string} name The name of the hook.
             * @param {HookCallback} callback The callback function which is given environment variables.
             * @public
             */
            add: function add(name, callback) {
              var hooks = _.hooks.all;
              hooks[name] = hooks[name] || [];
              hooks[name].push(callback);
            },

            /**
             * Runs a hook invoking all registered callbacks with the given environment variables.
             *
             * Callbacks will be invoked synchronously and in the order in which they were registered.
             *
             * @param {string} name The name of the hook.
             * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
             * @public
             */
            run: function run(name, env) {
              var callbacks = _.hooks.all[name];

              if (!callbacks || !callbacks.length) {
                return;
              }

              for (var i = 0, callback; callback = callbacks[i++];) {
                callback(env);
              }
            }
          },
          Token: Token
        };
        _self.Prism = _; // Typescript note:
        // The following can be used to import the Token type in JSDoc:
        //
        //   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

        /**
         * Creates a new token.
         *
         * @param {string} type See {@link Token#type type}
         * @param {string | TokenStream} content See {@link Token#content content}
         * @param {string|string[]} [alias] The alias(es) of the token.
         * @param {string} [matchedStr=""] A copy of the full string this token was created from.
         * @class
         * @global
         * @public
         */

        function Token(type, content, alias, matchedStr) {
          /**
           * The type of the token.
           *
           * This is usually the key of a pattern in a {@link Grammar}.
           *
           * @type {string}
           * @see GrammarToken
           * @public
           */
          this.type = type;
          /**
           * The strings or tokens contained by this token.
           *
           * This will be a token stream if the pattern matched also defined an `inside` grammar.
           *
           * @type {string | TokenStream}
           * @public
           */

          this.content = content;
          /**
           * The alias(es) of the token.
           *
           * @type {string|string[]}
           * @see GrammarToken
           * @public
           */

          this.alias = alias; // Copy of the full string this token was created from

          this.length = (matchedStr || '').length | 0;
        }
        /**
         * A token stream is an array of strings and {@link Token Token} objects.
         *
         * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
         * them.
         *
         * 1. No adjacent strings.
         * 2. No empty strings.
         *
         *    The only exception here is the token stream that only contains the empty string and nothing else.
         *
         * @typedef {Array<string | Token>} TokenStream
         * @global
         * @public
         */

        /**
         * Converts the given token or token stream to an HTML representation.
         *
         * The following hooks will be run:
         * 1. `wrap`: On each {@link Token}.
         *
         * @param {string | Token | TokenStream} o The token or token stream to be converted.
         * @param {string} language The name of current language.
         * @returns {string} The HTML representation of the token or token stream.
         * @memberof Token
         * @static
         */


        Token.stringify = function stringify(o, language) {
          if (typeof o == 'string') {
            return o;
          }

          if (Array.isArray(o)) {
            var s = '';
            o.forEach(function (e) {
              s += stringify(e, language);
            });
            return s;
          }

          var env = {
            type: o.type,
            content: stringify(o.content, language),
            tag: 'span',
            classes: ['token', o.type],
            attributes: {},
            language: language
          };
          var aliases = o.alias;

          if (aliases) {
            if (Array.isArray(aliases)) {
              Array.prototype.push.apply(env.classes, aliases);
            } else {
              env.classes.push(aliases);
            }
          }

          _.hooks.run('wrap', env);

          var attributes = '';

          for (var name in env.attributes) {
            attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
          }

          return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
        };
        /**
         * @param {RegExp} pattern
         * @param {number} pos
         * @param {string} text
         * @param {boolean} lookbehind
         * @returns {RegExpExecArray | null}
         */


        function matchPattern(pattern, pos, text, lookbehind) {
          pattern.lastIndex = pos;
          var match = pattern.exec(text);

          if (match && lookbehind && match[1]) {
            // change the match to remove the text matched by the Prism lookbehind group
            var lookbehindLength = match[1].length;
            match.index += lookbehindLength;
            match[0] = match[0].slice(lookbehindLength);
          }

          return match;
        }
        /**
         * @param {string} text
         * @param {LinkedList<string | Token>} tokenList
         * @param {any} grammar
         * @param {LinkedListNode<string | Token>} startNode
         * @param {number} startPos
         * @param {RematchOptions} [rematch]
         * @returns {void}
         * @private
         *
         * @typedef RematchOptions
         * @property {string} cause
         * @property {number} reach
         */


        function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
          for (var token in grammar) {
            if (!grammar.hasOwnProperty(token) || !grammar[token]) {
              continue;
            }

            var patterns = grammar[token];
            patterns = Array.isArray(patterns) ? patterns : [patterns];

            for (var j = 0; j < patterns.length; ++j) {
              if (rematch && rematch.cause == token + ',' + j) {
                return;
              }

              var patternObj = patterns[j],
                  inside = patternObj.inside,
                  lookbehind = !!patternObj.lookbehind,
                  greedy = !!patternObj.greedy,
                  alias = patternObj.alias;

              if (greedy && !patternObj.pattern.global) {
                // Without the global flag, lastIndex won't work
                var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
              }
              /** @type {RegExp} */


              var pattern = patternObj.pattern || patternObj;

              for ( // iterate the token list and keep track of the current token/string position
              var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
                if (rematch && pos >= rematch.reach) {
                  break;
                }

                var str = currentNode.value;

                if (tokenList.length > text.length) {
                  // Something went terribly wrong, ABORT, ABORT!
                  return;
                }

                if (str instanceof Token) {
                  continue;
                }

                var removeCount = 1; // this is the to parameter of removeBetween

                var match;

                if (greedy) {
                  match = matchPattern(pattern, pos, text, lookbehind);

                  if (!match) {
                    break;
                  }

                  var from = match.index;
                  var to = match.index + match[0].length;
                  var p = pos; // find the node that contains the match

                  p += currentNode.value.length;

                  while (from >= p) {
                    currentNode = currentNode.next;
                    p += currentNode.value.length;
                  } // adjust pos (and p)


                  p -= currentNode.value.length;
                  pos = p; // the current node is a Token, then the match starts inside another Token, which is invalid

                  if (currentNode.value instanceof Token) {
                    continue;
                  } // find the last node which is affected by this match


                  for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === 'string'); k = k.next) {
                    removeCount++;
                    p += k.value.length;
                  }

                  removeCount--; // replace with the new match

                  str = text.slice(pos, p);
                  match.index -= pos;
                } else {
                  match = matchPattern(pattern, 0, str, lookbehind);

                  if (!match) {
                    continue;
                  }
                }

                var from = match.index,
                    matchStr = match[0],
                    before = str.slice(0, from),
                    after = str.slice(from + matchStr.length);
                var reach = pos + str.length;

                if (rematch && reach > rematch.reach) {
                  rematch.reach = reach;
                }

                var removeFrom = currentNode.prev;

                if (before) {
                  removeFrom = addAfter(tokenList, removeFrom, before);
                  pos += before.length;
                }

                removeRange(tokenList, removeFrom, removeCount);
                var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                currentNode = addAfter(tokenList, removeFrom, wrapped);

                if (after) {
                  addAfter(tokenList, currentNode, after);
                }

                if (removeCount > 1) {
                  // at least one Token object was removed, so we have to do some rematching
                  // this can only happen if the current pattern is greedy
                  matchGrammar(text, tokenList, grammar, currentNode.prev, pos, {
                    cause: token + ',' + j,
                    reach: reach
                  });
                }
              }
            }
          }
        }
        /**
         * @typedef LinkedListNode
         * @property {T} value
         * @property {LinkedListNode<T> | null} prev The previous node.
         * @property {LinkedListNode<T> | null} next The next node.
         * @template T
         * @private
         */

        /**
         * @template T
         * @private
         */


        function LinkedList() {
          /** @type {LinkedListNode<T>} */
          var head = {
            value: null,
            prev: null,
            next: null
          };
          /** @type {LinkedListNode<T>} */

          var tail = {
            value: null,
            prev: head,
            next: null
          };
          head.next = tail;
          /** @type {LinkedListNode<T>} */

          this.head = head;
          /** @type {LinkedListNode<T>} */

          this.tail = tail;
          this.length = 0;
        }
        /**
         * Adds a new node with the given value to the list.
         * @param {LinkedList<T>} list
         * @param {LinkedListNode<T>} node
         * @param {T} value
         * @returns {LinkedListNode<T>} The added node.
         * @template T
         */


        function addAfter(list, node, value) {
          // assumes that node != list.tail && values.length >= 0
          var next = node.next;
          var newNode = {
            value: value,
            prev: node,
            next: next
          };
          node.next = newNode;
          next.prev = newNode;
          list.length++;
          return newNode;
        }
        /**
         * Removes `count` nodes after the given node. The given node will not be removed.
         * @param {LinkedList<T>} list
         * @param {LinkedListNode<T>} node
         * @param {number} count
         * @template T
         */


        function removeRange(list, node, count) {
          var next = node.next;

          for (var i = 0; i < count && next !== list.tail; i++) {
            next = next.next;
          }

          node.next = next;
          next.prev = node;
          list.length -= i;
        }
        /**
         * @param {LinkedList<T>} list
         * @returns {T[]}
         * @template T
         */


        function toArray(list) {
          var array = [];
          var node = list.head.next;

          while (node !== list.tail) {
            array.push(node.value);
            node = node.next;
          }

          return array;
        }

        if (!_self.document) {
          if (!_self.addEventListener) {
            // in Node.js
            return _;
          }

          if (!_.disableWorkerMessageHandler) {
            // In worker
            _self.addEventListener('message', function (evt) {
              var message = JSON.parse(evt.data),
                  lang = message.language,
                  code = message.code,
                  immediateClose = message.immediateClose;

              _self.postMessage(_.highlight(code, _.languages[lang], lang));

              if (immediateClose) {
                _self.close();
              }
            }, false);
          }

          return _;
        } // Get current script and highlight


        var script = _.util.currentScript();

        if (script) {
          _.filename = script.src;

          if (script.hasAttribute('data-manual')) {
            _.manual = true;
          }
        }

        function highlightAutomaticallyCallback() {
          if (!_.manual) {
            _.highlightAll();
          }
        }

        if (!_.manual) {
          // If the document state is "loading", then we'll use DOMContentLoaded.
          // If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
          // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
          // might take longer one animation frame to execute which can create a race condition where only some plugins have
          // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
          // See https://github.com/PrismJS/prism/issues/2102
          var readyState = document.readyState;

          if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
            document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
          } else {
            if (window.requestAnimationFrame) {
              window.requestAnimationFrame(highlightAutomaticallyCallback);
            } else {
              window.setTimeout(highlightAutomaticallyCallback, 16);
            }
          }
        }

        return _;
      }(_self);

      if (true && module.exports) {
        module.exports = Prism;
      } // hack for components to work correctly in node.js


      if (typeof global !== 'undefined') {
        global.Prism = Prism;
      } // some additional documentation/types

      /**
       * The expansion of a simple `RegExp` literal to support additional properties.
       *
       * @typedef GrammarToken
       * @property {RegExp} pattern The regular expression of the token.
       * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
       * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
       * @property {boolean} [greedy=false] Whether the token is greedy.
       * @property {string|string[]} [alias] An optional alias or list of aliases.
       * @property {Grammar} [inside] The nested grammar of this token.
       *
       * The `inside` grammar will be used to tokenize the text value of each token of this kind.
       *
       * This can be used to make nested and even recursive language definitions.
       *
       * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
       * each another.
       * @global
       * @public
      */

      /**
       * @typedef Grammar
       * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
       * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
       * @global
       * @public
       */

      /**
       * A function which will invoked after an element was successfully highlighted.
       *
       * @callback HighlightCallback
       * @param {Element} element The element successfully highlighted.
       * @returns {void}
       * @global
       * @public
      */

      /**
       * @callback HookCallback
       * @param {Object<string, any>} env The environment variables of the hook.
       * @returns {void}
       * @global
       * @public
       */

      /* **********************************************
           Begin prism-markup.js
      ********************************************** */


      Prism.languages.markup = {
        'comment': /<!--[\s\S]*?-->/,
        'prolog': /<\?[\s\S]+?\?>/,
        'doctype': {
          // https://www.w3.org/TR/xml/#NT-doctypedecl
          pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
          greedy: true,
          inside: {
            'internal-subset': {
              pattern: /(\[)[\s\S]+(?=\]>$)/,
              lookbehind: true,
              greedy: true,
              inside: null // see below

            },
            'string': {
              pattern: /"[^"]*"|'[^']*'/,
              greedy: true
            },
            'punctuation': /^<!|>$|[[\]]/,
            'doctype-tag': /^DOCTYPE/,
            'name': /[^\s<>'"]+/
          }
        },
        'cdata': /<!\[CDATA\[[\s\S]*?]]>/i,
        'tag': {
          pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
          greedy: true,
          inside: {
            'tag': {
              pattern: /^<\/?[^\s>\/]+/,
              inside: {
                'punctuation': /^<\/?/,
                'namespace': /^[^\s>\/:]+:/
              }
            },
            'attr-value': {
              pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
              inside: {
                'punctuation': [{
                  pattern: /^=/,
                  alias: 'attr-equals'
                }, /"|'/]
              }
            },
            'punctuation': /\/?>/,
            'attr-name': {
              pattern: /[^\s>\/]+/,
              inside: {
                'namespace': /^[^\s>\/:]+:/
              }
            }
          }
        },
        'entity': [{
          pattern: /&[\da-z]{1,8};/i,
          alias: 'named-entity'
        }, /&#x?[\da-f]{1,8};/i]
      };
      Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] = Prism.languages.markup['entity'];
      Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup; // Plugin to make entity title show the real entity, idea by Roman Komarov

      Prism.hooks.add('wrap', function (env) {
        if (env.type === 'entity') {
          env.attributes['title'] = env.content.replace(/&amp;/, '&');
        }
      });
      Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
        /**
         * Adds an inlined language to markup.
         *
         * An example of an inlined language is CSS with `<style>` tags.
         *
         * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addInlined('style', 'css');
         */
        value: function addInlined(tagName, lang) {
          var includedCdataInside = {};
          includedCdataInside['language-' + lang] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: true,
            inside: Prism.languages[lang]
          };
          includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;
          var inside = {
            'included-cdata': {
              pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
              inside: includedCdataInside
            }
          };
          inside['language-' + lang] = {
            pattern: /[\s\S]+/,
            inside: Prism.languages[lang]
          };
          var def = {};
          def[tagName] = {
            pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () {
              return tagName;
            }), 'i'),
            lookbehind: true,
            greedy: true,
            inside: inside
          };
          Prism.languages.insertBefore('markup', 'cdata', def);
        }
      });
      Prism.languages.html = Prism.languages.markup;
      Prism.languages.mathml = Prism.languages.markup;
      Prism.languages.svg = Prism.languages.markup;
      Prism.languages.xml = Prism.languages.extend('markup', {});
      Prism.languages.ssml = Prism.languages.xml;
      Prism.languages.atom = Prism.languages.xml;
      Prism.languages.rss = Prism.languages.xml;
      /* **********************************************
           Begin prism-css.js
      ********************************************** */

      (function (Prism) {
        var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
        Prism.languages.css = {
          'comment': /\/\*[\s\S]*?\*\//,
          'atrule': {
            pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
            inside: {
              'rule': /^@[\w-]+/,
              'selector-function-argument': {
                pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                lookbehind: true,
                alias: 'selector'
              },
              'keyword': {
                pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                lookbehind: true
              } // See rest below

            }
          },
          'url': {
            // https://drafts.csswg.org/css-values-3/#urls
            pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
            greedy: true,
            inside: {
              'function': /^url/i,
              'punctuation': /^\(|\)$/,
              'string': {
                pattern: RegExp('^' + string.source + '$'),
                alias: 'url'
              }
            }
          },
          'selector': RegExp('[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
          'string': {
            pattern: string,
            greedy: true
          },
          'property': /(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          'important': /!important\b/i,
          'function': /[-a-z0-9]+(?=\()/i,
          'punctuation': /[(){};:,]/
        };
        Prism.languages.css['atrule'].inside.rest = Prism.languages.css;
        var markup = Prism.languages.markup;

        if (markup) {
          markup.tag.addInlined('style', 'css');
          Prism.languages.insertBefore('inside', 'attr-value', {
            'style-attr': {
              pattern: /(^|["'\s])style\s*=\s*(?:"[^"]*"|'[^']*')/i,
              lookbehind: true,
              inside: {
                'attr-value': {
                  pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                  inside: {
                    'style': {
                      pattern: /(["'])[\s\S]+(?=["']$)/,
                      lookbehind: true,
                      alias: 'language-css',
                      inside: Prism.languages.css
                    },
                    'punctuation': [{
                      pattern: /^=/,
                      alias: 'attr-equals'
                    }, /"|'/]
                  }
                },
                'attr-name': /^style/i
              }
            }
          }, markup.tag);
        }
      })(Prism);
      /* **********************************************
           Begin prism-clike.js
      ********************************************** */


      Prism.languages.clike = {
        'comment': [{
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        }, {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }],
        'string': {
          pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: true
        },
        'class-name': {
          pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
          lookbehind: true,
          inside: {
            'punctuation': /[.\\]/
          }
        },
        'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
        'boolean': /\b(?:true|false)\b/,
        'function': /\w+(?=\()/,
        'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        'punctuation': /[{}[\];(),.:]/
      };
      /* **********************************************
           Begin prism-javascript.js
      ********************************************** */

      Prism.languages.javascript = Prism.languages.extend('clike', {
        'class-name': [Prism.languages.clike['class-name'], {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/,
          lookbehind: true
        }],
        'keyword': [{
          pattern: /((?:^|})\s*)(?:catch|finally)\b/,
          lookbehind: true
        }, {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|(?:get|set)(?=\s*[\[$\w\xA0-\uFFFF])|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }],
        // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
        'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        'number': /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
        'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
      });
      Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
      Prism.languages.insertBefore('javascript', 'keyword', {
        'regex': {
          pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
          lookbehind: true,
          greedy: true,
          inside: {
            'regex-source': {
              pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
              lookbehind: true,
              alias: 'language-regex',
              inside: Prism.languages.regex
            },
            'regex-flags': /[a-z]+$/,
            'regex-delimiter': /^\/|\/$/
          }
        },
        // This must be declared before keyword because we use "function" inside the look-forward
        'function-variable': {
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
          alias: 'function'
        },
        'parameter': [{
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism.languages.javascript
        }, {
          pattern: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          inside: Prism.languages.javascript
        }, {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        }, {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        }],
        'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
      });
      Prism.languages.insertBefore('javascript', 'string', {
        'template-string': {
          pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/,
          greedy: true,
          inside: {
            'template-punctuation': {
              pattern: /^`|`$/,
              alias: 'string'
            },
            'interpolation': {
              pattern: /((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,
              lookbehind: true,
              inside: {
                'interpolation-punctuation': {
                  pattern: /^\${|}$/,
                  alias: 'punctuation'
                },
                rest: Prism.languages.javascript
              }
            },
            'string': /[\s\S]+/
          }
        }
      });

      if (Prism.languages.markup) {
        Prism.languages.markup.tag.addInlined('script', 'javascript');
      }

      Prism.languages.js = Prism.languages.javascript;
      /* **********************************************
           Begin prism-file-highlight.js
      ********************************************** */

      (function () {
        if (typeof self === 'undefined' || !self.Prism || !self.document) {
          return;
        } // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill


        if (!Element.prototype.matches) {
          Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
        }

        var Prism = window.Prism;
        var LOADING_MESSAGE = 'Loading…';

        var FAILURE_MESSAGE = function FAILURE_MESSAGE(status, message) {
          return '✖ Error ' + status + ' while fetching file: ' + message;
        };

        var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';
        var EXTENSIONS = {
          'js': 'javascript',
          'py': 'python',
          'rb': 'ruby',
          'ps1': 'powershell',
          'psm1': 'powershell',
          'sh': 'bash',
          'bat': 'batch',
          'h': 'c',
          'tex': 'latex'
        };
        var STATUS_ATTR = 'data-src-status';
        var STATUS_LOADING = 'loading';
        var STATUS_LOADED = 'loaded';
        var STATUS_FAILED = 'failed';
        var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])' + ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
        var lang = /\blang(?:uage)?-([\w-]+)\b/i;
        /**
         * Sets the Prism `language-xxxx` or `lang-xxxx` class to the given language.
         *
         * @param {HTMLElement} element
         * @param {string} language
         * @returns {void}
         */

        function setLanguageClass(element, language) {
          var className = element.className;
          className = className.replace(lang, ' ') + ' language-' + language;
          element.className = className.replace(/\s+/g, ' ').trim();
        }

        Prism.hooks.add('before-highlightall', function (env) {
          env.selector += ', ' + SELECTOR;
        });
        Prism.hooks.add('before-sanity-check', function (env) {
          var pre =
          /** @type {HTMLPreElement} */
          env.element;

          if (pre.matches(SELECTOR)) {
            env.code = ''; // fast-path the whole thing and go to complete

            pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading
            // add code element with loading message

            var code = pre.appendChild(document.createElement('CODE'));
            code.textContent = LOADING_MESSAGE;
            var src = pre.getAttribute('data-src');
            var language = env.language;

            if (language === 'none') {
              // the language might be 'none' because there is no language set;
              // in this case, we want to use the extension as the language
              var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
              language = EXTENSIONS[extension] || extension;
            } // set language classes


            setLanguageClass(code, language);
            setLanguageClass(pre, language); // preload the language

            var autoloader = Prism.plugins.autoloader;

            if (autoloader) {
              autoloader.loadLanguages(language);
            } // load file


            var xhr = new XMLHttpRequest();
            xhr.open('GET', src, true);

            xhr.onreadystatechange = function () {
              if (xhr.readyState == 4) {
                if (xhr.status < 400 && xhr.responseText) {
                  // mark as loaded
                  pre.setAttribute(STATUS_ATTR, STATUS_LOADED); // highlight code

                  code.textContent = xhr.responseText;
                  Prism.highlightElement(code);
                } else {
                  // mark as failed
                  pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

                  if (xhr.status >= 400) {
                    code.textContent = FAILURE_MESSAGE(xhr.status, xhr.statusText);
                  } else {
                    code.textContent = FAILURE_EMPTY_MESSAGE;
                  }
                }
              }
            };

            xhr.send(null);
          }
        });
        Prism.plugins.fileHighlight = {
          /**
           * Executes the File Highlight plugin for all matching `pre` elements under the given container.
           *
           * Note: Elements which are already loaded or currently loading will not be touched by this method.
           *
           * @param {ParentNode} [container=document]
           */
          highlight: function highlight(container) {
            var elements = (container || document).querySelectorAll(SELECTOR);

            for (var i = 0, element; element = elements[i++];) {
              Prism.highlightElement(element);
            }
          }
        };
        var logged = false;
        /** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */

        Prism.fileHighlight = function () {
          if (!logged) {
            console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
            logged = true;
          }

          Prism.plugins.fileHighlight.highlight.apply(this, arguments);
        };
      })();
      /***/

    },

    /***/
    "wagW":
    /*!*********************************************!*\
      !*** ./markdown/src/lib/markdown-config.ts ***!
      \*********************************************/

    /*! exports provided: mdConfigToken */

    /***/
    function wagW(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "mdConfigToken", function () {
        return mdConfigToken;
      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");

      ;
      var mdConfigToken = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('wizdm-markdown-config-token');
      /***/
    },

    /***/
    "xbVm":
    /*!************************************************!*\
      !*** ./markdown/src/lib/markdown.component.ts ***!
      \************************************************/

    /*! exports provided: MarkdownRoot */

    /***/
    function xbVm(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "MarkdownRoot", function () {
        return MarkdownRoot;
      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /* harmony import */


      var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/cdk/coercion */
      "8LU1");
      /* harmony import */


      var _block_block_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! ./block/block.component */
      "bspj");
      /* harmony import */


      var _tree_tree_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! ./tree/tree.service */
      "6opK");

      var _c0 = ["wm-markdown", ""];

      function MarkdownRoot_ng_container_0_ng_container_2_h1_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "h1", 10);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          var ctx_r12 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("id", ctx_r12.toc(child_r1))("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-line", ctx_r12.pos(child_r1));
        }
      }

      function MarkdownRoot_ng_container_0_ng_container_2_h2_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "h2", 10);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("id", ctx_r13.toc(child_r1))("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-line", ctx_r13.pos(child_r1));
        }
      }

      function MarkdownRoot_ng_container_0_ng_container_2_h3_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "h3", 10);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          var ctx_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("id", ctx_r14.toc(child_r1))("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-line", ctx_r14.pos(child_r1));
        }
      }

      function MarkdownRoot_ng_container_0_ng_container_2_h4_4_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "h4", 10);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          var ctx_r15 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("id", ctx_r15.toc(child_r1))("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-line", ctx_r15.pos(child_r1));
        }
      }

      function MarkdownRoot_ng_container_0_ng_container_2_h5_5_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "h5", 10);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          var ctx_r16 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("id", ctx_r16.toc(child_r1))("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-line", ctx_r16.pos(child_r1));
        }
      }

      function MarkdownRoot_ng_container_0_ng_container_2_h6_6_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "h6", 10);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          var ctx_r17 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("id", ctx_r17.toc(child_r1))("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-line", ctx_r17.pos(child_r1));
        }
      }

      function MarkdownRoot_ng_container_0_ng_container_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, MarkdownRoot_ng_container_0_ng_container_2_h1_1_Template, 1, 3, "h1", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, MarkdownRoot_ng_container_0_ng_container_2_h2_2_Template, 1, 3, "h2", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, MarkdownRoot_ng_container_0_ng_container_2_h3_3_Template, 1, 3, "h3", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, MarkdownRoot_ng_container_0_ng_container_2_h4_4_Template, 1, 3, "h4", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, MarkdownRoot_ng_container_0_ng_container_2_h5_5_Template, 1, 3, "h5", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](6, MarkdownRoot_ng_container_0_ng_container_2_h6_6_Template, 1, 3, "h6", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", child_r1.depth === 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", child_r1.depth === 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", child_r1.depth === 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", child_r1.depth === 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", child_r1.depth === 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", child_r1.depth === 6);
        }
      }

      function MarkdownRoot_ng_container_0_p_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "p", 11);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("wm-inline", child_r1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-line", ctx_r3.pos(child_r1));
        }
      }

      function MarkdownRoot_ng_container_0_ng_container_4_ol_1_li_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "li", 16);
        }

        if (rf & 2) {
          var item_r29 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("wm-block", item_r29);
        }
      }

      function MarkdownRoot_ng_container_0_ng_container_4_ol_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "ol", 14);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, MarkdownRoot_ng_container_0_ng_container_4_ol_1_li_1_Template, 1, 1, "li", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("start", child_r1.start);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", child_r1.children);
        }
      }

      function MarkdownRoot_ng_container_0_ng_container_4_ul_2_li_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "li", 16);
        }

        if (rf & 2) {
          var item_r32 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("wm-block", item_r32);
        }
      }

      function MarkdownRoot_ng_container_0_ng_container_4_ul_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "ul");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, MarkdownRoot_ng_container_0_ng_container_4_ul_2_li_1_Template, 1, 1, "li", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", child_r1.children);
        }
      }

      function MarkdownRoot_ng_container_0_ng_container_4_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, MarkdownRoot_ng_container_0_ng_container_4_ol_1_Template, 2, 2, "ol", 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, MarkdownRoot_ng_container_0_ng_container_4_ul_2_Template, 2, 1, "ul", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", child_r1.ordered);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !child_r1.ordered);
        }
      }

      function MarkdownRoot_ng_container_0_table_5_tr_2_td_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "td", 11);
        }

        if (rf & 2) {
          var cell_r38 = ctx.$implicit;
          var i_r39 = ctx.index;

          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3).$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("wm-inline", cell_r38);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("align", child_r1.align[i_r39] || "");
        }
      }

      function MarkdownRoot_ng_container_0_table_5_tr_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "tr");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, MarkdownRoot_ng_container_0_table_5_tr_2_td_1_Template, 1, 2, "td", 17);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var row_r36 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", row_r36.children);
        }
      }

      function MarkdownRoot_ng_container_0_table_5_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "table");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "tbody");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, MarkdownRoot_ng_container_0_table_5_tr_2_Template, 2, 1, "tr", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-line", ctx_r5.pos(child_r1));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", child_r1.children);
        }
      }

      function MarkdownRoot_ng_container_0_hr_6_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "hr");
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-line", ctx_r6.pos(child_r1));
        }
      }

      function MarkdownRoot_ng_container_0_blockquote_7_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "blockquote", 16);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("wm-block", child_r1);
        }
      }

      function MarkdownRoot_ng_container_0_span_8_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "span", 18);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("wm-block", child_r1);
        }
      }

      function MarkdownRoot_ng_container_0_span_9_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "span", 19);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("wm-block", child_r1);
        }
      }

      function MarkdownRoot_ng_container_0_span_10_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "span", 20);
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("wm-block", child_r1);
        }
      }

      function MarkdownRoot_ng_container_0_pre_11_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "pre", 21);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](1, "      ");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](2, "\n      ");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "code");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtext"](5, "\n    ");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var child_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("disabled", ctx_r11.tree.disableHighlighting)("language", child_r1.lang)("wm-prism", child_r1.value);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("data-line", ctx_r11.pos(child_r1));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtextInterpolate"](child_r1.value);
        }
      }

      function MarkdownRoot_ng_container_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](1, 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, MarkdownRoot_ng_container_0_ng_container_2_Template, 7, 6, "ng-container", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, MarkdownRoot_ng_container_0_p_3_Template, 1, 2, "p", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, MarkdownRoot_ng_container_0_ng_container_4_Template, 3, 2, "ng-container", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, MarkdownRoot_ng_container_0_table_5_Template, 3, 2, "table", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](6, MarkdownRoot_ng_container_0_hr_6_Template, 1, 1, "hr", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](7, MarkdownRoot_ng_container_0_blockquote_7_Template, 1, 1, "blockquote", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](8, MarkdownRoot_ng_container_0_span_8_Template, 1, 1, "span", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](9, MarkdownRoot_ng_container_0_span_9_Template, 1, 1, "span", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](10, MarkdownRoot_ng_container_0_span_10_Template, 1, 1, "span", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](11, MarkdownRoot_ng_container_0_pre_11_Template, 6, 5, "pre", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var child_r1 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitch", child_r1.type);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "heading");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "paragraph");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "list");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "table");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "thematicBreak");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "blockquote");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "leftAligned");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "centerAligned");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "rightAligned");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", "code");
        }
      }
      /** Renders a markdown text into an angular view */


      var MarkdownRoot = /*#__PURE__*/function (_block_block_componen) {
        _inherits(MarkdownRoot, _block_block_componen);

        var _super = _createSuper(MarkdownRoot);

        function MarkdownRoot(tree) {
          var _this6;

          _classCallCheck(this, MarkdownRoot);

          _this6 = _super.call(this, tree);
          _this6.tree = tree;
          /** Navigation event emitted when a link is clicked on */

          _this6.navigate = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
          return _this6;
        }
        /** Returns the array of parsed footnotes */


        _createClass(MarkdownRoot, [{
          key: "notes",
          get: function get() {
            return this.tree.notes || [];
          }
        }, {
          key: "parse",
          set: function set(source) {
            // Makes sure source is a valid entry
            if (!source) {
              source = '';
            } // Parses the source md file into an mdAST syntax tree


            this.node = typeof source === 'string' ? this.tree.parse(source) : source;
          }
          /** Disables code highlighting */

        }, {
          key: "disablePrism",
          set: function set(value) {
            this.tree.disableHighlighting = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
          }
          /** Emoji Rendering Mode */

        }, {
          key: "emojiMode",
          set: function set(mode) {
            this.tree.emojiMode = mode;
          }
        }]);

        return MarkdownRoot;
      }(_block_block_component__WEBPACK_IMPORTED_MODULE_2__["MarkdownBlock"]);

      MarkdownRoot.ɵfac = function MarkdownRoot_Factory(t) {
        return new (t || MarkdownRoot)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_tree_tree_service__WEBPACK_IMPORTED_MODULE_3__["MarkdownTree"]));
      };

      MarkdownRoot.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: MarkdownRoot,
        selectors: [["", "wm-markdown", ""]],
        hostAttrs: [1, "wm-markdown"],
        inputs: {
          parse: ["wm-markdown", "parse"],
          disablePrism: ["disableHighlighting", "disablePrism"],
          emojiMode: "emojiMode"
        },
        outputs: {
          navigate: "navigate"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([_tree_tree_service__WEBPACK_IMPORTED_MODULE_3__["MarkdownTree"]]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
        attrs: _c0,
        decls: 1,
        vars: 1,
        consts: [[4, "ngFor", "ngForOf"], [3, "ngSwitch"], [4, "ngSwitchCase"], [3, "wm-inline", 4, "ngSwitchCase"], [3, "wm-block", 4, "ngSwitchCase"], ["align", "left", 3, "wm-block", 4, "ngSwitchCase"], ["align", "center", 3, "wm-block", 4, "ngSwitchCase"], ["align", "right", 3, "wm-block", 4, "ngSwitchCase"], [3, "disabled", "language", "wm-prism", 4, "ngSwitchCase"], [3, "id", "wm-inline", 4, "ngIf"], [3, "id", "wm-inline"], [3, "wm-inline"], [3, "start", 4, "ngIf"], [4, "ngIf"], [3, "start"], [3, "wm-block", 4, "ngFor", "ngForOf"], [3, "wm-block"], [3, "wm-inline", 4, "ngFor", "ngForOf"], ["align", "left", 3, "wm-block"], ["align", "center", 3, "wm-block"], ["align", "right", 3, "wm-block"], [3, "disabled", "language", "wm-prism"]],
        template: function MarkdownRoot_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, MarkdownRoot_ng_container_0_Template, 12, 11, "ng-container", 0);
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx.children);
          }
        },
        styles: [".wm-markdown[inline] * {\n  display: inline;\n}\n.wm-markdown p {\n  text-align: justify;\n}\n.wm-markdown td[align=left] {\n  text-align: left;\n}\n.wm-markdown td[align=center] {\n  text-align: center;\n}\n.wm-markdown td[align=right] {\n  text-align: right;\n}\n.wm-markdown span[align=left] > h1, .wm-markdown span[align=left] h2, .wm-markdown span[align=left] h3, .wm-markdown span[align=left] h4, .wm-markdown span[align=left] h5, .wm-markdown span[align=left] h6, .wm-markdown span[align=left] p {\n  text-align: left;\n}\n.wm-markdown span[align=left] > table {\n  margin-right: auto;\n}\n.wm-markdown span[align=center] > h1, .wm-markdown span[align=center] h2, .wm-markdown span[align=center] h3, .wm-markdown span[align=center] h4, .wm-markdown span[align=center] h5, .wm-markdown span[align=center] h6, .wm-markdown span[align=center] p {\n  text-align: center;\n}\n.wm-markdown span[align=center] > table {\n  margin-left: auto;\n  margin-right: auto;\n}\n.wm-markdown span[align=right] > h1, .wm-markdown span[align=right] h2, .wm-markdown span[align=right] h3, .wm-markdown span[align=right] h4, .wm-markdown span[align=right] h5, .wm-markdown span[align=right] h6, .wm-markdown span[align=right] p {\n  text-align: right;\n}\n.wm-markdown span[align=right] > table {\n  margin-left: auto;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2Jsb2NrLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdjO0VBQUksZUFBQTtBQURsQjtBQUlFO0VBQUksbUJBQUE7QUFETjtBQUtJO0VBQWtCLGdCQUFBO0FBRnRCO0FBR0k7RUFBb0Isa0JBQUE7QUFBeEI7QUFDSTtFQUFtQixpQkFBQTtBQUV2QjtBQU1NO0VBQ0UsZ0JBQUE7QUFKUjtBQU9NO0VBQ0Usa0JBQUE7QUFMUjtBQVVNO0VBQ0Usa0JBQUE7QUFSUjtBQVVNO0VBQ0UsaUJBQUE7RUFDQSxrQkFBQTtBQVJSO0FBYU07RUFDRSxpQkFBQTtBQVhSO0FBYU07RUFDRSxpQkFBQTtBQVhSIiwiZmlsZSI6ImJsb2NrLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiXG4ud20tbWFya2Rvd24ge1xuICAvLyBGb3JjZXMgYWxsIHRoZSBlbGVtZW50cyB0byBpbmxpbmUgXG4gICZbaW5saW5lXSB7ICogeyBkaXNwbGF5OiBpbmxpbmU7IH0gfVxuXG4gIC8vIEp1c3RpZmllcyBwYXJhZ3JhcGhzIGJ5IGRlZmF1bHRcbiAgcCB7IHRleHQtYWxpZ246IGp1c3RpZnk7IH1cblxuICAvLyBUYWJsZSBjZWxscyBhbGlnbmVtZW50XG4gIHRkIHtcbiAgICAmW2FsaWduPVwibGVmdFwiXSB7IHRleHQtYWxpZ246IGxlZnQ7IH1cbiAgICAmW2FsaWduPVwiY2VudGVyXCJdIHsgdGV4dC1hbGlnbjogY2VudGVyOyB9XG4gICAgJlthbGlnbj1cInJpZ2h0XCJdIHsgdGV4dC1hbGlnbjogcmlnaHQ7IH1cbiAgfVxuXG4gIC8vIEJsb2NrIGFsaWduZW1lbnRcbiAgc3BhbiB7XG5cbiAgICAvLyBBbGlnbnMgY2hpbGRyZW4gaGVhZGluZ3MgYW5kIHBhcmFncmFwaHNcbiAgICAmW2FsaWduPVwibGVmdFwiXSAgeyBcbiAgICAgICYgPiBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBwIHsgXG4gICAgICAgIHRleHQtYWxpZ246IGxlZnQ7IFxuICAgICAgfVxuICAgICAgLy8gQWxpZ25zIGNoaWxkcmVuIHRhYmxlc1xuICAgICAgJiA+IHRhYmxlIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiBhdXRvOyBcbiAgICAgIH1cbiAgICB9XG4gICAgICBcbiAgICAmW2FsaWduPVwiY2VudGVyXCJdIHsgXG4gICAgICAmID4gaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgcCB7IFxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IFxuICAgICAgfVxuICAgICAgJiA+IHRhYmxlIHsgXG4gICAgICAgIG1hcmdpbi1sZWZ0OiBhdXRvOyBcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiBhdXRvOyBcbiAgICAgIH1cbiAgICB9XG5cbiAgICAmW2FsaWduPVwicmlnaHRcIl0geyBcbiAgICAgICYgPiBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBwIHsgXG4gICAgICAgIHRleHQtYWxpZ246IHJpZ2h0OyBcbiAgICAgIH1cbiAgICAgICYgPiB0YWJsZSB7IFxuICAgICAgICBtYXJnaW4tbGVmdDogYXV0bzsgXG4gICAgICB9XG4gICAgfVxuICB9XG59Il19 */"],
        encapsulation: 2
      });
      /***/
    },

    /***/
    "xeKF":
    /*!***************************************************************!*\
      !*** ./wizdm/src/app/pages/static/static-resolver.service.ts ***!
      \***************************************************************/

    /*! exports provided: StaticResolver */

    /***/
    function xeKF(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "StaticResolver", function () {
        return StaticResolver;
      });
      /* harmony import */


      var _angular_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/router */
      "iInd");
      /* harmony import */


      var _angular_common_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/common/http */
      "IheW");
      /* harmony import */


      var _wizdm_content__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @wizdm/content */
      "g7MM");
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! rxjs/operators */
      "kU1M");
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! rxjs */
      "qCKp");
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! @angular/core */
      "8Y7J");
      /** Resolves the static document content */


      var StaticResolver = /*#__PURE__*/function () {
        function StaticResolver(router, selector, http) {
          _classCallCheck(this, StaticResolver);

          this.router = router;
          this.selector = selector;
          this.http = http;
          this.cache = new Map();
        } // Returns the default language of the content manager


        _createClass(StaticResolver, [{
          key: "defaultLang",
          get: function get() {
            return this.selector.config.defaultValue || 'en';
          }
          /** Resolves the content loading the requested source file */

        }, {
          key: "resolve",
          value: function resolve(route) {
            var _this7 = this;

            // Gets the root path from the route data
            var source = route.data.source || 'assets/doc'; // Resolves the language code from the route using the content selector resolver

            var lang = this.selector.resolve(route); // Clears the cache switching language

            if (lang !== this.currentLang) {
              this.cache.clear();
            } // Keeps track of the current language


            this.currentLang = lang; // Resolves the source file path from the route

            var path = this.resolvePath(route.paramMap); // Resolves the request from the cache whenever possible

            if (this.cache.has(path)) {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["of"])(this.cache.get(path));
            }

            console.log('Loading document:', path + '.md'); // Loads the document .md file in the requested language folder first

            return this.http.get("".concat(source, "/").concat(lang, "/").concat(path, ".md"), {
              responseType: 'text'
            }).pipe( // Catches the possible error
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["catchError"])(function (e) {
              // On file not found (404)...
              if (lang !== _this7.defaultLang && e.status === 404) {
                console.log('404 File not found, reverting to default language:', _this7.defaultLang); // Loads the same document in the default language instead

                return _this7.http.get("".concat(source, "/").concat(_this7.defaultLang, "/").concat(path, ".md"), {
                  responseType: 'text'
                });
              }

              console.error('Unable to load, redirecting to not-found', e);

              _this7.router.navigate(['/not-found']);

              return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["of"])('');
            }), // Composes the static content
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (body) {
              return {
                body: body,
                path: path
              };
            }), // Caches the content to avoid reloads
            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["tap"])(function (content) {
              return _this7.cache.set(path, content);
            }));
          }
          /** Path resolver helper */

        }, {
          key: "resolvePath",
          value: function resolvePath(params) {
            return params && params.keys // Matches all the params starting with 'path'
            .filter(function (key) {
              return !!key.match(/^path\d*$/);
            }) // Gets the corresponding values
            .map(function (key) {
              return params.get(key);
            }) // Joins the parameters into the full path
            .join('/');
          }
          /** Parses the comments from source md file */

        }, {
          key: "parseComments",
          value: function parseComments(source) {
            var _this8 = this;

            var out = {};

            if (!source) {
              return out;
            }

            var comments = /<!--([\s\S]*?)-->/g;
            var pairs = /\s*(\w+):\s*([\w-_.\/]*)\s*/g;
            this.parse(comments, source, function (comment) {
              _this8.parse(pairs, comment[1], function (pair) {
                if (out[pair[1]]) {
                  return;
                }

                out[pair[1]] = pair[2];
              });
            });
            return out;
          }
        }, {
          key: "parse",
          value: function parse(rx, source, fn) {
            if (typeof fn !== 'function') {
              throw new Error("fn must be a function");
            }

            var match;

            while (match = rx.exec(source)) {
              // Prevents the zero-length match infinite loop for all browsers
              if (match.index == rx.lastIndex) {
                rx.lastIndex++;
              }

              ;
              fn(match);
            }
          }
        }]);

        return StaticResolver;
      }();

      StaticResolver.ɵfac = function StaticResolver_Factory(t) {
        return new (t || StaticResolver)(_angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵinject"](_angular_router__WEBPACK_IMPORTED_MODULE_0__["Router"]), _angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵinject"](_wizdm_content__WEBPACK_IMPORTED_MODULE_2__["SelectorResolver"]), _angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵinject"](_angular_common_http__WEBPACK_IMPORTED_MODULE_1__["HttpClient"]));
      };

      StaticResolver.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_5__["ɵɵdefineInjectable"]({
        token: StaticResolver,
        factory: StaticResolver.ɵfac
      });
      /***/
    },

    /***/
    "xkQk":
    /*!**************************************!*\
      !*** ./node_modules/trough/index.js ***!
      \**************************************/

    /*! no static exports found */

    /***/
    function xkQk(module, exports, __webpack_require__) {
      "use strict";

      var wrap = __webpack_require__(
      /*! ./wrap.js */
      "EBzq");

      module.exports = trough;
      trough.wrap = wrap;
      var slice = [].slice; // Create new middleware.

      function trough() {
        var fns = [];
        var middleware = {};
        middleware.run = run;
        middleware.use = use;
        return middleware; // Run `fns`.  Last argument must be a completion handler.

        function run() {
          var index = -1;
          var input = slice.call(arguments, 0, -1);
          var done = arguments[arguments.length - 1];

          if (typeof done !== 'function') {
            throw new Error('Expected function as last argument, not ' + done);
          }

          next.apply(null, [null].concat(input)); // Run the next `fn`, if any.

          function next(err) {
            var fn = fns[++index];
            var params = slice.call(arguments, 0);
            var values = params.slice(1);
            var length = input.length;
            var pos = -1;

            if (err) {
              done(err);
              return;
            } // Copy non-nully input into values.


            while (++pos < length) {
              if (values[pos] === null || values[pos] === undefined) {
                values[pos] = input[pos];
              }
            }

            input = values; // Next or done.

            if (fn) {
              wrap(fn, next).apply(null, input);
            } else {
              done.apply(null, [null].concat(input));
            }
          }
        } // Add `fn` to the list.


        function use(fn) {
          if (typeof fn !== 'function') {
            throw new Error('Expected `fn` to be a function, not ' + fn);
          }

          fns.push(fn);
          return middleware;
        }
      }
      /***/

    },

    /***/
    "zK1H":
    /*!************************************************!*\
      !*** ./node_modules/remark-parse/lib/parse.js ***!
      \************************************************/

    /*! no static exports found */

    /***/
    function zK1H(module, exports, __webpack_require__) {
      "use strict";

      var xtend = __webpack_require__(
      /*! xtend */
      "U6jy");

      var removePosition = __webpack_require__(
      /*! unist-util-remove-position */
      "cBNe");

      module.exports = parse;
      var lineFeed = '\n';
      var lineBreaksExpression = /\r\n|\r/g; // Parse the bound file.

      function parse() {
        var self = this;
        var value = String(self.file);
        var start = {
          line: 1,
          column: 1,
          offset: 0
        };
        var content = xtend(start);
        var node; // Clean non-unix newlines: `\r\n` and `\r` are all changed to `\n`.
        // This should not affect positional information.

        value = value.replace(lineBreaksExpression, lineFeed); // BOM.

        if (value.charCodeAt(0) === 0xfeff) {
          value = value.slice(1);
          content.column++;
          content.offset++;
        }

        node = {
          type: 'root',
          children: self.tokenizeBlock(value, content),
          position: {
            start: start,
            end: self.eof || xtend(start)
          }
        };

        if (!self.options.position) {
          removePosition(node, true);
        }

        return node;
      }
      /***/

    }
  }]);
})();
//# sourceMappingURL=pages-static-static-module-es5.js.map